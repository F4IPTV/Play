package com.example.filin4iktv

import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.*
import android.webkit.JavascriptInterface
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import android.util.Log
import org.json.JSONArray
import org.json.JSONObject
import java.io.*
import java.net.HttpURLConnection
import java.net.URL

class MainActivity : AppCompatActivity() {

    private lateinit var webView: WebView
    private lateinit var webInterface: WebAppInterface

    @SuppressLint("SetJavaScriptEnabled")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        checkStoragePermissions()

        cacheDir.listFiles()?.forEach {
            if (it.name.endsWith(".apk")) it.delete()
        }

        webView = WebView(this)
        webView.id = android.R.id.content
        setContentView(webView)

        webView.settings.javaScriptEnabled = true
        webView.webViewClient = WebViewClient()
        webInterface = WebAppInterface(this)
        webView.addJavascriptInterface(webInterface, "AndroidInterface")
        webView.loadUrl("https://f4iptv.github.io/Play/index.html")
    }

    override fun onResume() {
        super.onResume()
        if (webInterface.installQueue.isNotEmpty()) {
            webInterface.installNextApkManually()
        }
    }

    private fun checkStoragePermissions() {
        val permissions = arrayOf(
            Manifest.permission.READ_EXTERNAL_STORAGE,
            Manifest.permission.WRITE_EXTERNAL_STORAGE
        )

        val missingPermissions = permissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }

        if (missingPermissions.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, missingPermissions.toTypedArray(), 100)
        }
    }

    inner class WebAppInterface(private val context: Context) {

        val installQueue = mutableListOf<File>()

        @JavascriptInterface
        fun startInstallation(groupName: String) {
            Thread {
                try {
                    val configUrl = "https://f4iptv.github.io/Play/config.json"
                    val configText = URL(configUrl).readText()
                    val config = JSONObject(configText)

                    val group = config.getJSONObject("groups").getJSONObject(groupName)
                    val tags = group.getJSONArray("tags")

                    installQueue.clear()

                    val apps = config.getJSONArray("apps")
                    val appsToInstall = mutableListOf<String>()

                    for (i in 0 until apps.length()) {
                        val app = apps.getJSONObject(i)
                        if (tagsMatch(tags, app.getJSONArray("tags"))) {
                            val url = app.getString("url")
                            if (url.isNotBlank()) appsToInstall.add(url)
                        }
                    }

                    sendMessageToWebView("COUNT:${appsToInstall.size}")

                    for (url in appsToInstall) {
                        val apkFile = downloadApkToCache(url)
                        if (apkFile != null) installQueue.add(apkFile)
                        sendMessageToWebView("DOWNLOADED")
                    }

                    val backups = config.getJSONArray("backups")
                    for (i in 0 until backups.length()) {
                        val backup = backups.getJSONObject(i)
                        if (tagsMatch(tags, backup.getJSONArray("tags"))) {
                            val fileUrl = backup.getString("url")
                            val folder = backup.getString("target_folder")
                            if (fileUrl.isNotBlank() && folder.isNotBlank()) downloadFile(fileUrl, folder)
                        }
                    }

                    Handler(Looper.getMainLooper()).post {
                        if (installQueue.isNotEmpty()) {
                            installNextApk()
                        } else {
                            sendMessageToWebView("✅ Установка завершена. Нет приложений.")
                        }
                    }

                } catch (e: Exception) {
                    e.printStackTrace()
                    sendMessageToWebView("❌ Ошибка установки: ${e.message}")
                }
            }.start()
        }

        @JavascriptInterface
        fun installNextApkManually(): String {
            return if (installQueue.isEmpty()) {
                sendMessageToWebView("✅ Очередь пуста, установка завершена.")
                "empty"
            } else {
                installNextApk()
                "ok"
            }
        }

        fun installNextApk() {
            if (installQueue.isEmpty()) {
                sendMessageToWebView("✅ Установка завершена. Больше нет приложений.")
                return
            }

            val apkFile = installQueue.removeAt(0)
            val uri = FileProvider.getUriForFile(context, "${context.packageName}.provider", apkFile)

            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(uri, "application/vnd.android.package-archive")
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }

            context.startActivity(intent)
        }

        private fun tagsMatch(groupTags: JSONArray, itemTags: JSONArray): Boolean {
            for (i in 0 until groupTags.length()) {
                val tag = groupTags.getString(i)
                for (j in 0 until itemTags.length()) {
                    if (tag.equals(itemTags.getString(j), ignoreCase = true)) {
                        return true
                    }
                }
            }
            return false
        }

        private fun downloadApkToCache(urlStr: String): File? {
            return try {
                val fileName = "install_${System.currentTimeMillis()}.apk"
                val file = File(context.cacheDir, fileName)

                val input = URL(urlStr).openStream()
                val output = FileOutputStream(file)
                input.copyTo(output)
                input.close()
                output.close()

                file
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }

        private fun downloadFile(urlStr: String, targetFolder: String) {
            try {
                val fileName = Uri.parse(urlStr).lastPathSegment ?: return

                val baseDir = when {
                    targetFolder.startsWith("Download") -> Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                    targetFolder.startsWith("Documents") -> Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS)
                    else -> Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                }

                val relativePath = targetFolder.substringAfter("/", "")
                val targetDir = if (relativePath.isNotEmpty()) File(baseDir, relativePath) else baseDir

                if (!targetDir.exists()) {
                    if (!targetDir.mkdirs()) return
                }

                val outFile = File(targetDir, fileName)

                val url = URL(urlStr)
                val connection = url.openConnection() as HttpURLConnection
                connection.connect()

                val input = BufferedInputStream(connection.inputStream)
                val output = FileOutputStream(outFile)

                input.copyTo(output)
                input.close()
                output.close()

            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        private fun sendMessageToWebView(message: String) {
            Handler(Looper.getMainLooper()).post {
                (context as? MainActivity)?.runOnUiThread {
                    val webView = (context as MainActivity).findViewById<WebView>(android.R.id.content).rootView as WebView
                    webView.evaluateJavascript("updateStatus('${message.replace("'", "\\'")}')", null)
                }
            }
        }
    }
}
