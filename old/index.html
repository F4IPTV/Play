<!DOCTYPE html>
<html lang="ru" class="splash-open" style="overflow:hidden;">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
  <title>FastInstaller_cloud</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 40px; background-color: #000; color: #fff; }
    select, input, button { font-size: 18px; padding: 10px; margin: 10px; width: 250px; }
    #status { margin-top: 20px; font-weight: bold; min-height: 24px; transition: opacity .5s ease; opacity: 0; position: fixed; top: 10px; left: 0; right: 0; text-align: center; z-index: 1001; }
    #status.visible { opacity: 1; }
    .spin { display: inline-block; animation: spin 1s linear infinite; }
    @keyframes spin { from{transform:rotate(0)} to{transform:rotate(360deg)} }
    #adbScanStatus {
      transition: color .2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    #adbScanStatus .adb-scan-spinner {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.22);
      border-top-color: #00cfff;
      animation: spin 0.95s linear infinite;
      box-sizing: border-box;
    }
    #adbScanStatus .adb-scan-spinwrap {
      display: inline-flex;
      align-items: center;
    }
    #adbScanStatus.adb-scan-complete {
      color: #4caf50;
    }

    
    .card-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-top: 12px;
      margin-bottom: 12px;
    }
    .card {
      background-color: #2a2a2a; border-radius: 10px; padding: 2px 2px 2px;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: #fff; font-size: 13px; border: 2px solid transparent; transition: all .2s ease; cursor: pointer;
      text-align: center; line-height: 1.1;
      flex: 0 0 calc((100% - 20px) / 3);
      max-width: calc((100% - 20px) / 3);
      min-width: 0;
      width: auto; height: auto;
      box-sizing: border-box;
    }
    .card img {
      margin-top: 0;
      margin-bottom: 4px;
    }
    .card .group-title {
      display: -webkit-box;
      line-clamp: 2;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      line-height: 1.1;
      text-align: center;
    }
    .card:hover, .card:focus { background-color: #004d61; border-color: #00cfff; box-shadow: 0 0 10px rgba(0,0,0,.5); outline: none; }
    .card.selected { background-color: #00cfff; color: #000; border: 2px solid #fff; }

    .modal { 
      position: fixed; 
      inset: 0; 
      background: rgba(0,0,0,.7); 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      z-index: 999; 
      outline: none;
      overscroll-behavior: contain;
      touch-action: none; /* Блокируем touch события на фоне модалки */
    }

    .adb-status-indicator {
      font-size: 13px;
      text-align: center;
      margin-top: -6px;
      margin-bottom: 10px;
      color: rgba(255,255,255,0.75);
      transition: color .2s ease;
    }
    .storage-usage-badge {
      font-size: 13px;
      opacity: 0.85;
      margin-left: 6px;
      white-space: nowrap;
    }
    .adb-status-indicator.connected {
      color: #0ff;
      font-weight: 600;
    }
    .modal-header {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      flex-wrap: nowrap;
    }
    .modal-header-title {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .modal-content {
      position: relative;
      background: #111;
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      max-height: 80vh;
      overflow: hidden;
      width: 80%;
      border: 1px solid #333;
      touch-action: auto;
      overscroll-behavior: contain;
    }
    .modal-header-tools {
      position: absolute;
      top: -5px;
      right: -5px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      z-index: 6;
    }
    .modal-header-tools button {
      width: 36px;
      height: 36px;
      border: 2px solid transparent;
      background: transparent;
      padding: 4px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      -webkit-tap-highlight-color: transparent;
      transition: border-color .2s ease, box-shadow .2s ease, background-color .2s ease;
    }
    .modal-header-tools button img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
    }
    .modal-header-tools button:focus,
    .modal-header-tools button:focus-visible,
    .modal-header-tools button:hover,
    .modal-header-tools button:active {
      outline: none !important;
      border-color: #fff;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.08);
      filter: none !important;
    }
    .modal-adb-indicator {
      width: 42px;
      height: 42px;
      border: none;
      background: transparent;
      padding: 0;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      z-index: 5;
      -webkit-tap-highlight-color: transparent;
      appearance: none;
    }
    .modal-adb-indicator:focus-visible {
      outline: none;
    }
    .modal-adb-indicator img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
    }
    .modal-adb-indicator:hover,
    .modal-adb-indicator:focus,
    .modal-adb-indicator:focus-visible,
    .modal-adb-indicator:active {
      outline: none !important;
      background: transparent !important;
      box-shadow: none !important;
      filter: none !important;
    }
    /* Пульт ADB */
    #adbRemoteModal .adb-remote-grid {
      position: relative;
      width: 220px;
      height: 220px;
      margin: 10px auto 14px;
    }
    #adbRemoteModal .modal-content {
      min-height: 72vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    #adbRemoteModal .adb-remote-top {
      width: 100%;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      margin-top: -6px;
    }
    #adbRemoteModal.keyboard-open .adb-remote-top {
      display: none;
    }
    #adbRemoteModal.keyboard-open .adb-remote-grid,
    #adbRemoteModal.keyboard-open .adb-remote-row {
      display: none;
    }
    #adbRemoteModal.keyboard-open .adb-remote-grid {
      margin-top: 6px;
    }
    #adbRemoteModal .adb-remote-left-buttons {
      display: flex;
      gap: 10px;
    }
    #adbRemoteModal .adb-remote-volume {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }
    #adbRemoteModal .adb-remote-round-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #3b3b3b;
      background: #2b2b2b;
      color: #fff;
      font-size: 18px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.35), inset 0 -2px 4px rgba(0,0,0,0.35);
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }
    #adbRemoteModal .adb-remote-icon {
      width: 26px;
      height: 26px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    #adbRemoteModal .adb-remote-icon svg {
      width: 26px;
      height: 26px;
      display: block;
    }
    #adbRemoteModal .adb-remote-volume-rocker {
      width: 54px;
      height: 108px;
      border-radius: 999px;
      border: 2px solid #3b3b3b;
      background: #232323;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      box-shadow: 0 2px 6px rgba(0,0,0,0.35), inset 0 -2px 4px rgba(0,0,0,0.35);
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }
    #adbRemoteModal .adb-remote-rocker-btn {
      height: 48px;
      width: 100%;
      flex: 1 1 auto;
      border: none;
      background: transparent;
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      outline: none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
      position: relative;
    }
    #adbRemoteModal .adb-remote-rocker-btn::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 22px;
      height: 22px;
      background:
        linear-gradient(#ffffff, #ffffff) center/22px 3px no-repeat;
      z-index: 1;
    }
    #adbRemoteModal .adb-remote-rocker-btn.plus::after {
      transform: translate(-50%, -60%);
    }
    #adbRemoteModal .adb-remote-rocker-btn.minus::after {
      transform: translate(-50%, -40%);
    }
    #adbRemoteModal .adb-remote-rocker-btn.plus::after {
      background:
        linear-gradient(#ffffff, #ffffff) center/22px 3px no-repeat,
        linear-gradient(#ffffff, #ffffff) center/3px 22px no-repeat;
    }
    #adbRemoteModal .adb-remote-icon svg path,
    #adbRemoteModal .adb-remote-icon svg line,
    #adbRemoteModal .adb-remote-icon svg circle,
    #adbRemoteModal .adb-remote-icon svg rect {
      stroke: #fff;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    #adbRemoteModal .adb-remote-icon.power svg circle {
      stroke: #ff3b30;
    }
    #adbRemoteModal .adb-remote-icon.power svg line {
      stroke: #ff3b30;
    }
    #adbRemoteModal .adb-remote-dpad {
      position: absolute;
      inset: 0;
      margin: auto;
      width: 220px;
      height: 220px;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 40%, #f6f6f6 0%, #e9e9e9 60%, #d8d8d8 100%);
      border: 2px solid #f4f4f4;
      box-shadow: 0 6px 12px rgba(0,0,0,0.28), inset 0 -4px 6px rgba(0,0,0,0.18);
      cursor: pointer;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      outline: none;
      user-select: none;
    }
    #adbRemoteModal .adb-remote-dpad {
      --dpad-line-color: rgba(0,0,0,0.18);
      --dpad-gap: 58px;
      --dpad-highlight-start: 315deg;
    }
    #adbRemoteModal .adb-remote-dpad-highlight {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 120ms ease;
      background: conic-gradient(
        from var(--dpad-highlight-start),
        rgba(255,255,255,0.35) 0deg,
        rgba(255,255,255,0.35) 90deg,
        transparent 90deg,
        transparent 360deg
      );
      pointer-events: none;
    }
    #adbRemoteModal .adb-remote-dpad[data-dir] .adb-remote-dpad-highlight {
      opacity: 1;
    }
    #adbRemoteModal .adb-remote-dpad[data-dir="up"] {
      --dpad-highlight-start: 315deg;
    }
    #adbRemoteModal .adb-remote-dpad[data-dir="right"] {
      --dpad-highlight-start: 45deg;
    }
    #adbRemoteModal .adb-remote-dpad[data-dir="down"] {
      --dpad-highlight-start: 135deg;
    }
    #adbRemoteModal .adb-remote-dpad[data-dir="left"] {
      --dpad-highlight-start: 225deg;
    }
    #adbRemoteModal .adb-remote-dpad-line {
      position: absolute;
      z-index: 2;
      pointer-events: none;
    }
    #adbRemoteModal .adb-remote-dpad-line.vertical {
      left: 50%;
      top: 0;
      transform: translateX(-50%) rotate(45deg);
      width: 2px;
      height: 100%;
      background: linear-gradient(
        to bottom,
        var(--dpad-line-color) 0,
        var(--dpad-line-color) calc(50% - var(--dpad-gap)),
        transparent calc(50% - var(--dpad-gap)),
        transparent calc(50% + var(--dpad-gap)),
        var(--dpad-line-color) calc(50% + var(--dpad-gap)),
        var(--dpad-line-color) 100%
      );
    }
    #adbRemoteModal .adb-remote-dpad-line.horizontal {
      top: 50%;
      left: 0;
      transform: translateY(-50%) rotate(45deg);
      height: 2px;
      width: 100%;
      background: linear-gradient(
        to right,
        var(--dpad-line-color) 0,
        var(--dpad-line-color) calc(50% - var(--dpad-gap)),
        transparent calc(50% - var(--dpad-gap)),
        transparent calc(50% + var(--dpad-gap)),
        var(--dpad-line-color) calc(50% + var(--dpad-gap)),
        var(--dpad-line-color) 100%
      );
    }
    #adbRemoteModal .adb-remote-row {
      width: 100%;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      justify-items: center;
      align-items: center;
      margin-top: 8px;
    }
    #adbRemoteModal .adb-remote-row.menu {
      grid-template-columns: 1fr;
      margin-top: 6px;
    }
    #adbRemoteModal .adb-remote-btn {
      position: relative;
      z-index: 2;
      width: 58px;
      height: 58px;
      padding: 6px;
      font-size: 18px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #2b2b2b;
      border: 2px solid #3b3b3b;
      color: #fff;
      box-shadow: 0 2px 6px rgba(0,0,0,0.35), inset 0 -2px 4px rgba(0,0,0,0.35);
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }
    #adbRemoteModal .adb-remote-btn:focus,
    #adbRemoteModal .adb-remote-btn:focus-visible,
    #adbRemoteModal .adb-remote-btn:hover,
    #adbRemoteModal .adb-remote-btn:active {
      outline: none !important;
      border-color: #6a6a6a;
      background: #343434;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 2px 6px rgba(0,0,0,0.35);
      filter: none !important;
    }
    #adbRemoteModal .adb-remote-grid .adb-remote-ok {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 96px;
      height: 96px;
      font-size: 15px;
      background: #3a3a3a;
      border-color: #4a4a4a;
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      border: 2px solid #4a4a4a;
      box-shadow: 0 3px 8px rgba(0,0,0,0.35), inset 0 -2px 4px rgba(0,0,0,0.35);
      cursor: pointer;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      outline: none;
      user-select: none;
    }
    #adbRemoteModal .adb-remote-grid .adb-remote-ok:active {
      box-shadow: 0 0 0 3px rgba(255,255,255,0.25), 0 3px 8px rgba(0,0,0,0.35), inset 0 -2px 4px rgba(0,0,0,0.35);
      filter: brightness(1.06);
    }
    #adbRemoteModal .adb-remote-btn.wide {
      width: 110px;
      height: 44px;
      font-size: 14px;
      border-radius: 999px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.35), inset 0 -2px 4px rgba(0,0,0,0.35);
    }

    /* Панель клавиатуры в пульте ДУ */
    #adbRemoteModal .adb-remote-keyboard-panel {
      width: 100%;
      margin: 6px 0 2px;
      padding: 8px 10px;
      background: #1e1e1e;
      border-radius: 12px;
      border: 1px solid #3b3b3b;
      max-height: 170px;
      overflow: hidden;
      position: relative;
      z-index: 2;
    }
    #adbRemoteModal.keyboard-open .adb-remote-keyboard-panel {
      margin: 10px 0 16px;
      max-height: none;
      overflow: visible;
    }
    #adbRemoteModal .adb-remote-keyboard-panel-inner {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    #adbRemoteModal .adb-remote-keyboard-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: nowrap;
    }
    #adbRemoteModal .adb-remote-keyboard-nav {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex: 1 1 auto;
      justify-content: center;
    }
    #adbRemoteModal .adb-remote-keyboard-nav-btn {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      border: 2px solid #3b3b3b;
      background: #2b2b2b;
      color: #fff;
      font-size: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      padding: 0;
    }
    #adbRemoteModal .adb-remote-keyboard-nav-btn:hover,
    #adbRemoteModal .adb-remote-keyboard-nav-btn:focus {
      border-color: #5a5a5a;
      background: #343434;
    }
    #adbRemoteModal .adb-remote-keyboard-label {
      font-size: 13px;
      color: #aaa;
      margin: 0;
    }
    #adbRemoteModal .adb-remote-keyboard-status {
      font-size: 10px;
      color: #666;
      margin-left: 8px;
    }
    #adbRemoteModal .adb-remote-keyboard-header-btns {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #adbRemoteModal .adb-remote-keyboard-icon-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid #3b3b3b;
      background: #2b2b2b;
      color: #fff;
      font-size: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      padding: 0;
    }
    #adbRemoteModal .adb-remote-keyboard-icon-btn:hover,
    #adbRemoteModal .adb-remote-keyboard-icon-btn:focus {
      border-color: #5a5a5a;
      background: #343434;
    }
    #adbRemoteModal .adb-remote-keyboard-close-btn {
      font-size: 16px;
    }
    #adbRemoteModal .adb-remote-keyboard-input {
      width: 100%;
      min-height: 40px;
      max-height: 60px;
      padding: 8px 10px;
      font-size: 14px;
      line-height: 1.4;
      color: #fff;
      background: #2b2b2b;
      border: 2px solid #3b3b3b;
      border-radius: 8px;
      resize: vertical;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    #adbRemoteModal .adb-remote-keyboard-input::placeholder {
      color: #666;
    }
    #adbRemoteModal .adb-remote-keyboard-input:focus {
      outline: none;
      border-color: #5a5a5a;
    }
    #adbRemoteModal .adb-remote-keyboard-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }
    #adbRemoteModal .adb-remote-keyboard-btn {
      flex: 0 0 auto;
      min-width: 180px;
      padding: 8px 12px;
      font-size: 13px;
      border-radius: 8px;
      border: 2px solid #3b3b3b;
      background: #2b2b2b;
      color: #fff;
    }
    #adbRemoteModal .adb-remote-keyboard-btn.secondary {
      background: #252525;
      border-color: #353535;
      color: #ccc;
    }
    #adbRemoteModal .adb-remote-keyboard-debug {
      display: flex;
      justify-content: center;
      margin-top: 6px;
    }
    #adbRemoteModal .adb-remote-keyboard-debug-btn {
      padding: 4px 8px;
      font-size: 11px;
      color: #777;
      background: transparent;
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    #adbRemoteModal .adb-remote-keyboard-debug-btn:hover {
      color: #aaa;
      border-color: #444;
    }

    /* Кнопки-иконки у блока ввода пароля */
    #passwordRow .password-row-icon-btn,
    #passwordRow .modal-adb-indicator {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 2px solid transparent;
      padding: 6px;
      background: transparent;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    #passwordRow .password-row-icon-btn img,
    #passwordRow .modal-adb-indicator img {
      height: 30px;
      width: 30px;
      object-fit: contain;
    }
    #passwordRow .password-row-icon-btn:focus,
    #passwordRow .password-row-icon-btn:focus-visible,
    #passwordRow .modal-adb-indicator:focus,
    #passwordRow .modal-adb-indicator:focus-visible {
      outline: none !important;
      border-color: #fff;
      background: transparent !important;
      box-shadow: none !important;
      filter: none !important;
    }

    #adbScannerModal .modal-content {
      max-height: 85vh;
      overflow-y: auto;
      overscroll-behavior: contain;
      -webkit-overflow-scrolling: touch;
    }

    /* Прокрутка для модалки "Разное" */
    #miscModal .modal-content {
      display: flex;
      flex-direction: column;
      max-height: 80vh;
    }

    #miscModal .misc-buttons-container {
      max-height: 60vh;
      overflow-y: auto;
      overscroll-behavior: contain;
      scroll-behavior: auto;
      scrollbar-gutter: stable both-edges;
      margin-bottom: 20px;
    }

    body.modal-open { 
      overflow: hidden; 
      position: fixed; 
      width: 100%; 
      height: 100%; 
      overscroll-behavior: none; 
    }
    body.splash-open { overflow: hidden; height: 100vh; }
    html.splash-open { overflow: hidden; height: 100vh; }
    body.splash-open > :not(#splash) { display: none !important; }
    html, body { overscroll-behavior: none; }
    html.splash-open::-webkit-scrollbar, body.splash-open::-webkit-scrollbar { width: 0; height: 0; }

    /* Список компонентов внутри модалки групп */
    #modalListContainer { max-height: 60vh; overflow-y: auto; overscroll-behavior: contain; scroll-behavior: auto; scrollbar-gutter: stable both-edges; }
    #modalList { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; justify-items: center; }
    
    /* Адаптация модального списка для портретной ориентации - 1 колонка для лучшей эстетики на телефонах */
    @media (orientation: portrait) {
      #modalList { 
        grid-template-columns: 1fr; 
        gap: 12px; 
        max-width: 320px; 
        margin: 0 auto; 
      }
      
      #modalList .component-btn {
        width: 100%;
        max-width: 300px;
        margin: 0 auto;
      }
      
      #installAllBtn {
        width: 100%;
        max-width: 300px;
        margin: 12px auto 0;
      }
    }
    #modalList .component-btn { transition: none !important; position: relative; }
    #modalList .component-btn:focus,
    #installAllBtn:focus,
    #installAllBtn.selected { background-color: #00cfff; box-shadow: 0 0 0 1px rgba(255, 255, 255, 0) !important; border-color: #fff !important; outline: none; }
    /* Перенос длинных названий без пробелов и обрезка до 2 строк */
#modalList .component-btn {
  white-space: normal;
  overflow-wrap: anywhere;   /* для сплошных строк */
  word-break: break-word;    /* fallback */
  line-height: 1.25;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;     /* максимум 2 строки */
  line-clamp: 2;             /* стандартное свойство для совместимости */
  overflow: hidden;
  text-overflow: ellipsis;
  min-height: 48px;          /* чтобы высота не "прыгала" */
  max-height: 48px; 
}
    #modalList .component-btn.selected {
      background-color: #003b4a;
      border-color: #fff;
      box-shadow: 0 0 0 1px #fff;
    }
    #installAllBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #groupSelectActions { display: none; gap: 8px; justify-content: center; margin-top: 10px; }
    #groupSelectActions.visible { display: flex; }
    #groupSelectActions .component-btn { width: auto; min-width: 140px; }
    #modalList.selection-mode .component-btn::after {
      content: "";
      position: absolute;
      top: 50%;
      right: 6px;
      width: 14px;
      height: 14px;
      border: 2px solid #fff;
      border-radius: 4px;
      background: transparent;
      box-sizing: border-box;
      transform: translateY(-50%);
      z-index: 0;
    }
    #modalList.selection-mode .component-btn.selected::after {
      border-color: #00cfff;
      background: #00cfff;
    }
    #modalList.selection-mode .component-btn.selected::before {
      content: "✓";
      position: absolute;
      top: 50%;
      right: 8px;
      font-size: 16px;
      color: #000;
      transform: translateY(-50%);
      font-weight: 700;
      line-height: 1;
      z-index: 1;
    }
    /* Кнопки в стиле Google TV */
    button {
      background-color: #004d61; color: #fff; border: 2px solid transparent; border-radius: 8px;
      padding: 10px 20px; font-size: 14px; width: 250px; cursor: pointer;
      transition: background-color .2s ease, box-shadow .2s ease, border-color .2s ease; box-sizing: border-box;
    }
    button:hover { background-color: #00cfff; }
    button:focus { outline: none; border-color: #fff; box-shadow: 0 0 10px #004d61; }

    .system-buttons { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-top: 12px; }
    .sys-btn {
      flex: 1 1 calc(33.33% - 20px); min-width: 100px; max-width: 240px; padding: 3px; font-size: 13px; text-align: center;
      background-color: #004d61; color: #fff; border: 2px solid transparent; border-radius: 10px; cursor: pointer; transition: background-color .3s ease;
    }
    .sys-btn:hover { background-color: #00cfff; }
    .sys-btn:focus {
      border-color: #fff;
      box-shadow: 0 0 10px #004d61;
    }
    #mainSystemButtons .sys-btn:focus {
      background-color: #00cfff;
      color: #000;
      border-color: #fff;
      box-shadow: 0 0 10px #004d61;
    }
    /* В модалке "Разное" отключаем hover, чтобы не мешал подсветке по фокусу */
    #miscModal .sys-btn { background-color: #004d61; color:#fff; }
    #miscModal .sys-btn:hover { background-color: #004d61; }

    /* ATV список приложений */
    .app-filters { display:flex; flex-wrap:wrap; justify-content:center; gap:8px; margin:8px 0 12px; }
    .app-filters .sys-btn {
      min-width: 92px;
      max-width: 140px;
      padding: 8px;
      font-size: 12px;
      background: #10131A;
      border: 1px solid #1f3a5a;
      color: #e8f0ff;
    }
    .app-filters .sys-btn.active,
    .app-filters .sys-btn:focus {
      background: #10131A;
      border-color: #3fa9f5;
      color: #fff;
    }
    .apps-list { display:flex; flex-direction:column; gap:8px; }
    .app-row {
      display:flex; gap:12px; align-items:flex-start; padding:10px 12px;
      background:#10131A; border-radius:14px; border:1px solid #1f3a5a;
      box-shadow: 0 4px 10px rgba(0,0,0,0.28);
    }
    /* ТВ: убираем hover, чтобы не "залипало" при D-pad */
    #atvAppsList .app-row:hover,
    #launcherList .app-row:hover { background:#10131A; }
    /* ТВ/общий случай: подсветка по фокусу/selected */
    #atvAppsList .app-row:focus-visible,
    #atvAppsList .app-row.selected,
    #launcherList .app-row:focus-visible,
    #launcherList .app-row.selected {
      background:#152b45;
      border-color:#fcb900;
      outline:none;
    }
    /* Телефоны/планшеты: отключаем рамку (и при желании подсветку) */
    @media (hover: none) and (pointer: coarse) {
      #atvAppsList .app-row:focus-visible,
      #atvAppsList .app-row.selected,
      #launcherList .app-row:focus-visible,
      #launcherList .app-row.selected {
        border-color: transparent;
        /* при необходимости уберите подсветку:
           box-shadow: none; */
      }
    }
    /* Глобально блокируем выделение/копирование длинным тапом (кроме ввода) */
    html, body, .modal, .modal * {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
    /* Разрешаем выделение там, где нужен ввод/редактирование текста */
    input, textarea, [contenteditable],
    input *, textarea *, [contenteditable] * {
      -webkit-user-select: text;
      user-select: text;
      -webkit-touch-callout: default;
    }
    /* Flex для кнопок ввода/ADB: центрируем каждую строку */
    #passwordRow {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin: 8px 0;
    }
    #passwordRow .password-row-icon-btn,
    #passwordRow #passwordBtn,
    #passwordRow .adb-status-icon {
      flex: 0 0 auto;
    }
    .app-icon { width:42px; height:42px; border-radius:10px; object-fit:contain; background:#101316; padding:6px; }
    .app-meta { display:flex; flex-direction:column; gap:4px; overflow:hidden; align-items:flex-start; width:100%; text-align:left; }
    .app-title { font-weight:700; font-size:15px; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; width:100%; text-align:left; }
    .app-sub { font-size:12px; color:rgba(255,255,255,0.85); overflow:hidden; text-overflow:ellipsis; display:flex; justify-content:space-between; align-items:flex-start; flex-wrap:nowrap; width:100%; gap:8px; text-align:left; }
    .app-badge { display:inline-flex; align-items:center; gap:4px; padding:2px 8px; border-radius:20px; font-size:11px; font-weight:700; text-transform:uppercase; margin-left:12px; white-space:nowrap; background:#d0a447; color:#0b1d25; }
    .badge-user { background:#2abf6d; color:#0b1d25; }
    .badge-system { background:#7e6735; color:#e2e3e4; }
    /* Кнопка обновления списка ATV с отдельными отступами по осям */
    .atv-refresh-btn {
      width: 48px;
      height: 48px;
      padding: 4px;
      transform: translate(var(--atv-refresh-offset-x, 0px), var(--atv-refresh-offset-y, 0px));
    }
    /* Подсказка по фокусу (для кнопок без hover) */
    .focus-tooltip {
      position: relative;
    }
    .focus-tooltip:focus-visible::after {
      content: attr(data-tip);
      position: absolute;
      left: 50%;
      top: -8px;
      transform: translate(-50%, -100%);
      white-space: nowrap;
      background: #1f3a5a52;
      color: #fff;
      padding: 4px 8px;
      border-radius: 8px;
      font-size: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      z-index: 10;
    }
    /* Кнопки в хедере модалки ATV — используем общие стили modal-header-tools/modal-quick-action */
    #atvAppsModal .modal-header-tools { right: -8px; top: -5px; gap: 1px; }
    #atvAppsModal #atvAppsHeader { margin-top: 6px; margin-bottom: 6px; }
    #atvAppsModal .modal-content { max-height: 90vh; }
    #atvAppsModal .atv-loading { display:flex; flex-direction:column; align-items:center; gap:8px; padding:20px; opacity:0.9; }
    #atvAppsModal .atv-loading .spin { display:inline-flex; align-items:center; justify-content:center; animation: spin 1s linear infinite; transform-origin:center; }
    #atvAppsModal .atv-loading img { height:40px; width:40px; display:block; }
    #atvAppsModal .atv-loading,
    #launcherModal .atv-loading { display:flex; flex-direction:column; align-items:center; gap:10px; padding:24px 20px; opacity:0.9; }
    #atvAppsModal .launcher-spinner,
    #launcherModal .launcher-spinner {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 3px solid rgba(255,255,255,0.22);
      border-top-color: #00cfff;
      animation: spin 0.95s linear infinite;
      box-sizing: border-box;
    }
    .app-state { font-size:12px; color:#ffc107; }
    #atvAppsModal.atv-loading-active { pointer-events: none; }
    #atvAppsModal.atv-loading-active .modal-content { opacity: 0.85; }
    #launcherModal .modal-header-tools { right: -8px; top: -5px; gap: 1px; }
    #launcherModal #launcherHeader { margin-top: 6px; margin-bottom: 6px; }
    #launcherModal .modal-content { max-height: 90vh; }
    #launcherModal.launcher-loading-active { pointer-events: none; }
    #launcherModal.launcher-loading-active .modal-content { opacity: 0.85; }

    /* Модалка действий по приложению ATV */
    #atvAppActionsModal .sys-btn {
      background: #10131A;
      border: 1px solid #1f3a5a;
      color: #e8f0ff;
    }
    #atvAppActionsModal .sys-btn:hover,
    #atvAppActionsModal .sys-btn:focus,
    #atvAppActionsModal .sys-btn.selected {
      background: #10131A;
      border-color: #3fa9f5;
      color: #fff;
    }
    #launcherActionsModal .sys-btn {
      background: #10131A;
      border: 1px solid #1f3a5a;
      color: #e8f0ff;
    }
    #launcherActionsModal .sys-btn:hover,
    #launcherActionsModal .sys-btn:focus,
    #launcherActionsModal .sys-btn.selected {
      background: #10131A;
      border-color: #3fa9f5;
      color: #fff;
    }
    #miscModal .sys-btn:focus {
      background-color: #00cfff; color:#000;
       border: 2px solid #fff;
    }
    /* Подсветка выбранной кнопки в модалке "Разное" */
    #miscModal .sys-btn.selected { background-color: #00cfff; color: #000; border: 2px solid #fff; }
    
    /* В модалке "Дополнительные функции" отключаем hover, чтобы не мешал подсветке по фокусу */
    #miscMoreModal .sys-btn { background-color: #004d61; color:#fff; }
    #miscMoreModal .sys-btn:hover { background-color: #004d61; }
    #miscMoreModal .sys-btn:focus {
      background-color: #00cfff; color:#000;
      border: 2px solid #fff;
    }
    /* Подсветка выбранной кнопки в модалке "Дополнительные функции" */
    #miscMoreModal .sys-btn.selected { background-color: #00cfff; color: #000; border: 2px solid #fff; }
    
    /* === СКАНЕР ADB === */
    #adbScanListContainer {
      max-height: 60vh;
      overflow-y: auto;
      overscroll-behavior: contain;
      scroll-behavior: auto;
      scrollbar-gutter: stable both-edges;
      touch-action: pan-y;
      -ms-touch-action: pan-y;
      -webkit-overflow-scrolling: touch;
    }
    #adbScanList {
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-width: 360px;
      width: 100%;
      margin: 0 auto;
      align-items: center;
    }
    
    /* Карточки устройств ADB */
    .adb-chip {
      width: min(86vw, 288px) !important;
      max-width: 288px;
      min-height: 48px;
      padding: 8px 12px;
      margin: 0 auto;
      border-radius: 12px;
      border: 2px solid transparent;
      background-color: #004d61;
      color: #fff;
      display: inline-flex;
      flex-direction: column;
      gap: 2px;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-shadow: 0 5px 10px rgba(0,0,0,0.35);
      cursor: pointer;
      transition: transform .15s ease, box-shadow .2s ease, background-color .2s ease, border-color .2s ease;
      line-height: 1.2;
      appearance: none;
      box-sizing: border-box;
    }
    .adb-chip:focus,
    .adb-chip:focus-visible {
      outline: none;
      transform: translateY(-2px);
      background-color: #00cfff;
      color: #000;
      border-color: #fff;
      box-shadow: 0 16px 24px rgba(0,0,0,0.4);
    }
    .adb-chip.has-selected-style {
      transform: translateY(-2px);
      background-color: #00cfff;
      color: #000;
      border-color: #fff;
      box-shadow: 0 16px 24px rgba(0,0,0,0.4);
    }
    
    .adb-device-card {
      border-radius: 16px;
    }
    
    .adb-device-name {
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 2px;
      color: inherit;
      text-align: center;
      width: 100%;
    }

    .adb-device-name--placeholder {
      opacity: .65;
      font-style: italic;
    }
    
    .adb-device-ip {
      font-size: 13px;
      font-weight: 500;
      margin: 0;
      opacity: .85;
      text-align: center;
      width: 100%;
      color: inherit;
    }
    
    /* Кнопки управления сканером */
    #adbScannerModal .sys-btn { background-color: #004d61; color: #fff; }
    #adbScannerModal .sys-btn:hover { background-color: #004d61; }
    #adbScannerModal .sys-btn:focus {
      background-color: #00cfff;
      color: #000;
      border: 2px solid #fff;
    }
    #adbScannerModal .sys-btn.selected { background-color: #00cfff; color: #000; border: 2px solid #fff; }

    .adb-last-connection {
      display: none;
      margin-bottom: 16px;
      text-align: center;
    }
    .adb-last-connection.active {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 8px;
    }
    .adb-last-connection-title {
      font-size: 13px;
      opacity: .8;
      margin-bottom: 6px;
    }
    .adb-last-connection-btn-line1 {
      display: block;
      font-weight: 600;
      font-size: 15px;
    }
    .adb-last-connection-btn-line2 {
      display: block;
      font-size: 13px;
      opacity: .85;
    }
    

    #splash { position: fixed; inset: 0; background-color: #000; display: flex; justify-content: center; align-items: center; z-index: 9999; }
     #logo { position: fixed; inset: 0; z-index: 9999; background-repeat: no-repeat; background-position: center; background-size: cover; }

    /* Тосты */
    .toast {
      display: inline-flex; align-items: center; gap: 8px; box-sizing: border-box; background: rgba(0,0,0,.85); color: #fff;
      border-radius: 10px; padding: 12px 18px; font-size: 14px; line-height: 1.3; max-width: min(70vw,720px);
      white-space: normal; overflow-wrap: anywhere; word-break: break-word; opacity: 0; transform: translateY(8px);
      transition: opacity .25s ease, transform .25s ease; pointer-events: auto;
    }
    .toast.show { opacity: 1; transform: translateY(0); }
    .toast--pill { border-radius: 999px; padding: 10px 16px; }
    .toast--compact { padding: 8px 12px; font-size: 16px; }
    .toast--card { box-shadow: 0 8px 24px rgba(0,0,0,.35); }
    .toast .spin { display:inline-block; animation: spin 1s linear infinite; }
    .toast-stack { position: fixed; z-index: 9999; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
    .toast-stack--top{ top: 40px; } .toast-stack--bottom{ bottom: 40px; } .toast-stack--center{ top: 50%; transform: translateY(-50%); }
    .toast-stack--left{ left: 40px; align-items: flex-start; } .toast-stack--centerX{ left: 50%; transform: translateX(-50%); align-items: center; }
    .toast-stack--right{ right: 40px; align-items: flex-end; }
    .toast--anchored { position: fixed; z-index: 10000; }

    /* === АВТОЗАПУСК === */
    #autostartListContainer { max-height: 60vh; overflow-y: auto; overscroll-behavior: contain; scroll-behavior: auto; scrollbar-gutter: stable both-edges; }
    #autostartList {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* адаптивно по ширине модалки */
      gap: 10px;
      justify-items: center;
    }
    #autostartList .card {
      transition: none !important;
      flex: none;
      width: 100%;
      min-width: 140px;
      max-width: 180px;
    }
    #autostartList .card:focus { box-shadow: 0 0 0 3px rgba(255,255,255,.6) !important; border-color: #fff !important; outline: none; }
    /* Отключаем hover в автозапуске, чтобы мышь не давала "ложную" подсветку */
    #autostartList .card:hover { background-color: #2a2a2a; border-color: transparent; box-shadow: none; }
    #autostartList .card.selected:hover { background-color: #00cfff; color:#000; border: 2px solid #fff; }

    /* Сделаем «Закрыть» видимой как "низ списка" */
    #autostartCloseBtn { margin: 12px auto 0; width: 100%; max-width: 320px; }


     /* Красим имя приложения*/
  .app-name {
    color: #00cfff;       /* оттенок бирюзового, как у кнопок */
    font-weight: 700;
  }

/* Стили для модалки настроек установки (как модалка "Разное") */
#installMethodModal {
  z-index: 1000 !important; /* Выше чем у модалки "Разное" (999) */
}

#installMethodModal .modal-content {
  display: flex;
  flex-direction: column;
  max-height: 96vh;
  overflow: hidden;
}

#installMethodModal .install-method-settings {
  max-width: 560px;         /* список уже, не на всю ширину экрана */
  margin: 0 auto;
  max-height: 72vh;
  overflow-y: auto;
  overscroll-behavior: contain;
  -webkit-overflow-scrolling: touch;
  padding-right: 6px;
}

#miscMoreModal .modal-content {
  display: flex;
  flex-direction: column;
  max-height: 80vh;
}

#miscMoreModal .misc-buttons-container {
  max-height: 60vh;
  overflow-y: auto;
  overscroll-behavior: contain;
  scroll-behavior: auto;
  scrollbar-gutter: stable both-edges;
  margin-bottom: 20px;
}

#installMethodModal .method-option {
  margin: 12px 0;
  padding: 14px 18px;
  border: 2px solid #333;
  border-radius: 14px;
  cursor: pointer;
  transition: all 0.25s ease;
  display: grid;
  grid-template-columns: auto 1fr;
  column-gap: 14px;
  align-items: center;
  background: #141414;
  position: relative;
}
#installMethodModal .method-option strong {
  font-size: 1rem;
}
#installMethodModal .method-option small {
  display: block;
  margin-top: 4px;
  line-height: 1.3;
}
/* Уплотняем и центрируем радио-опции */

/* Адаптация модалки метода установки для портретного режима */
@media (orientation: portrait) {
  #installMethodModal .modal-content {
    max-height: 96vh;
    width: 92%;
    padding: 18px 16px;
  }
  
  #installMethodModal .install-method-settings {
    max-width: 100%;
    margin: 0;
    max-height: 78vh;
    padding-right: 4px;
  }
}

@media (max-width: 1100px) {
  #installMethodModal .modal-content {
    width: 92%;
    padding: 22px 18px 20px;
    border-radius: 22px;
  }

  #installMethodModal .install-method-settings {
    max-width: 100%;
    margin: 0;
    max-height: 74vh;
    padding-right: 4px;
  }

  #installMethodModal h3 {
    text-align: center;
    font-size: 1.18rem;
    margin-bottom: 16px;
  }

  #installMethodModal .method-option {
    grid-template-columns: 1fr;
    row-gap: 10px;
    text-align: center;
    justify-items: center;
    padding: 16px 14px;
  }

  #installMethodModal .method-option input[type="radio"] {
    transform: scale(1.4);
  }

  #installMethodModal .method-option label {
    text-align: center;
  }

  #installMethodModal .method-option strong {
    font-size: 1.1rem;
  }

  #installMethodModal .method-option small {
    font-size: .92rem;
    line-height: 1.4;
  }

  #installMethodModal .sys-btn {
    max-width: 100%;
  }
}


#installMethodModal .method-option:focus {
  border-color: #00cfff;
  background-color: rgba(0, 207, 255, 0.1);
  outline: none;
}

#installMethodModal .method-option input[type="radio"] {
  margin: 0;
  transform: scale(1.2);
  flex-shrink: 0;
  pointer-events: none; /* не даём фокусу/клику уходить в кружок */
  opacity: 1;
}

#installMethodModal .method-option label {
  margin-left: -5px;
  cursor: pointer;
  display: block;
  margin: 0;
  flex: 1;
}

#installMethodModal .method-option label small {
  color: #d0d0d0;
  transition: color 0.2s ease;
}

#installMethodModal .method-option.selected label small {
  color: #4caf50;
}

/* Модалка ADB-команд */
#adbCommandsModal .modal-content {
  max-width: 640px;
  width: 90%;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

#adbCommandsListContainer {
  max-height: 70vh;
  overflow-y: auto;
  overscroll-behavior: contain;
  scroll-behavior: auto;
  scrollbar-gutter: stable both-edges;
}

#adbCommandsList {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 12px;
  justify-items: center;
}

.adb-command-btn {
  width: 100%;
  max-width: 280px;
  min-height: 64px;
  background: #10131A;
  color: #e8f0ff;
  border: 1px solid #1f3a5a;
  border-radius: 12px;
  padding: 12px;
  display: flex;
  align-items: center;
  gap: 12px;
  text-align: left;
  cursor: pointer;
  transition: background-color .2s ease, border-color .2s ease, box-shadow .2s ease;
}

.adb-command-btn:hover,
.adb-command-btn:focus,
.adb-command-btn.selected {
  background: #10131A;
  border-color: #3fa9f5;
  color: #fff;
  box-shadow: none;
  outline: none;
}

.adb-command-btn__icon {
  width: 36px;
  height: 36px;
  border-radius: 8px;
  background: rgba(0,0,0,0.2);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  flex-shrink: 0;
}

.adb-command-btn__icon img {
  max-width: 28px;
  max-height: 28px;
  object-fit: contain;
}

.adb-command-btn__text {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.adb-command-btn__label {
  font-weight: 400;
  font-size: 13px;
}

.adb-command-btn__command {
  font-size: 11px;
  opacity: .8;
  word-break: break-all;
}

#adbCommandsEmpty {
  text-align: center;
  opacity: .75;
  padding: 20px 0;
}

#adbCommandsCloseBtn {
  margin: 16px auto 0;
  width: min(280px, 90%);
  background: #10131A;
  border: 1px solid #1f3a5a;
  color: #e8f0ff;
}
#adbCommandsCloseBtn:hover,
#adbCommandsCloseBtn:focus {
  background: #10131A;
  border-color: #3fa9f5;
  color: #fff;
  box-shadow: none;
}

#screenSaverModal .modal-content {
  display: flex;
  flex-direction: column;
  gap: 16px;
  width: min(640px, 92vw);
  max-height: 85vh;
  overflow: hidden;
}

#screenSaverModal .screen-saver-body {
  display: flex;
  flex-direction: column;
  gap: 16px;
  max-height: 70vh;
  overflow-y: auto;
  overscroll-behavior: contain;
  scrollbar-gutter: stable both-edges;
}

#screenSaverModal .screen-saver-body {
  display: flex;
  flex-direction: column;
  gap: 16px;
  max-height: 70vh;
  overflow-y: auto;
  overscroll-behavior: contain;
  scrollbar-gutter: stable both-edges;
}

.screen-saver-section {
  background: rgba(255,255,255,0.04);
  border-radius: 14px;
  padding: 14px;
  border: 1px solid rgba(255,255,255,0.08);
}

.screen-saver-section h4 {
  margin: 0 0 8px;
  font-size: 15px;
  color: #00cfff;
}

.screen-saver-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

.screen-saver-row label {
  font-size: 14px;
  opacity: .85;
}

.screen-saver-value {
  font-weight: 600;
  font-size: 15px;
}

.screen-saver-actions {
  display: flex;
  flex-direction: column;
  gap: 12px;
  justify-content: center;
  align-items: center;
}

.screen-saver-actions .sys-btn {
  width: min(340px, 100%);
}

.screen-saver-action-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
  text-align: left;
}

.screen-saver-action-btn img {
  display: block;
  height: 20px;
  width: auto;
}

.screen-saver-cta {
  display: flex;
  gap: 10px;
  justify-content: center;
  flex-wrap: wrap;
}

#screenSaverTimeoutModal .modal-content {
  max-width: 400px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.screen-saver-timeout-body {
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.screen-saver-timeout-field {
  display: flex;
  flex-direction: column;
  gap: 6px;
  text-align: left;
}

.screen-saver-timeout-field label {
  font-size: 13px;
  opacity: .85;
}

#screenSaverTimeoutInput {
  width: 100%;
  box-sizing: border-box;
  padding: 10px 12px;
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  color: #fff;
  font-size: 18px;
  text-align: center;
}

.screen-saver-step-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.screen-saver-step {
  flex: 1 1 calc(33% - 8px);
  min-width: 90px;
  width: auto;
  padding: 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.2);
  background: rgba(0,77,97,0.5);
  color: #fff;
  text-align: center;
  font-weight: 600;
  transition: background .2s ease, border-color .2s ease;
}

.screen-saver-step:focus,
.screen-saver-step:hover {
  background-color: #00cfff;
  color: #000;
  border-color: #fff;
  outline: none;
}

.screen-saver-timeout-hint {
  font-size: 12px;
  opacity: 0.7;
  text-align: left;
}

    
    /* Отключение системного масштабирования шрифтов */
    html {
      -webkit-text-size-adjust: 100% !important;
      -moz-text-size-adjust: 100% !important;
      -ms-text-size-adjust: 100% !important;
      text-size-adjust: 100% !important;
      font-size: 16px !important; /* базовый размер */
    }

    body {
      font-size: 1rem !important; /* относительно html */
      -webkit-text-size-adjust: none !important;
      -moz-text-size-adjust: none !important;
      -ms-text-size-adjust: none !important;
      text-size-adjust: none !important;
    }

    /* Фиксированные размеры для всех элементов */
    *, *::before, *::after {
      -webkit-text-size-adjust: none !important;
      -moz-text-size-adjust: none !important;
      -ms-text-size-adjust: none !important;
      text-size-adjust: none !important;
    }

    /* Специально для элементов интерфейса - принудительное фиксирование размеров */
    select, input, button {
      font-size: 18px !important; /* фиксированный размер */
      -webkit-text-size-adjust: none !important;
      text-size-adjust: none !important;
    }

    .card {
      font-size: 13px !important;
      -webkit-text-size-adjust: none !important;
      text-size-adjust: none !important;
    }

    .sys-btn {
      font-size: 13px !important;
      -webkit-text-size-adjust: none !important;
      text-size-adjust: none !important;
    }

    button {
      font-size: 14px !important;
      -webkit-text-size-adjust: none !important;
      text-size-adjust: none !important;
    }

    button,
    .sys-btn,
    .component-btn {
      -webkit-tap-highlight-color: transparent;
    }
    
  </style>
</head>

<body style="margin:0; padding:0;" class="splash-open">
  <div id="splash"><div id="logo"></div></div>
  <div id="main-content" style="display:none;"></div>

   <script>
  (function(){
    const logo = document.getElementById('logo');
    if (!logo) return;
    const LAND = "url('https://appassets.androidplatform.net/assets/webview/logo/usr.gif')";
    const PORT = "url('https://appassets.androidplatform.net/assets/webview/logo/usrPort.gif')";
    const mql = window.matchMedia('(orientation: portrait)');
    function apply() { logo.style.backgroundImage = mql.matches ? PORT : LAND; }
    apply();
    if (mql.addEventListener) mql.addEventListener('change', apply);
    else if (mql.addListener) mql.addListener(apply);
    window.addEventListener('orientationchange', apply);
  })();
  </script>

  <h5 style="margin:0 0 2px; display:inline-flex; align-items:center; gap:4px;">
  <img src="https://appassets.androidplatform.net/assets/webview/icons/title/ic_launcher_round.png" alt="" style="height:18px; width:18px; object-fit:contain;">
  FastInstaller
</h5>
  <div id="adbStatusIndicator" class="adb-status-indicator">Проверка подключения ADB…</div>

  <div id="progress-container" style="display:none; width:100%; background:#000; padding:5px; z-index:1002; position:fixed; bottom:0; left:0; right:0;">
    <div id="progress-text" style="color:#fff; margin-bottom:5px;">Загрузка...</div>
    <div style="width:100%; background:#000; height:8px; border-radius:6px;">
      <div id="progress-bar" style="height:8px; width:0%; background:#42A5F5; border-radius:6px;"></div>
    </div>
  </div>

  <div class="card-container" id="groupCards"></div>

  <script>
    // Enter/OK на главном экране
    document.addEventListener('keydown', function (e) {
      const isOk = e.key === 'Enter' || e.key === 'NumpadEnter' || e.key === 'OK' || e.code === 'Enter';
      if (!isOk) return;
      if (anyModalOpen()) return;

      const selected = document.querySelector('.card.selected');
      if (!selected) return;
      currentGroup = selected.dataset.group;
      startInstall();
    });
  </script>

  <select id="groupSelect" style="display:none;"></select>
  <div id="passwordRow" style="display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:8px;margin:8px 0;">
    
    <button class="password-row-icon-btn focus-tooltip" onclick="ignoreNextEnter=true;openAdbScanner()" title="К другому (RSA)" aria-label="К другому (RSA)" data-tip="К другому (RSA)">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/network/ic_ADB_scan.png" alt="" loading="lazy">
    </button>


    <button type="button" id="passwordBtn" class="password-row-icon-btn focus-tooltip"
            title="Введите пароль" aria-label="Введите пароль" data-tip="Введите пароль">
      <img id="passwordBtnIcon" src="https://appassets.androidplatform.net/assets/webview/icons/screenserver/ic_AerialDream.webp" alt="" loading="lazy">
    </button>

    <button class="modal-adb-indicator adb-status-icon focus-tooltip" onclick="reconnectLastAdbFromChip(event)" title="Подключиться к последнему ADB" aria-label="Подключиться к последнему ADB" data-tip="Подключиться к последнему ADB">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic10_updWebView.png" alt="" loading="lazy">
    </button>

    <button class="password-row-icon-btn focus-tooltip" onclick="event.stopPropagation();window.AndroidInterface.openUnknownSources()"
            title="Неизвестные источники" aria-label="Неизвестные источники" data-tip="Неизвестные источники">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic1_unknow.png" alt="" loading="lazy">
    </button>
    <button class="password-row-icon-btn focus-tooltip" onclick="ignoreNextEnter=true;window.AndroidInterface.openAppSettingsList()"
            title="Все приложения" aria-label="Все приложения" data-tip="Все приложения">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic2_appsSettings.png" alt="" loading="lazy">
    </button>
    <button class="password-row-icon-btn focus-tooltip" onclick="ignoreNextEnter=true;window.AndroidInterface.openAccessibilitySettings()"
            title="Спец возможности" aria-label="Спец возможности" data-tip="Спец возможности">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic3_accessibility.png" alt="" loading="lazy">
    </button>
    <button class="password-row-icon-btn focus-tooltip" onclick="ignoreNextEnter=true;window.AndroidInterface.openBatteryOptimization()"
            title="Общие настройки" aria-label="Общие настройки" data-tip="Общие настройки">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic4_allSettings.png" alt="" loading="lazy">
    </button>
    <button class="password-row-icon-btn focus-tooltip" onclick="ignoreNextEnter=true;window.AndroidInterface.openAllAppsSide()"
            title="Меню приложений" aria-label="Меню приложений" data-tip="Меню приложений">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic7_appsdriver.png" alt="" loading="lazy">
    </button>
  </div>
  <div id="status"></div>

  <div class="system-buttons" id="mainSystemButtons">
    <!--
    <button onclick="event.stopPropagation();window.AndroidInterface.openUnknownSources()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic1_unknow.png" alt="" style="height:30px;"><br>Неизвестные источники
    </button>
    <button onclick="ignoreNextEnter=true;window.AndroidInterface.openAppSettingsList()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic2_appsSettings.png" alt="" style="height:28px;"><br>Все приложения
    </button>
    -->
    <button onclick="ignoreNextEnter=true;requestLocalAdbConnection()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png" alt="" style="height:26px;"><br>ADB локально
    </button>

    <button onclick="ignoreNextEnter=true;window.AndroidInterface.openWirelessDebuggingSettings()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic3_developer.png" alt="" style="height:26px;"><br>Для разработчиков
    </button>

    <button onclick="openAdbCommandsFromButton(this)" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic13_ADB_cmd.png" alt="" style="height:24px;"><br>ADB команды
    </button>

    <button onclick="openAdbRemoteModal(this)" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png" alt="" style="height:24px;"><br>Пульт ДУ
    </button>

    <button onclick="openAtvAppsModalFast(this)" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic2_appsSettings.png" alt="" style="height:28px;"><br>Пакеты
    </button>

    <button onclick="openLaunchersModal(this)" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png" alt="" style="height:26px;"><br>Лаунчеры
    </button>

    <button onclick="openScreenSaverModal(this)" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic12_ScreenServer.png" alt="" style="height:26px;"><br>Заставка
    </button>

    <button onclick="disablePackages(['com.amazon.amazonvideo.livingroom','com.android.cts.priv.ctsshim','com.android.printspooler','com.android.providers.calendar','com.android.providers.contacts','com.apple.atve.androidtv.appletv','com.google.android.feedback','com.xiaomi.mitv.mediaexplorer','com.google.android.play.games','com.google.android.syncadapters.calendar','com.iqiyi.i18n.tv','com.mitv.tvhome.michannel','com.mitv.tvhome.mitvplus','com.mitv.videoplayer','com.miui.tv.analytics','com.netflix.ninja','com.google.android.videos','com.sonyliv','in.startv.hotstar','com.android.dreams.basic','com.google.android.apps.tv.dreamx','com.mitv.tvhome.atv','com.mitv.dream','com.google.android.youtube.tvmusic'])" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic22_disableside.png" alt="" style="height:26px;"><br>Откл\вкл системные
    </button>

    <button onclick="handleOpenApkFilePicker()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic11_usb.png" alt="" style="height:26px;"><br>Установить APK+
    </button>

    <button onclick="showInstallMethodSettings(this)" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic1_tools.png" alt="" style="height:26px;"><br>Выбор способа установки
      </button>

      <button onclick="ignoreNextEnter=true;window.AndroidInterface.confirmDeleteCopiedBackups()" class="sys-btn">
        <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic8_cleartrash.png" alt="" style="height:26px;"><br>Удаление бэкапов
      </button>

    <!--
    <button onclick="ignoreNextEnter=true;window.AndroidInterface.openAccessibilitySettings()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic3_accessibility.png" alt="" style="height:28px;"><br>Спец возможности
    </button>
    <button onclick="ignoreNextEnter=true;window.AndroidInterface.openBatteryOptimization()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic4_allSettings.png" alt="" style="height:28px;"><br>Общие настройки
    </button>
    -->
    <button onclick="ignoreNextEnter=true;window.AndroidInterface.openFileManagerPlus()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic5_FileManagerPlus.png" alt="" style="height:25px;"><br>File Manager
    </button>
    <button onclick="openMiscModal(this)" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic_launcher_round.png" alt="" style="height:30px;"><br>FastInstaller+
    </button>
    <!--
    <button onclick="ignoreNextEnter=true;window.AndroidInterface.openAllAppsSide()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic7_appsdriver.png" alt="" style="height:28px;"><br>Меню приложений
          </button>
    -->
    <button onclick="ignoreNextEnter=true;window.AndroidInterface.openAnydesk()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic8_anydesk.png" alt="" style="height:28px;"><br>AnyDesk
    </button>
    <button onclick="AndroidInterface.updateWebView()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic10_updWebView.png" alt="" style="height:28px;"><br>Обновить AndroidWebView
    </button>
    <button onclick="ignoreNextEnter=true;showDeviceStats()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png" alt="" style="height:28px;"><br>CPU / RAM / Storage
    </button>
  </div>

  <!-- Модалка автозапуска -->
  <div id="autostartModal" class="modal" style="display:none;">
    <div class="modal-content">
      <div id="autostartCurrent" style="margin-bottom:10px; font-weight:bold;">Выбрано: Нет</div>
      <h3>Выберите приложение для автозапуска:</h3>
      <button onclick="disableAutostart()" class="sys-btn">🚫 Отключить автозапуск</button>
      <button onclick="ignoreNextEnter=true;window.AndroidInterface.testAutostart()" class="sys-btn">🚀 Проверка автозапуска</button>

      <!-- КОНТЕЙНЕР СО СКРОЛЛОМ (и здесь же кнопка Закрыть) -->
      <div id="autostartListContainer">
        <div id="autostartList"></div>
        <button id="autostartCloseBtn" onclick="closeAutostartModal()">❌ Закрыть</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <!-- Модалка списка приложений Android TV -->
  <div id="atvAppsModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <div class="modal-header-tools" style="justify-content:flex-end;">
        <button
          type="button"
          class="modal-quick-action atv-refresh-btn"
          data-action="modal-action-atv-refresh"
          onclick="refreshAtvAppsList('remote')"
          title="Обновить список"
          aria-label="Обновить список"
          style="--atv-refresh-offset-x: -10px; --atv-refresh-offset-y: 7px;"
        >
          <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic10_updWebView.png" alt="Refresh" loading="lazy">
        </button>
      </div>
      <h3 id="atvAppsHeader" style="display:flex;align-items:center;justify-content:center;gap:8px;margin-bottom:4px;margin-top:0;font-size:1.1rem;">
        <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic20_ATV.png" alt="" style="height:22px;">
        Приложения Android TV
      </h3>
      <div class="app-filters" id="atvAppsFilters" style="margin-bottom:6px;display:flex;gap:4px;justify-content:center;flex-wrap:wrap;">
        <button class="sys-btn" style="min-width:70px; padding:6px 8px; font-size:11px;" data-filter="all" onclick="setAtvAppsFilter('all')">Все</button>
        <button class="sys-btn" style="min-width:70px; padding:6px 8px; font-size:11px;" data-filter="user" onclick="setAtvAppsFilter('user')">Сторонние</button>
        <button class="sys-btn" style="min-width:70px; padding:6px 8px; font-size:11px;" data-filter="system" onclick="setAtvAppsFilter('system')">Системные</button>
        <button class="sys-btn" style="min-width:70px; padding:6px 8px; font-size:11px;" data-filter="disabled" onclick="setAtvAppsFilter('disabled')">Отключенные</button>
        <button class="sys-btn" style="min-width:70px; padding:6px 8px; font-size:11px;" data-filter="deleted" onclick="setAtvAppsFilter('deleted')">Удаленные</button>
        <button class="sys-btn" style="min-width:70px; padding:6px 8px; font-size:11px;" data-filter="system_launchable" onclick="setAtvAppsFilter('system_launchable')">Сист откр</button>
      </div>

      <div id="atvAppsContainer" style="max-height:calc(90vh - 160px);overflow-y:auto;overscroll-behavior:contain;scrollbar-gutter:stable both-edges;margin-bottom:4px;padding-right:4px;padding-bottom:24px;-webkit-overflow-scrolling:touch;">
        <div id="atvAppsList" class="apps-list"></div>
      </div>
    </div>
  </div>

  <!-- Модалка действий по приложению -->
  <div id="atvAppActionsModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <h3 id="atvAppActionsTitle" style="display:flex;align-items:center;gap:8px;">Действия</h3>
      <div id="atvAppActionsInfo" style="font-size:13px; opacity:0.8; margin-bottom:10px;"></div>
      <div class="system-buttons" id="atvAppActionsButtons" style="justify-content:center; gap:8px; flex-wrap:wrap;"></div>
    </div>
  </div>

  <!-- Модалка списка лаунчеров -->
  <div id="launcherModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <div class="modal-header-tools" style="justify-content:flex-end;">
        <button
          type="button"
          class="modal-quick-action atv-refresh-btn"
          onclick="refreshLaunchersList()"
          title="Обновить лаунчеры"
          aria-label="Обновить лаунчеры"
          style="--atv-refresh-offset-x: -10px; --atv-refresh-offset-y: 7px;"
        >
          <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic10_updWebView.png" alt="Refresh" loading="lazy">
        </button>
      </div>
      <h3 id="launcherHeader" style="display:flex;align-items:center;justify-content:center;gap:8px;margin-bottom:4px;margin-top:0;font-size:1.1rem;">
        <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png" alt="" style="height:22px;">
        Лаунчеры
      </h3>
      <div id="launcherContainer" style="max-height:calc(90vh - 135px);overflow-y:auto;overscroll-behavior:contain;scrollbar-gutter:stable both-edges;margin-bottom:4px;padding-right:4px;padding-bottom:24px;-webkit-overflow-scrolling:touch;">
        <div id="launcherList" class="apps-list"></div>
      </div>
      <div id="launcherSystemPickerWrap" class="system-buttons" style="margin-top:8px; justify-content:center;">
        <button class="sys-btn" style="max-width:280px;" onclick="sendAdbCommand('am start -a android.settings.HOME_SETTINGS','Выбор лаунчера',{ singleToast: true })">
          Системный<br>выбор
        </button>
      </div>
    </div>
  </div>

  <!-- Модалка действий по лаунчеру -->
  <div id="launcherActionsModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <h3 id="launcherActionsTitle" style="display:flex;align-items:center;gap:8px;">Лаунчер</h3>
      <div id="launcherActionsInfo" style="font-size:13px; opacity:0.85; margin-bottom:10px;"></div>
      <div class="system-buttons" id="launcherActionsButtons" style="justify-content:center; gap:8px; flex-wrap:wrap;"></div>
    </div>
  </div>

  <!-- Модалка «Разное» -->
  <div id="miscModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <h3 id="miscHeader" style="display:flex;align-items:center;justify-content:center;gap:8px;">Разное</h3>
      <div class="misc-buttons-container">
        <div class="system-buttons">
          <!-- <button onclick="ignoreNextEnter=true;window.AndroidInterface.openFilePicker()" class="sys-btn">
            <img src="https://raw.githubusercontent.com/F4IPTV/Play/main/Pictures/Без названия (15).svg" alt="" style="height:26px;"><br>Файловый менеджер
          </button> -->
	  <!-- Кнопка настроек метода установки -->
    
   
    <button onclick="ignoreNextEnter=true;openAdbScanner()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png" alt="" style="height:26px;"><br>К другому (RSA)
    </button>
    
    <button onclick="dumpLocalApps()" class="sys-btn">
      <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic10_updWebView.png" alt="" style="height:28px;"><br>Дамп иконок
    </button>
          
           <button onclick="ignoreNextEnter=true;handleConfirmWipeThirdPartyApps()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic8_cleartrash.png" alt="" style="height:26px;"><br>Удаление всех приложений
          </button>

          <button onclick="ignoreNextEnter=true;runAllAutoPermissions()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png" alt="" style="height:28px;"><br>Авторазрешения
          </button>
          
          <button onclick="ignoreNextEnter=true;window.AndroidInterface.openApkFilePickerDownload()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic11_usb.png" alt="" style="height:26px;"><br>Загрузить на устройство
          </button>
          <button onclick="ignoreNextEnter=true;window.AndroidInterface.openDownloadToDevice()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic11_usb.png" alt="" style="height:26px;"><br>Скачать на устройство
          </button>

          <button onclick="openAutostartModal(this)" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic2_autostart.png" alt="" style="height:26px;"><br>Автозагрузка приложения
          </button>
          <button onclick="ignoreNextEnter=true;installFastInstaller()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png" alt="" style="height:28px;"><br>Установить FastInstaller
          </button>
			
          
			<button onclick="openMiscMoreModal(this)" class="sys-btn">
    <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic1_disable.png" alt="" style="height:26px;"><br>Доп. функции
  </button>

		  
          
        </div>
      </div>
    </div>
  </div>

  <!-- Дополнительная модалка внутри «Разное» -->
  <div id="miscMoreModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <h3 id="miscMoreHeader" style="display:flex;align-items:center;justify-content:center;gap:8px;">Дополнительные функции</h3>
      <div class="misc-buttons-container">
        <div class="system-buttons">

			    <button onclick="ignoreNextEnter=true; window.AndroidInterface.openActivityStubOneButton()" class="sys-btn">
          <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic9_AndroidWebView.png" alt="" style="height:24px;"><br>Activity Stub
          </button>
          <button onclick="ignoreNextEnter=true;window.AndroidInterface.openSettingsForPackage('com.android.documentsui')" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic10_Files.webp" alt="" style="height:22px;"><br> Файлы
          </button>
          <button onclick="ignoreNextEnter=true;window.AndroidInterface.openFilesPermissionSettings()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic_launcher_round.png" alt="" style="height:28px;"><br>Доступ к памяти
          </button>
			
			    <button onclick="ignoreNextEnter=true;window.AndroidInterface.openFilesPermissionSettingsForPackage('com.anydesk.anydeskandroid')" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic8_anydesk.png" alt="" style="height:26px;"><br>Доступ к памяти
          </button>
          <button onclick="ignoreNextEnter=true;window.AndroidInterface.openPlayMarket()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic9_googleplay.png" alt="" style="height:24px;"><br>Google Play
          </button>
          <button onclick="ignoreNextEnter=true;window.AndroidInterface.openSettingsForPackage('com.google.android.katniss')" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic5_googlekatniss.png" alt="" style="height:24px;"><br>Google Katniss
          </button>
          
          <button onclick="ignoreNextEnter=true;window.AndroidInterface.clearWebCache()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic7_clearcash.png" alt="" style="height:26px;"><br>Очистить кеш
          </button>
          <button onclick="ignoreNextEnter=true;handleAdbTcpToggle(true,this)" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic15_connect.webp" alt="" style="height:22px;"><br>ADB TCP 5555 (root)
          </button>
          <button onclick="ignoreNextEnter=true;window.AndroidInterface.openAddAccountSettings()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic6_account.png" alt="" style="height:28px;"><br>Вход в аккаунт
          </button>
          
          
          
        
			    <button onclick="ignoreNextEnter=true;window.AndroidInterface.openNetworkSettings()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/network/ic_wifi.png" alt="" style="height:28px;"><br>Настройки Wi-Fi
          </button>
          <button onclick="showSettingsCash()" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic1_tools.png" alt="" style="height:26px;"><br>Выбор кеша
            </button>
          
          <button onclick="ignoreNextEnter=true; openInternal('https://tvboxsetup.ru/sv/');" class="sys-btn">
            <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic11_about.png" alt="" style="height:28px;"><br>О программе
          </button>
        </div>
        <div id="adbRootDiagOutput" style="margin-top:12px;padding:10px 12px;border-radius:12px;background:#11131a;color:#d5e3ff;font-family:monospace;font-size:12px;white-space:pre-wrap;max-height:160px;overflow:auto;display:none;line-height:1.5;">
          Лог ADB (root) появится здесь
        </div>
      </div>
    </div>
  </div>

  <!-- Модалка сканера ADB -->
  <div id="adbScannerModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <div id="lastAdbConnectionWrapper" class="adb-last-connection">
        <div class="adb-last-connection-title">Последнее подключение</div>
        <button id="lastAdbConnectionBtn" class="adb-chip adb-last-connection-btn" onclick="connectToLastAdb()" tabindex="0"></button>
      </div>
      <h3 id="adbScannerHeader" style="display:flex;align-items:center;justify-content:center;gap:8px;">
        <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png" alt="" style="height:25px;">
        Сканирование устройств ADB
      </h3>
      <div id="adbScanStatus" style="font-size:13px;opacity:.85;margin-bottom:12px;text-align:center;">Ожидание...</div>
      
      <!-- Контейнер со скроллом для списка устройств -->
      <div id="adbScanListContainer" style="max-height:60vh;overflow-y:auto;overscroll-behavior:contain;scroll-behavior:auto;scrollbar-gutter:stable both-edges;margin-bottom:20px;">
        <div id="adbScanList" style="display:flex;flex-direction:column;gap:12px;align-items:center;"></div>
      </div>
      
      <!-- Кнопки управления -->
      <div class="system-buttons" style="justify-content:center;">
        <button class="sys-btn" onclick="restartAdbScan()" tabindex="0">
          <img src="https://appassets.androidplatform.net/assets/webview/icons/main/ic10_updWebView.png" alt="" style="height:22px;"><br>Пересканировать
        </button>
        <button class="sys-btn" onclick="ignoreNextEnter=true;openAdbManualConnectModal()" tabindex="0">
          <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic14_ADB_Input.png" alt="" style="height:22px;"><br>Ввести IP:порт
        </button>
      </div>
    </div>
  </div>

  <!-- Модалка ручного подключения -->
  <div id="adbManualConnectModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content" style="max-width:420px;">
      <h3 id="adbManualHeader" style="display:flex;align-items:center;justify-content:center;gap:8px;">
        <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png" alt="" style="height:26px;">
        Ручное подключение ADB
      </h3>
      <div style="display:flex;flex-direction:column;gap:12px;margin-bottom:16px;align-items:center;">
        <div style="display:flex;flex-direction:column;gap:4px;width:100%;max-width:280px;">
          <label for="adbManualHostInput" style="font-size:13px;opacity:.85;">IP адрес устройства</label>
          <input id="adbManualHostInput" type="text" placeholder="192.168.0.15" autocomplete="off" spellcheck="false"
                 style="padding:10px 12px;border-radius:10px;border:none;background:#1c1c1f;color:#fff;font-size:15px;">
        </div>
        <div style="display:flex;flex-direction:column;gap:4px;width:100%;max-width:280px;">
          <label for="adbManualPortInput" style="font-size:13px;opacity:.85;">Порт ADB (из &laquo;IP address &amp; port&raquo;)</label>
          <input id="adbManualPortInput" type="text" placeholder="5555" autocomplete="off" spellcheck="false"
                 style="padding:10px 12px;border-radius:10px;border:none;background:#1c1c1f;color:#fff;font-size:15px;">
        </div>
        <div style="font-size:13px;line-height:1.4;opacity:.85;">
          Введите IP и порт из раздела <strong>Wireless debugging → IP address &amp; port</strong>. Устройство должно быть уже paired или иметь доверенный ключ ADB.
        </div>
      </div>
      <div class="system-buttons" style="justify-content:center;">
        <button id="adbManualSubmitBtn" class="sys-btn" onclick="submitAdbManualConnect()" type="button">
          <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic15_connect.webp" alt="" style="height:22px;"><br>Подключиться
        </button>
        <button id="adbManualCloseBtn" class="sys-btn" onclick="closeAdbManualConnectModal()" type="button">
          <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic16_back.webp" alt="" style="height:22px;"><br>Закрыть
        </button>
      </div>
    </div>
  </div>

  <!-- Модалка отправки ADB команд -->
  <div id="adbCommandsModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <h3 id="adbCommandsHeader" style="display:flex;align-items:center;justify-content:center;gap:8px;">
        <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png" alt="" style="height:26px;">
        ADB команды
      </h3>
      <div id="adbCommandsListContainer">
        <div id="adbCommandsList"></div>
        <button id="adbCommandsCloseBtn" class="component-btn" onclick="closeAdbCommandsModal()">Закрыть</button>
      </div>
    </div>
  </div>

  <!-- Модалка пульта ADB -->
  <div id="adbRemoteModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <h3 id="adbRemoteHeader" style="display:flex;align-items:center;justify-content:center;gap:8px;">
        <img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png" alt="" style="height:26px;">
        Пульт ДУ (ADB)
      </h3>
      <div class="adb-remote-top">
        <div class="adb-remote-left-buttons">
          <button class="adb-remote-round-btn"
                  aria-label="Питание"
                  onpointerdown="startPwrHold(event)"
                  onpointerup="stopPwrHold(event)"
                  onpointerleave="stopPwrHold(event)"
                  onpointercancel="stopPwrHold(event)">
            <span class="adb-remote-icon power" aria-hidden="true">
              <svg viewBox="0 0 24 24">
                <circle cx="12" cy="13" r="7"></circle>
                <line x1="12" y1="3" x2="12" y2="9"></line>
              </svg>
            </span>
          </button>
          <button class="adb-remote-round-btn" onclick="sendAdbRemoteKey(164)" aria-label="Без звука">
            <span class="adb-remote-icon" aria-hidden="true">
              <svg viewBox="0 0 24 24">
                <path d="M4 9h4l5-4v14l-5-4H4z"></path>
                <line x1="16" y1="8" x2="21" y2="13"></line>
                <line x1="21" y1="8" x2="16" y2="13"></line>
              </svg>
            </span>
          </button>
          <button class="adb-remote-round-btn" onclick="toggleAdbRemoteKeyboardPanel()" aria-label="Клавиатура">
            <span class="adb-remote-icon" aria-hidden="true">
              <svg viewBox="0 0 24 24">
                <rect x="2" y="6" width="20" height="12" rx="1"></rect>
                <line x1="6" y1="10" x2="6" y2="10"></line>
                <line x1="10" y1="10" x2="10" y2="10"></line>
                <line x1="14" y1="10" x2="14" y2="10"></line>
                <line x1="18" y1="10" x2="18" y2="10"></line>
                <line x1="6" y1="14" x2="6" y2="14"></line>
                <line x1="10" y1="14" x2="10" y2="14"></line>
                <line x1="14" y1="14" x2="14" y2="14"></line>
                <line x1="18" y1="14" x2="18" y2="14"></line>
              </svg>
            </span>
          </button>
        </div>
        <div class="adb-remote-volume" aria-label="Громкость">
          <div class="adb-remote-volume-rocker" aria-label="Громкость">
            <button class="adb-remote-rocker-btn plus"
                    aria-label="Громкость +"
                    onpointerdown="startAdbRemoteRepeat(event)"
                    onpointerup="stopAdbRemoteRepeat(event)"
                    onpointerleave="stopAdbRemoteRepeat(event)"
                    onpointercancel="stopAdbRemoteRepeat(event)"
                    data-key="24"></button>
            <button class="adb-remote-rocker-btn minus"
                    aria-label="Громкость -"
                    onpointerdown="startAdbRemoteRepeat(event)"
                    onpointerup="stopAdbRemoteRepeat(event)"
                    onpointerleave="stopAdbRemoteRepeat(event)"
                    onpointercancel="stopAdbRemoteRepeat(event)"
                    data-key="25"></button>
          </div>
        </div>
      </div>
      <div id="adbRemoteKeyboardPanel" class="adb-remote-keyboard-panel" style="display:none;">
        <div class="adb-remote-keyboard-panel-inner">
          <div class="adb-remote-keyboard-panel-header">
            <div class="adb-remote-keyboard-nav" aria-label="Навигация по тексту">
              <button type="button" class="adb-remote-keyboard-nav-btn"
                      aria-label="Влево" title="Влево"
                      onpointerdown="startAdbRemoteRepeat(event)"
                      onpointerup="stopAdbRemoteRepeat(event)"
                      onpointerleave="stopAdbRemoteRepeat(event)"
                      onpointercancel="stopAdbRemoteRepeat(event)"
                      data-key="21">←</button>
              <button type="button" class="adb-remote-keyboard-nav-btn"
                      aria-label="Вправо" title="Вправо"
                      onpointerdown="startAdbRemoteRepeat(event)"
                      onpointerup="stopAdbRemoteRepeat(event)"
                      onpointerleave="stopAdbRemoteRepeat(event)"
                      onpointercancel="stopAdbRemoteRepeat(event)"
                      data-key="22">→</button>
            </div>
            <span id="adbRemoteKeyboardStatus" class="adb-remote-keyboard-status"></span>
            <div class="adb-remote-keyboard-header-btns">
              <button type="button" class="adb-remote-keyboard-icon-btn" data-key="67" aria-label="Backspace" title="Удалить символ (удерживать — ускоренное удаление)"
                    onpointerdown="startAdbRemoteRepeat(event)"
                    onpointerup="stopAdbRemoteRepeat(event)"
                    onpointerleave="stopAdbRemoteRepeat(event)"
                    onpointercancel="stopAdbRemoteRepeat(event)">⌫</button>
              <button type="button" class="adb-remote-keyboard-icon-btn adb-remote-keyboard-close-btn" onclick="toggleAdbRemoteKeyboardPanel()" aria-label="Закрыть">✕</button>
            </div>
          </div>
          <textarea id="adbRemoteKeyboardInput" class="adb-remote-keyboard-input" rows="1" placeholder="Введите текст…" autocomplete="off"></textarea>
          <div class="adb-remote-keyboard-actions">
            <button type="button" class="sys-btn adb-remote-keyboard-btn secondary" onclick="pasteFromPhoneAndSendToDevice()">Вставить из буфера</button>
          </div>
        </div>
      </div>
      <div class="adb-remote-grid">
        <div id="adbRemoteDpad"
             class="adb-remote-dpad"
             aria-label="Навигация"
             onpointerdown="startAdbDpad(event)"
             onpointermove="moveAdbDpad(event)"
             onpointerup="stopAdbDpad(event)"
             onpointerleave="stopAdbDpad(event)"
             onpointercancel="stopAdbDpad(event)">
          <span class="adb-remote-dpad-highlight"></span>
          <span class="adb-remote-dpad-line vertical"></span>
          <span class="adb-remote-dpad-line horizontal"></span>
        </div>
        <div class="adb-remote-ok"
             role="button"
             tabindex="0"
             aria-label="OK"
             onpointerdown="startOkHold(event)"
             onpointerup="stopOkHold(event)"
             onpointerleave="stopOkHold(event)"
             onpointercancel="stopOkHold(event)"
             onkeydown="if (event.key === 'Enter' || event.key === 'OK' || event.code === 'Enter') { sendAdbRemoteKey(23); }">
          OK
        </div>
      </div>
      <div class="adb-remote-row">
        <button class="sys-btn adb-remote-btn wide"
                onpointerdown="startBackHold(event)"
                onpointerup="stopBackHold(event)"
                onpointerleave="stopBackHold(event)"
                onpointercancel="stopBackHold(event)">
          Назад
        </button>
        <button class="sys-btn adb-remote-btn wide" onclick="sendAdbRemoteKey(3)">Домой</button>
      </div>
      <div class="adb-remote-row menu">
        <button class="sys-btn adb-remote-btn wide" onclick="sendAdbRemoteKey(82)">Меню</button>
      </div>
    </div>
  </div>

  <!-- Модалка настроек заставки -->
  <div id="screenSaverModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <h3 id="screenSaverHeader" style="display:flex;align-items:center;justify-content:center;gap:8px;">
        <img src="https://appassets.androidplatform.net/assets/webview/icons/network/ic_wifi.png" alt="" style="height:26px;">
        Заставка
      </h3>
      <div class="screen-saver-body">
        <div class="screen-saver-section">
          <div class="screen-saver-row">
            <label>Состояние</label>
            <div id="screenSaverState" class="screen-saver-value">—</div>
          </div>
          <div class="screen-saver-row">
            <label>Текущая заставка</label>
            <div id="screenSaverCurrent" class="screen-saver-value">—</div>
          </div>
          <div class="screen-saver-row">
            <label>Запуск заставки</label>
            <button id="screenSaverIdleBtn" class="sys-btn" onclick="openScreenSaverTimeoutModal('screen')">
              —
            </button>
          </div>
          <div class="screen-saver-row">
            <label>Сон при бездействии</label>
            <button id="screenSaverSleepBtn" class="sys-btn" onclick="openScreenSaverTimeoutModal('sleep')">
              —
            </button>
          </div>
        </div>

        <div class="screen-saver-section">
          <h4>Выбор заставки</h4>
          <div class="screen-saver-actions">
            <button id="screenSaverAerialViewsBtn" class="sys-btn screen-saver-action-btn" onclick="setScreenSaverPackage('com.neilturner.aerialviews')">
              <img src="https://appassets.androidplatform.net/assets/webview/icons/screenserver/ic_AerialViews.webp" alt="Aerial Views">
              <span>Aerial Views</span>
            </button>
            <button id="screenSaverAerialDreamBtn" class="sys-btn screen-saver-action-btn" onclick="setScreenSaverPackage('com.codingbuffalo.aerialdream')">
              <img src="https://appassets.androidplatform.net/assets/webview/icons/screenserver/ic_AerialDream.webp" alt="Aerial Dream" style="height:22px;">
              <span>Aerial Dream</span>
            </button>
            <button id="screenSaverToggleBtn" class="sys-btn" onclick="toggleScreenSaver()">
              Отключить заставку
            </button>
          <button class="sys-btn" onclick="RunScreenSaverSettings()">Проверка заставки</button>
            <button class="sys-btn" onclick="resetScreenSaverSettings()">Сброс настроек заставки</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Модалка таймаута заставки -->
  <div id="screenSaverTimeoutModal" class="modal" style="display:none;" tabindex="-1">
    <div class="modal-content">
      <h3 id="screenSaverTimeoutTitle" style="text-align:center;">Изменение таймера</h3>
      <div class="screen-saver-timeout-body">
        <div class="screen-saver-timeout-field">
          <label id="screenSaverTimeoutLabel">Минуты</label>
          <input id="screenSaverTimeoutInput" type="text" inputmode="numeric" pattern="[0-9]*" />
          <div class="screen-saver-timeout-hint" id="screenSaverTimeoutHint">Допустимые значения: 1–1440 минут</div>
        </div>
      </div>
      <div class="system-buttons" style="justify-content:center;">
        <button id="screenSaverTimeoutApply" class="sys-btn" onclick="applyScreenSaverTimeout()">Применить</button>
        <button id="screenSaverTimeoutCancel" class="sys-btn" onclick="closeScreenSaverTimeoutModal()">Отмена</button>
      </div>
    </div>
  </div>

  <!-- Модалка списка компонентов -->
  <div id="modal" class="modal" style="display:none;">
    <div class="modal-content">
      <h3 id="modalGroupHeader" style="display:flex;gap:8px;align-items:center;justify-content:center;"></h3>
      <div id="modalListContainer">
        <div id="modalList"></div>
        <div id="groupSelectActions">
          <button id="selectAllBtn" class="component-btn" onclick="selectAllGroupItems()">Выбрать все</button>
        </div>
        <button id="installAllBtn" onclick="installAll()" class="component-btn">Установить всё</button>
      </div>
    </div>
  </div>

  <script>
    // Список ADB-команд. Изменяйте этот массив, чтобы обновить команды у всех пользователей.
    const ADB_COMMANDS = [
      {
        id: 1008,
        command: "am start -a android.intent.action.OPEN_DOCUMENT -c android.intent.category.OPENABLE -t \"application/vnd.android.package-archive\"",
        description: "Для Google TV 12+",
        label: "Выбор проводника",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/group/ic_default_icon_groups2.png",
        isEnabled: true,
        uid: "d1c3a7ab-8f7a-4c9a-9f5e-commands-open-document"
      },
      {
        id: 1009,
        command: "settings put system screen_off_timeout 1800000",
        description: "Таймер заставки",
        label: "Заставка: 30 минут",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic12_ScreenServer.png",
        isEnabled: true,
        uid: "3fcd28d1-0f6e-4f3a-adb1-screen-timeout"
      },
      {
        id: 1010,
        command: "settings put secure sleep_timeout 28800000",
        description: "Таймер сна",
        label: "Сон: 8 часов",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic12_ScreenServer.png",
        isEnabled: true,
        uid: "12dc0a6d-7fb2-4149-adb1-sleep-timeout"
      },
      {
        id: 1011,
        command: "cmd package install-existing com.google.android.apps.tv.launcherx || pm install-existing com.google.android.apps.tv.launcherx; cmd package enable --user 0 com.google.android.apps.tv.launcherx; pm enable --user 0 com.google.android.apps.tv.launcherx; cmd package enable com.google.android.apps.tv.launcherx; cmd package enable --user 0 com.google.android.tungsten.setupwraith; pm enable --user 0 com.google.android.tungsten.setupwraith; cmd package enable com.google.android.tungsten.setupwraith; pm path com.google.android.apps.tv.launcherx >/dev/null 2>&1 && { cmd notification allow_listener com.google.android.apps.tv.launcherx/com.google.android.apps.tv.launcherx.notifications.NotificationListenerService || true; cmd notification allow_listener com.google.android.apps.tv.launcherx/com.google.android.apps.tv.launcherx.coreservices.notificationlistener.TvNotificationListenerService || true; cmd notification disallow_listener com.spocky.projengmenu/com.spocky.projengmenu.services.ProjectivyNotificationListener || true; cmd notification disallow_listener com.spocky.projengmenu/com.spocky.projengmenu.services.notification.NotificationListener || true; cmd notification disallow_listener com.google.android.tvlauncher/com.google.android.tvlauncher.notifications.NotificationListenerService || true; } || true; cmd role add-role-holder android.app.role.HOME com.google.android.apps.tv.launcherx || true; cmd package set-home-activity com.google.android.apps.tv.launcherx/.ui.HomeActivity || true",
        description: " ",
        label: "Включить Google TV Home",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic19_GTV.webp",
        isEnabled: true,
        uid: "launcher-restore-google-tv"
      },
      {
        id: 1012,
        command: "cmd package install-existing com.google.android.tvlauncher || pm install-existing com.google.android.tvlauncher; cmd package enable --user 0 com.google.android.tvlauncher; pm enable --user 0 com.google.android.tvlauncher; cmd package enable com.google.android.tvlauncher; pm path com.google.android.tvlauncher >/dev/null 2>&1 && { cmd notification allow_listener com.google.android.tvlauncher/com.google.android.tvlauncher.notifications.NotificationListenerService || true; cmd notification disallow_listener com.spocky.projengmenu/com.spocky.projengmenu.services.ProjectivyNotificationListener || true; cmd notification disallow_listener com.spocky.projengmenu/com.spocky.projengmenu.services.notification.NotificationListener || true; pm path com.google.android.apps.tv.launcherx >/dev/null 2>&1 && { cmd notification disallow_listener com.google.android.apps.tv.launcherx/com.google.android.apps.tv.launcherx.notifications.NotificationListenerService || true; cmd notification disallow_listener com.google.android.apps.tv.launcherx/com.google.android.apps.tv.launcherx.coreservices.notificationlistener.TvNotificationListenerService || true; } || true; } || true; cmd role add-role-holder android.app.role.HOME com.google.android.tvlauncher || true; cmd package set-home-activity com.google.android.tvlauncher/.ui.HomeActivity || true",
        description: " ",
        label: "Включить Android TV Home",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png",
        isEnabled: true,
        uid: "launcher-restore-android-tv"
      },
      {
        id: 1015,
        command: "su -c 'pm uninstall -k --user 0 com.google.android.apps.tv.launcherx || true; cmd package install-existing com.google.android.tvlauncher || pm install-existing com.google.android.tvlauncher || true; cmd package enable --user 0 com.google.android.tvlauncher; pm enable --user 0 com.google.android.tvlauncher; cmd package enable com.google.android.tvlauncher; pm path com.google.android.tvlauncher >/dev/null 2>&1 && { cmd notification allow_listener com.google.android.tvlauncher/com.google.android.tvlauncher.notifications.NotificationListenerService || true; } || true'",
        description: "Root: удаляет GTV Home для user 0, включает ATV Home и выдаёт слушатель уведомлений.",
        label: "Включить ATV (root)",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png",
        isEnabled: true,
        uid: "launcher-restore-android-tv-root"
      },
      {
        id: 1013,
        command: "cmd package install-existing com.spocky.projengmenu || pm install-existing com.spocky.projengmenu; cmd package enable --user 0 com.spocky.projengmenu; pm enable --user 0 com.spocky.projengmenu; cmd package enable com.spocky.projengmenu && { cmd notification allow_listener com.spocky.projengmenu/com.spocky.projengmenu.services.ProjectivyNotificationListener || true; cmd notification allow_listener com.spocky.projengmenu/com.spocky.projengmenu.services.notification.NotificationListener || true; pm path com.google.android.apps.tv.launcherx >/dev/null 2>&1 && { cmd notification disallow_listener com.google.android.apps.tv.launcherx/com.google.android.apps.tv.launcherx.notifications.NotificationListenerService || true; cmd notification disallow_listener com.google.android.apps.tv.launcherx/com.google.android.apps.tv.launcherx.coreservices.notificationlistener.TvNotificationListenerService || true; } || true; pm path com.google.android.tvlauncher >/dev/null 2>&1 && { cmd notification disallow_listener com.google.android.tvlauncher/com.google.android.tvlauncher.notifications.NotificationListenerService || true; } || true; pm path com.google.android.tvlauncher >/dev/null 2>&1 && { cmd package install-existing com.google.android.tvlauncher || pm install-existing com.google.android.tvlauncher || true; cmd package disable-user --user 0 com.google.android.tvlauncher || true; pm disable-user --user 0 com.google.android.tvlauncher || true; } || true; pm path com.google.android.apps.tv.launcherx >/dev/null 2>&1 && { cmd package install-existing com.google.android.apps.tv.launcherx || pm install-existing com.google.android.apps.tv.launcherx || true; cmd package disable-user --user 0 com.google.android.apps.tv.launcherx || true; pm disable-user --user 0 com.google.android.apps.tv.launcherx || true; cmd package disable-user --user 0 com.google.android.tungsten.setupwraith || true; pm disable-user --user 0 com.google.android.tungsten.setupwraith || true; } || true; }",
        description: " ",
        label: "Projectivy Launcher",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic21_PJL.png",
        isEnabled: true,
        uid: "launcher-enable-projectivy"
      },
      {
        id: 1016,
        command: "am start -a android.settings.HOME_SETTINGS",
        description: "Открыть системный выбор домашнего приложения (лаунчера).",
        label: "Выбор лаунчера",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png",
        isEnabled: true,
        uid: "launcher-picker"
      },
      {
        id: 1017,
        command: "su -c 'setprop persist.vendor.usb.debug 0'",
        description: "ATV 11: фиксирует рабочий USB/ADB по Wi‑Fi после перезагрузки.",
        label: "USB debug фикс (ATV11)",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png",
        isEnabled: true,
        uid: "usb-debug-fix-atv11"
      },
      {
        id: 1018,
        command: "su -c 'while [ \"$(getprop sys.boot_completed)\" != \"1\" ]; do sleep 1; done; GPIO=474; BASE=/sys/class/gpio/gpio$GPIO; [ -e \"$BASE/direction\" ] || echo $GPIO > /sys/class/gpio/export 2>/dev/null; if [ -e \"$BASE/direction\" ]; then echo out > \"$BASE/direction\" 2>/dev/null; echo 1 > \"$BASE/value\" 2>/dev/null; fi'",
        description: "ATV 14: ставит GPIO 474 в out и value=1 после загрузки, если GPIO доступен.",
        label: "USB fix (ATV14)",
        icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png",
        isEnabled: true,
        uid: "usb-fix-atv14"
      },
      
      { id: 1014, command: "am force-stop com.google.android.katniss", description: "Эффект «стоп-кадр»", label: "Перезапуск Katniss", icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic18_back.png", isEnabled: true, uid: "force-stop-katniss" },
      { id: 1001, command: "reboot", description: "reboot", label: "Система", icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic18_back.png", isEnabled: true, uid: "171afb09-e150-4348-83b8-1f4fef2787aa" },
      { id: 1002, command: "reboot bootloader", description: "reboot bootloader", label: "Bootloader", icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic18_back.png", isEnabled: true, uid: "1000e8c1-025c-4621-92ff-a867210e8b96" },
      { id: 1003, command: "reboot fastboot", description: "reboot fastboot", label: "FastbootD", icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic18_back.png", isEnabled: true, uid: "29dcff70-46b2-4626-83d4-0b4bebc83957" },
      { id: 1004, command: "reboot recovery", description: "reboot recovery", label: "Recovery", icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic18_back.png", isEnabled: true, uid: "1f1426c1-1676-4e8b-845c-5349e7a1a9ae" },
      { id: 1005, command: "reboot sideload", description: "reboot sideload", label: "Sideload", icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic18_back.png", isEnabled: true, uid: "91788dc4-4247-488f-831a-7b0e823d50a3" },
      { id: 1006, command: "reboot update", description: "reboot update", label: "TWRP", icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic18_back.png", isEnabled: true, uid: "f537d6b2-4c49-46ab-affe-7f29e400f7fe" },
      { id: 1007, command: "reboot -p", description: "reboot -p", label: "Выключение (полное)", icon: "https://appassets.androidplatform.net/assets/webview/icons/misc/ic18_back.png", isEnabled: true, uid: "bdf56bfe-03ba-40b0-bb52-5723e9ee70af" }
    ];
    const BATTERY_WHITELIST_PACKAGES = [
      "dev.vodik7.tvquickactions",
      "org.acestream.media",
      "org.acestream.start",
      "org.acestream.core",
      "org.free.aceserve",
      "ru.yourok.torrserve",
      "io.github.romanvht.byedpi",
      "org.amnezia.awg",
      "org.acestream.live",
      "org.acestream.core.atv",
      "com.carriez.flutter_hbb",
      "atvhelper.ru",
      "atv.rustdesk"
    ];
    const USAGE_STATS_PACKAGES = [
      "dev.vodik7.tvquickactions",
      "org.acestream.media",
      "org.acestream.start",
      "org.acestream.core",
      "org.free.aceserve",
      "ru.yourok.torrserve",
      "io.github.romanvht.byedpi",
      "org.amnezia.awg",
      "org.acestream.live",
      "org.acestream.core.atv",
      "atv.rustdesk"
    ];
    const MANAGE_STORAGE_PACKAGES = [
      "dev.vodik7.tvquickactions",
      "ru.yourok.torrserve",
	    "com.mexplorer.silver",
      "ru.tiardev.kinotrend",
      "com.carriez.flutter_hbb",
      "atvhelper.ru",
      "atv.rustdesk"
    ];
    const OVERLAY_PACKAGES = [
      "dev.vodik7.tvquickactions",
      "ar.tvplayer.tv",
      "com.softmedia.receiver",
      "com.carriez.flutter_hbb",
      "atvhelper.ru",
      "atv.rustdesk"
    ];
    const WRITE_SETTINGS_PACKAGES = [
      "dev.vodik7.tvquickactions",
      "ru.yourok.torrserve",
      "org.acestream.media"
    ];
    const PROJECT_MEDIA_PACKAGES = [
      "com.carriez.flutter_hbb",
      "atvhelper.ru",
      "atv.rustdesk"
    ];
    const EXACT_ALARM_PACKAGES = [
      "dev.vodik7.tvquickactions",
      "org.amnezia.awg"
    ];
    const NOTIFICATION_LISTENER_SERVICES = [
      {
        pkg: "dev.vodik7.tvquickactions",
        service: "dev.vodik7.tvquickactions/.services.NotificationListenerService"
      }
    ];
    const ACCESSIBILITY_SERVICES = [
      "ru.yourok.torrserve/ru.yourok.torrserve.server.local.services.GlobalTorrService",
      "dev.vodik7.tvquickactions/dev.vodik7.tvquickactions.KeyAccessibilityService",
      "flar2.homebutton/a.i",
      "com.spocky.projengmenu/com.spocky.projengmenu.services.ProjectivyAccessibilityService",
      "atvhelper.ru/com.carriez.flutter_hbb.InputService",
      "atv.rustdesk/com.carriez.flutter_hbb.InputService"
    ];
const ACCESSIBILITY_PACKAGES = [
  "ru.yourok.torrserve",
  "dev.vodik7.tvquickactions",
  "flar2.homebutton",
  "com.spocky.projengmenu",
  "io.github.romanvht.byedpi",
  "org.amnezia.awg",
  "com.carriez.flutter_hbb",
  "atvhelper.ru",
  "atv.rustdesk"
];
    const MICROPHONE_PERMISSION = "android.permission.RECORD_AUDIO";
    const MICROPHONE_PERMISSION_PACKAGES = [
      
      "com.google.android.youtube.tv",
      
      "org.liskovsoft.androidtv.rukeyboard"
    ];
    const DEFAULT_KEYBOARD_IME = "org.liskovsoft.androidtv.rukeyboard/com.liskovsoft.leankeyboard.ime.LeanbackImeService";
    const DEFAULT_SCREENSAVER_COMPONENT = "com.neilturner.aerialviews/.ui.screensaver.DreamActivity";
    const DEFAULT_SCREENSAVER_PACKAGE = "com.neilturner.aerialviews";
    const ADB_ICON_CONNECTED = "https://appassets.androidplatform.net/assets/webview/icons/network/ic_ADB_on.png";
    const ADB_ICON_DISCONNECTED = "https://appassets.androidplatform.net/assets/webview/icons/network/ic_ADB_off.png";
    const modalActionAtvRefresh = {
      key: 'modal-action-atv-refresh',
      icon: 'https://appassets.androidplatform.net/assets/webview/icons/main/ic10_updWebView.png',
      label: 'Обновить список',
      run() { refreshAtvAppsList('remote'); }
    };

    const MODAL_HEADER_ACTIONS = [
      {
        key: 'modal-action-all-apps',
        icon: 'https://appassets.androidplatform.net/assets/webview/icons/main/ic12_about.png',
        label: 'Меню приложений',
        run(btn) {
          ignoreNextEnter = true;
          try {
            window.AndroidInterface?.openAllAppsSide?.();
          } catch (err) {
            console.warn('openAllAppsSide недоступен', err);
          }
        }
      },
      {
        key: 'modal-action-screen-saver',
        icon: 'https://appassets.androidplatform.net/assets/webview/icons/main/ic13_about.png',
        label: 'Заставка',
        run(btn) {
          openScreenSaverModal(btn);
        }
      },
      {
        key: 'modal-action-adb-commands',
        icon: 'https://appassets.androidplatform.net/assets/webview/icons/main/ic14_about.png',
        label: 'ADB команды',
        run(btn) {
          openAdbCommandsFromButton(btn);
        }
      },
      modalActionAtvRefresh
    ];
    let modalOverlayCounter = 1000;
    const MODAL_Z_STEP = 5;

    const SCREEN_SAVER_TIMEOUT_LIMITS = { min: 1, max: 1440 };
    const SCREEN_SAVER_TIMEOUT_DEFAULTS = { screen: 60, sleep: 480 };
    const SCREEN_SAVER_TIMEOUT_LABELS = {
      screen: 'Отключение при бездействии',
      sleep: 'Отключение при просмотре'
    };

    let currentGroup = "";
    let cachedConfig = null;
    let lastFocusedElement = null;
    let lastPassword = "";
    let backupQueue = [];
    let backupTarget = "";
    let savedPassword = "";
let ignoreNextEnter = false;
let __installMethodApplying = false;
let lastFocusedElementMiscMore = null;
let lastFocusedElementManualConnect = null;
let lastFocusedElementAdbCommands = null;
let lastAdbCommandsTriggerButton = null;
let lastScreenSaverTrigger = null;
let screenSaverTimeoutState = { screen: null, sleep: null };
let screenSaverTimeoutModalType = null;
let screenSaverTimeoutReturnEl = null;
let currentScreenSaverComponent = null;
let storageUsageLabel = '';
let lastAdbIndicatorText = '';
let lastAdbIndicatorConnected = false;
let autostartReturnModal = null;
let autostartOpener = null;

const ADB_ROOT_LOG_ID = 'adbRootDiagOutput';

function setAdbRootLog(text) {
  const box = document.getElementById(ADB_ROOT_LOG_ID);
  if (!box) return;
  if (text && text.length) {
    box.style.display = 'block';
    box.textContent = text;
  } else {
    box.textContent = '';
    box.style.display = 'none';
  }
}

    document.getElementById('passwordBtn').addEventListener('click', () => {
      const ai = window.AndroidInterface;
      if (ai?.requestPasswordPrefill) { ai.requestPasswordPrefill(savedPassword || ""); return; }
      if (ai?.requestPassword) { try { ai.requestPassword(savedPassword || ""); return; } catch (e) { ai.requestPassword(); return; } }
      const pwd = prompt("Введите пароль", savedPassword || "");
      if (pwd !== null) { savedPassword = pwd.trim(); updatePasswordBtn(); }
    });

    function setPasswordFromAndroid(pwd) { savedPassword = (pwd || "").trim(); updatePasswordBtn(); }
    function updatePasswordBtn() {
      const btn = document.getElementById('passwordBtn');
      const icon = document.getElementById('passwordBtnIcon');
      const hasPwd = !!savedPassword;
      const tip = hasPwd ? `Пароль: ${'*'.repeat(savedPassword.length)}` : 'Введите пароль';
      const iconSrc = hasPwd
        ? 'https://appassets.androidplatform.net/assets/webview/icons/screenserver/ic_AerialViews.webp'
        : 'https://appassets.androidplatform.net/assets/webview/icons/screenserver/ic_AerialDream.webp';
      if (icon) icon.src = iconSrc;
      if (btn) {
        btn.title = tip;
        btn.setAttribute('aria-label', tip);
        btn.setAttribute('data-tip', tip);
      }
    }
    function anyModalOpen() { return ['modal','autostartModal','atvAppsModal','atvAppActionsModal','launcherModal','launcherActionsModal','miscModal','installMethodModal','adbScannerModal','adbManualConnectModal','adbCommandsModal','adbRemoteModal','screenSaverModal','screenSaverTimeoutModal'].some(id => document.getElementById(id)?.style.display === 'flex'); }

    function copyBackupsSequentially(urls, folder) { if (!urls.length) return; backupQueue = urls; backupTarget = folder; copyNextBackup(); }
    function copyNextBackup() {
      if (backupQueue.length === 0) { showStatus("✅ Все бэкапы скопированы", "green"); return; }
      const url = backupQueue.shift(); const fileName = url.split('/').pop();
      showStatus(`⏳ Копирование: ${fileName} <span class="spin"><img src="https://appassets.androidplatform.net/assets/webview/icons/title/ic_load_round.png" style="height:29px; vertical-align:middle;"></span>`, "#00cfff", 4000);
      window.AndroidInterface?.copyBackup(url, backupTarget);
    }
    function onBackupCopied() { copyNextBackup(); }

    const disablePackageStates = new Map();

let adbStatusRetryTimer = null;

function setAdbIndicator(text, connected) {
  lastAdbIndicatorText = text || '';
  lastAdbIndicatorConnected = !!connected;
  const safeBase = escapeHtml(lastAdbIndicatorText);
  const base = safeBase.length ? safeBase : '&nbsp;';
  const storagePart = storageUsageLabel
    ? ` <span class="storage-usage-badge">${escapeHtml(storageUsageLabel)}</span>`
    : '';
  document.querySelectorAll('.adb-status-indicator').forEach((el) => {
    el.innerHTML = `${base}${storagePart}`;
    el.classList.toggle('connected', !!connected);
  });
  document.querySelectorAll('#passwordRow .adb-status-icon').forEach((btn) => {
    btn.title = (text || '').trim() || 'Подключиться к последнему ADB';
    btn.setAttribute('aria-label', btn.title);
    btn.classList.toggle('connected', !!connected);
  });
  syncModalAdbIndicators(!!connected);
}

function refreshAdbStatusIndicator() {
  try {
    const raw = window.AndroidInterface?.getAdbConnectionInfo?.();
    if (!raw || raw === 'undefined') {
      setAdbIndicator('Локальное устройство', false);
      scheduleAdbStatusRetry();
      return;
    }
    const info = JSON.parse(raw);
    const fallback = info.connected ? 'ADB подключен' : 'Локальное устройство';
    setAdbIndicator(info.label || fallback, info.connected);
  } catch (e) {
    console.warn('ADB status update error', e);
    setAdbIndicator('ADB: статус неизвестен', false);
  }
}

function scheduleAdbStatusRetry() {
  clearTimeout(adbStatusRetryTimer);
  adbStatusRetryTimer = setTimeout(refreshAdbStatusIndicator, 2000);
}

window.refreshAdbStatusIndicator = refreshAdbStatusIndicator;

function updateStorageUsage(label) {
  if (typeof label === 'string' && label.trim().length) {
    storageUsageLabel = label.trim();
  } else {
    storageUsageLabel = '';
  }
  setAdbIndicator(lastAdbIndicatorText, lastAdbIndicatorConnected);
}

function escapeHtml(value) {
  return String(value ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

window.updateStorageUsage = updateStorageUsage;

function handleAdbTcpToggle(enable, triggerBtn) {
  const method = enable ? 'enableAdbTcp5555' : 'disableAdbTcp';
  const available = window.AndroidInterface?.[method];
  if (!available) {
    showToast({ message: "❌ Управление ADB по сети недоступно", type: "error" });
    return;
  }
  if (window.AndroidInterface?.hasRootAccess && !window.AndroidInterface.hasRootAccess()) {
    showToast({ message: "❌ Нужен root (su)", type: "error" });
    setAdbRootLog("Нужен root (su) для этой операции");
    return;
  }
  setAdbRootLog(enable ? '⏳ Включаю ADB по сети (5555)…' : '⏳ Отключаю ADB по сети…');
  let raw = '';
  try {
    raw = available.call(window.AndroidInterface) || '';
  } catch (e) {
    showToast({ message: "❌ Ошибка вызова su-команды", type: "error" });
    setAdbRootLog(`Ошибка: ${e?.message || e}`);
    return;
  }
  let data = null;
  try { data = JSON.parse(raw); } catch (_) {}
  const ok = data?.ok === true;
  const output = (data?.output || raw || '').trim();
  setAdbRootLog(output || 'Нет вывода');
  if (ok) {
    showToast({ message: enable ? "✅ ADB по сети 5555 включён" : "✅ ADB по сети отключён", type: "success" });
  } else {
    const reason = data?.error === "root_required" ? "Нужен root (su)" : (output || "неизвестная ошибка");
    showToast({ message: `❌ ${reason}`, type: "error" });
  }
}

const adbScanState = {
  hosts: [],
  running: false,
  status: 'Ожидание...'
};
const FRIENDLY_NAME_FALLBACK = 'Неизвестное устройство';

function applyFriendlyNameNode(node, friendlyName) {
  if (!node) return;
  const label = (friendlyName || '').trim();
  if (label) {
    node.textContent = label;
    node.classList.remove('adb-device-name--placeholder');
  } else {
    node.textContent = FRIENDLY_NAME_FALLBACK;
    node.classList.add('adb-device-name--placeholder');
  }
}

function resetAdbConnectionState() {
  window.AndroidInterface?.disconnectAdb?.();
  setAdbIndicator('Локальное устройство', false);
  updateStorageUsage('');
}

function requestLocalAdbConnection() {
  resetAdbConnectionState();
  window.AndroidInterface?.connectAdb?.();
}

function refreshLastAdbConnection() {
  const wrapper = document.getElementById('lastAdbConnectionWrapper');
  const btn = document.getElementById('lastAdbConnectionBtn');
  if (!wrapper || !btn) return;
  const hideWrapper = () => {
    wrapper.style.display = 'none';
    wrapper.classList.remove('active');
    btn.dataset.host = '';
    btn.dataset.port = '';
    btn.innerHTML = '';
    btn.classList.remove('is-selected', 'selected');
  };
  let raw;
  try {
    raw = window.AndroidInterface?.getLastAdbConnectionInfo?.();
  } catch (e) {
    raw = null;
  }
  if (!raw || raw === 'undefined') {
    hideWrapper();
    return;
  }
  let info;
  try {
    info = JSON.parse(raw);
  } catch (e) {
    hideWrapper();
    return;
  }
  if (!info || !info.available) {
    hideWrapper();
    return;
  }
  const host = (info.host || '').trim();
  const friendly = (info.friendly || '').trim();
  const topLine = friendly || host;
  const ipLine = host;
  btn.innerHTML = topLine
    ? `<span class="adb-last-connection-btn-line1">${topLine}</span>${ipLine ? `<span class="adb-last-connection-btn-line2">${ipLine}</span>` : ''}`
    : '';
  btn.dataset.host = host;
  btn.dataset.port = info.port != null ? String(info.port) : '';
  if (topLine) {
    wrapper.style.display = 'flex';
    wrapper.classList.add('active');
    btn.classList.remove('is-selected', 'selected');
  } else {
    hideWrapper();
  }
}

function connectToLastAdb() {
  const btn = document.getElementById('lastAdbConnectionBtn');
  if (!btn) return;
  const host = btn.dataset.host;
  const port = parseInt(btn.dataset.port || '', 10) || 5555;
  if (!host) return;
  const scannerModal = document.getElementById('adbScannerModal');
  const scannerVisible = scannerModal && scannerModal.style.display === 'flex';
  if (scannerVisible) {
    closeAdbScanner();
    setTimeout(() => connectToRemoteAdb(host, port), 150);
  } else {
    connectToRemoteAdb(host, port);
  }
}

window.refreshLastAdbConnection = refreshLastAdbConnection;

function openAdbScanner() {
  resetAdbConnectionState();
  refreshAdbStatusIndicator();
  updateStorageUsage('');
  window.AndroidInterface?.requestStorageUsageRefresh?.();
  const modal = document.getElementById('adbScannerModal');
  if (!modal) return;
  const miscModal = document.getElementById('miscModal');
  const miscMoreModal = document.getElementById('miscMoreModal');
  modal.dataset.restoreMisc = '0';
  modal.dataset.restoreMiscMore = '0';
  if (miscModal && miscModal.style.display === 'flex') {
    miscModal.setAttribute('inert', '');
    miscModal.style.pointerEvents = 'none';
    modal.dataset.restoreMisc = '1';
  }
  if (miscMoreModal && miscMoreModal.style.display === 'flex') {
    miscMoreModal.setAttribute('inert', '');
    miscMoreModal.style.pointerEvents = 'none';
    modal.dataset.restoreMiscMore = '1';
  }
  lastFocusedElement = document.activeElement;
  adbScanState.hosts = [];
  renderAdbScanHosts();
  updateAdbScanStatus('Сканирование сети...', 0);
  modal.style.display = 'flex';
  bringModalToFront(modal);
  document.body.classList.add('modal-open');
  document.activeElement?.blur();
  refreshLastAdbConnection();
  setTimeout(() => {
    if (focusLastAdbConnectionButton(true)) return;
    const firstCard = document.querySelector('#adbScanList .adb-device-card');
    if (firstCard) {
      focusAndRevealAdbCard(firstCard);
      return;
    }
    const firstBtn = modal.querySelector('.system-buttons .sys-btn');
    if (firstBtn) {
      firstBtn.focus({ preventScroll: true });
    } else {
      modal.focus();
    }
  }, 120);
  try {
    window.AndroidInterface?.startNativeAdbScan?.();
  } catch (e) {}
}

function closeAdbScanner() {
  const modal = document.getElementById('adbScannerModal');
  if (!modal) return;
  modal.style.display = 'none';
  modal.style.zIndex = '';
  document.body.classList.remove('modal-open');
  if (modal.dataset.restoreMisc === '1') {
    const misc = document.getElementById('miscModal');
    if (misc) {
      misc.removeAttribute('inert');
      misc.style.pointerEvents = '';
    }
    modal.dataset.restoreMisc = '0';
  }
  if (modal.dataset.restoreMiscMore === '1') {
    const miscMore = document.getElementById('miscMoreModal');
    if (miscMore) {
      miscMore.removeAttribute('inert');
      miscMore.style.pointerEvents = '';
    }
    modal.dataset.restoreMiscMore = '0';
  }
  try {
    window.AndroidInterface?.stopNativeAdbScan?.();
  } catch (e) {}
  if (lastFocusedElement && document.body.contains(lastFocusedElement)) {
    lastFocusedElement.focus({ preventScroll: true });
  }
  lastFocusedElement = null;
    restoreGroupModalOverlay();
}

function restartAdbScan() {
  try {
    window.AndroidInterface?.stopNativeAdbScan?.();
  } catch (e) {}
  setTimeout(() => {
    try { window.AndroidInterface?.startNativeAdbScan?.(); } catch (err) {}
  }, 250);
}

function renderAdbScanHosts() {
  const list = document.getElementById('adbScanList');
  if (!list) return;
  list.innerHTML = '';
  if (!adbScanState.hosts.length) {
    const placeholder = document.createElement('div');
    placeholder.style.opacity = '.7';
    placeholder.style.textAlign = 'center';
    placeholder.textContent = adbScanState.running ? 'Ищем устройства...' : 'Устройства не найдены';
    list.appendChild(placeholder);
    return;
  }
  adbScanState.hosts.forEach(host => {
    const card = document.createElement('button');
    card.type = 'button';
    card.className = 'adb-chip adb-device-card';
    let connectTriggered = false;

    const nameEl = document.createElement('div');
    nameEl.className = 'adb-device-name';
    applyFriendlyNameNode(nameEl, host?.friendlyName);

    const ipEl = document.createElement('div');
    ipEl.className = 'adb-device-ip';
    ipEl.textContent = host?.ip || '—';

    card.append(nameEl, ipEl);
    const handleConnect = () => {
      if (connectTriggered) return;
      const ip = host?.ip;
      if (!ip) return;
      connectTriggered = true;
      closeAdbScanner();
      setTimeout(() => {
        connectToRemoteAdb(ip, host?.port || 5555);
        connectTriggered = false;
      }, 150);
    };
    const activationKeys = ['Enter', 'OK', 'Select', ' '];

    card.addEventListener('click', (event) => {
      event.preventDefault();
      document.querySelectorAll('#adbScanList .adb-device-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      handleConnect();
    });
    card.addEventListener('focus', () => {
      document.querySelectorAll('#adbScanList .adb-device-card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      focusAndRevealAdbCard(card);
    });
    const handleKeyActivation = (event) => {
      if (!activationKeys.includes(event.key)) return;
      event.preventDefault();
      handleConnect();
    };
    card.addEventListener('keydown', handleKeyActivation);
    card.addEventListener('keyup', handleKeyActivation);
    card.addEventListener('keypress', handleKeyActivation);
    list.appendChild(card);
  });
}

function updateAdbScanStatus(message = null, totalOverride = null) {
  const status = document.getElementById('adbScanStatus');
  if (!status) return;
  if (typeof message === 'string' && message.length) {
    adbScanState.status = message;
  }
  const running = !!adbScanState.running;
  const fallback = running ? 'Сканирование сети…' : 'Сканирование завершено';
  const base = adbScanState.status || fallback;
  const total = typeof totalOverride === 'number' ? totalOverride : adbScanState.hosts.length;

  status.classList.toggle('adb-scan-complete', !running);
  status.textContent = '';

  const label = document.createElement('span');
  label.className = 'adb-scan-label';
  label.textContent = base;
  status.appendChild(label);

  if (running) {
    const spinnerWrap = document.createElement('span');
    spinnerWrap.className = 'adb-scan-spinwrap';
    const spinnerEl = document.createElement('span');
    spinnerEl.className = 'adb-scan-spinner';
    spinnerWrap.appendChild(spinnerEl);
    status.appendChild(spinnerWrap);
  }

  const totalSpan = document.createElement('span');
  totalSpan.className = 'adb-scan-total';
  totalSpan.textContent = `• Найдено: ${total}`;
  status.appendChild(totalSpan);
}

window.__applyAdbScanResults = function(payload) {
  let data = [];
  try {
    data = Array.isArray(payload) ? payload : JSON.parse(payload);
  } catch (e) {
    console.error('applyAdbScanResults parse error', e);
    return;
  }
  if (!Array.isArray(data)) data = [];
  adbScanState.hosts = data;
  renderAdbScanHosts();
  updateAdbScanStatus();
};

window.__handleAdbScanStatus = function(message, running, total) {
  if (typeof running === 'boolean') {
    adbScanState.running = running;
  }
  updateAdbScanStatus(typeof message === 'string' ? message : null, typeof total === 'number' ? total : null);
};

function connectToRemoteAdb(ip, port) {
  ignoreNextEnter = true;
  try {
    if (window.AndroidInterface?.connectAdbToHost) {
      window.AndroidInterface.connectAdbToHost(ip, port);
    } else if (window.AndroidInterface?.connectAdbTo) {
      window.AndroidInterface.connectAdbTo(`${ip}:${port}`);
    } else if (window.AndroidInterface?.connectAdb) {
      window.AndroidInterface.connectAdb(`${ip}:${port}`);
    } else {
      showToast({ message: 'Метод подключения ADB недоступен', type: 'error' });
    }
  } catch (e) {
    showToast({ message: 'Ошибка подключения ADB', type: 'error' });
  }
}

function attachAdbManualInputHandlers() {
  ['adbManualHostInput', 'adbManualPortInput'].forEach((id) => {
    const input = document.getElementById(id);
    if (input && !input.dataset.manualBound) {
      input.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          submitAdbManualConnect();
        }
      });
      input.dataset.manualBound = '1';
    }
  });
}

function openAdbManualConnectModal() {
  const modal = document.getElementById('adbManualConnectModal');
  if (!modal) return;
  ignoreNextEnter = true;
  const miscModal = document.getElementById('miscModal');
  const miscMoreModal = document.getElementById('miscMoreModal');
  const scannerModal = document.getElementById('adbScannerModal');
  modal.dataset.restoreMisc = '0';
  modal.dataset.restoreMiscMore = '0';
  modal.dataset.restoreScanner = '0';
  if (miscModal && miscModal.style.display === 'flex') {
    miscModal.setAttribute('inert', '');
    miscModal.style.pointerEvents = 'none';
    modal.dataset.restoreMisc = '1';
  }
  if (miscMoreModal && miscMoreModal.style.display === 'flex') {
    miscMoreModal.setAttribute('inert', '');
    miscMoreModal.style.pointerEvents = 'none';
    modal.dataset.restoreMiscMore = '1';
  }
  if (scannerModal && scannerModal.style.display === 'flex') {
    scannerModal.setAttribute('inert', '');
    scannerModal.style.pointerEvents = 'none';
    modal.dataset.restoreScanner = '1';
  }
  lastFocusedElementManualConnect = document.activeElement;
  document.activeElement?.blur();
  modal.style.display = 'flex';
  bringModalToFront(modal);
  document.body.classList.add('modal-open');

  const hostInput = document.getElementById('adbManualHostInput');
  const portInput = document.getElementById('adbManualPortInput');
  try {
    const raw = window.AndroidInterface?.getLastAdbConnectionInfo?.();
    if (raw && raw !== 'undefined') {
      const info = JSON.parse(raw);
      if (hostInput && !hostInput.value.trim()) hostInput.value = info.host || '';
      if (portInput && !portInput.value.trim()) {
        const lastPort = parseInt(info.port, 10);
        if (Number.isFinite(lastPort) && lastPort > 0) portInput.value = String(lastPort);
      }
    }
  } catch (err) {
    console.warn('prefill manual connect error', err);
  }

  attachAdbManualInputHandlers();

  setTimeout(() => hostInput?.focus({ preventScroll: true }), 120);
}

function closeAdbManualConnectModal() {
  const modal = document.getElementById('adbManualConnectModal');
  if (!modal) return;
  modal.style.display = 'none';
  document.body.classList.remove('modal-open');

  let needRestoreModalClass = false;

  if (modal.dataset.restoreMisc === '1') {
    const misc = document.getElementById('miscModal');
    if (misc) {
      misc.removeAttribute('inert');
      misc.style.pointerEvents = '';
      if (misc.style.display === 'flex') needRestoreModalClass = true;
    }
    modal.dataset.restoreMisc = '0';
  }
  if (modal.dataset.restoreMiscMore === '1') {
    const miscMore = document.getElementById('miscMoreModal');
    if (miscMore) {
      miscMore.removeAttribute('inert');
      miscMore.style.pointerEvents = '';
      if (miscMore.style.display === 'flex') needRestoreModalClass = true;
    }
    modal.dataset.restoreMiscMore = '0';
  }
  if (modal.dataset.restoreScanner === '1') {
    const scanner = document.getElementById('adbScannerModal');
    if (scanner) {
      scanner.removeAttribute('inert');
      scanner.style.pointerEvents = '';
      if (scanner.style.display === 'flex') needRestoreModalClass = true;
    }
    modal.dataset.restoreScanner = '0';
  }

  if (needRestoreModalClass) {
    document.body.classList.add('modal-open');
  }

  if (lastFocusedElementManualConnect && document.body.contains(lastFocusedElementManualConnect)) {
    setTimeout(() => lastFocusedElementManualConnect?.focus({ preventScroll: true }), 50);
  }
  lastFocusedElementManualConnect = null;
}

function submitAdbManualConnect() {
  const hostInput = document.getElementById('adbManualHostInput');
  const portInput = document.getElementById('adbManualPortInput');
  const host = hostInput?.value?.trim();
  if (!host) {
    showToast({ message: 'Введите IP адрес устройства', type: 'warning' });
    hostInput?.focus({ preventScroll: true });
    return;
  }
  let port = parseInt(portInput?.value, 10);
  if (!Number.isFinite(port) || port <= 0) port = 5555;
  port = Math.min(65535, Math.max(1, port));
  if (portInput) portInput.value = String(port);

  ignoreNextEnter = true;
  const modal = document.getElementById('adbManualConnectModal');
  const shouldReturnToFast = modal?.dataset?.restoreScanner === '1';
  closeAdbManualConnectModal();

  const ai = window.AndroidInterface;
  if (ai && typeof ai.connectAdbToHost === 'function') {
    ai.connectAdbToHost(host, port);
  } else if (ai && typeof ai.connectAdbTo === 'function') {
    ai.connectAdbTo(`${host}:${port}`);
  } else if (ai && typeof ai.connectAdb === 'function') {
    ai.connectAdb(`${host}:${port}`);
  } else {
    showToast({ message: 'Функция подключения ADB недоступна', type: 'error' });
  }
  if (shouldReturnToFast) {
    closeAdbScanner();
    setTimeout(() => {
      if (document.getElementById('miscModal')?.style.display !== 'flex') {
        openMiscModal();
      }
    }, 200);
  }
}

// Вспомогательная функция для скролла в сканере ADB
function focusAndRevealAdbCard(el, margin = 12) {
  if (!el) return;
  const container = document.getElementById('adbScanListContainer');
  if (!container) return;
  const cr = container.getBoundingClientRect();
  const er = el.getBoundingClientRect();
  if (er.top < cr.top + margin) container.scrollTop -= (cr.top + margin - er.top);
  else if (er.bottom > cr.bottom - margin) container.scrollTop += (er.bottom - (cr.bottom - margin));
  requestAnimationFrame(() => el.focus({ preventScroll: true }));
}

function focusLastAdbConnectionButton(scrollToTop = false) {
  const btn = document.getElementById('lastAdbConnectionBtn');
  const wrap = document.getElementById('lastAdbConnectionWrapper');
  if (!btn || !wrap || wrap.style.display === 'none') return false;
  if (scrollToTop) {
    const container = document.getElementById('adbScanListContainer');
    if (container) container.scrollTop = 0;
    const content = document.querySelector('#adbScannerModal .modal-content');
    if (content) content.scrollTop = 0;
  }
  document.querySelectorAll('#adbScanList .adb-device-card.selected').forEach(c => c.classList.remove('selected'));
  requestAnimationFrame(() => btn.focus({ preventScroll: true }));
  return true;
}

// Навигация в модалке сканера ADB
    function selectCard(card) {
      document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      currentGroup = card.dataset.group;
      const s = document.getElementById('status'); s.innerHTML = ""; s.classList.remove('visible');
    }

    function disablePackages(packages) {
      const list = Array.isArray(packages)
        ? packages
        : String(packages || "")
            .split(',')
            .map(p => p.trim())
            .filter(Boolean);

      if (!list.length) return;

      const actionLabel = 'Откл/вкл системные приложения';
      const ai = getAdbInterfaceOrWarn(actionLabel);
      if (!ai) return;
      if (!ensureAdbSessionConnected(actionLabel)) return;

      const key = list.join('|').toLowerCase();
      const nextDisable = !(disablePackageStates.get(key) ?? false);
      disablePackageStates.set(key, nextDisable);

      const payload = { packages: list, disable: nextDisable };

      try {
        if (typeof ai.disablePackage === 'function') {
          ai.disablePackage(JSON.stringify(payload));
          return;
        }
      } catch (e) {
        console.warn('disablePackages error', e);
      }

      try {
        window.AndroidInterface?.disablePackage(JSON.stringify(payload));
      } catch (err) {
        console.warn('disablePackages fallback error', err);
        showToast({ message: 'Не удалось отправить команды ADB', type: 'error' });
      }
    }

    function handleConfirmWipeThirdPartyApps() {
      const actionLabel = 'Удаление всех приложений';
      const ai = getAdbInterfaceOrWarn(actionLabel);
      if (!ai) return;
      if (!ensureAdbSessionConnected(actionLabel)) return;
      if (typeof ai.confirmWipeThirdPartyApps !== 'function') {
        showToast({ message: 'Функция недоступна в этом режиме', type: 'error' });
        return;
      }
      try {
        ai.confirmWipeThirdPartyApps();
      } catch (err) {
        console.warn('confirmWipeThirdPartyApps error', err);
        showToast({ message: 'Не удалось выполнить удаление', type: 'error' });
      }
    }

    function handleOpenApkFilePicker() {
      ignoreNextEnter = true;

      const method = window.AndroidInterface?.getInstallMethod?.() || 'sai';
      if (method === 'adb' && !isAdbSessionConnected()) {
        showToast({
          message: 'Выбран способ «ADB», но подключение отсутствует. Подключите ADB или переключите установку на «Быстрая» либо «Стандартная».',
          type: 'warning'
        });
        return;
      }

      try {
        window.AndroidInterface?.openApkFilePicker();
      } catch (err) {
        console.warn('openApkFilePicker error', err);
        showToast({ message: 'Не удалось открыть выбор APK', type: 'error' });
      }
    }

    function formatBytesAsStorage(valueMb) {
      if (!Number.isFinite(valueMb) || valueMb < 0) return 'n/a';
      if (valueMb < 1024) {
        return `${Math.round(valueMb)} MB`;
      }
      return `${(valueMb / 1024).toFixed(2)} GB`;
    }

    function showDeviceStats() {
      ignoreNextEnter = true;
      const ai = window.AndroidInterface;
      const adbConnected = isAdbSessionConnected();
      if (!ai) {
        showToast({ message: '❌ Функция недоступна', type: 'error' });
        return;
      }
      try {
        if (adbConnected && typeof ai.showCpuRamToastAdb === 'function') {
          ai.showCpuRamToastAdb();
        } else if (typeof ai.showCpuRamToast === 'function') {
          ai.showCpuRamToast();
        } else {
          showToast({ message: '❌ Функция недоступна', type: 'error' });
        }
      } catch (err) {
        console.warn('showDeviceStats error', err);
        showToast({ message: '❌ Ошибка запуска', type: 'error' });
      }
    }
    function installFastInstaller() {
      ignoreNextEnter = true;
      if (!isAdbSessionConnected()) {
        showToast({ message: '❌ ADB не подключен', type: 'error' });
        return;
      }
      const ai = window.AndroidInterface;
      if (!ai || typeof ai.installSelfApkViaAdb !== 'function') {
        showToast({ message: '❌ Функция недоступна', type: 'error' });
        return;
      }
      try {
        ai.installSelfApkViaAdb();
      } catch (err) {
        console.warn('installSelfApkViaAdb error', err);
        showToast({ message: '❌ Ошибка запуска установки', type: 'error' });
      }
    }

    function createAdbCommandIconNode(iconValue, label) {
      const wrapper = document.createElement('div');
      wrapper.className = 'adb-command-btn__icon';

      if (iconValue && /^(https?:)?\/\//i.test(iconValue)) {
        const img = document.createElement('img');
        img.src = iconValue;
        img.alt = '';
        wrapper.appendChild(img);
        return wrapper;
      }

      const text = (iconValue || label || '?').replace(/^gmd_/, '').trim();
      wrapper.textContent = text.length ? text[0].toUpperCase() : 'A';
      return wrapper;
    }

    function renderAdbCommandsList() {
      const list = document.getElementById('adbCommandsList');
      if (!list) return;
      list.innerHTML = '';

      const commands = ADB_COMMANDS.filter(item => item && item.isEnabled !== false);
      if (!commands.length) {
        const placeholder = document.createElement('div');
        placeholder.id = 'adbCommandsEmpty';
        placeholder.textContent = 'Команды недоступны. Обновите конфиг в index.html';
        list.appendChild(placeholder);
        return;
      }

      commands.forEach((item, index) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'adb-command-btn';
        btn.setAttribute('tabindex', '0');
        btn.dataset.index = String(index);

        const iconNode = createAdbCommandIconNode(item.icon, item.label);
        const textWrap = document.createElement('div');
        textWrap.className = 'adb-command-btn__text';

        const title = document.createElement('div');
        title.className = 'adb-command-btn__label';
        title.textContent = item.label || `Команда #${index + 1}`;

        const body = document.createElement('div');
        body.className = 'adb-command-btn__command';
        body.textContent = item.description || item.command || '';

        textWrap.append(title, body);
        btn.append(iconNode, textWrap);

        const exec = () => {
          sendAdbCommand(item.command, item.label);
          if ([1001, 1002, 1003, 1004, 1005, 1006, 1007].includes(item.id)) {
            setTimeout(() => {
              resetAdbConnectionState();
            }, 300);
          }
        };
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          exec();
        });
        btn.addEventListener('keydown', (event) => {
          if (['Enter', 'OK', 'NumpadEnter', ' '].includes(event.key)) {
            event.preventDefault();
            exec();
          }
        });
        btn.addEventListener('focus', () => {
          document.querySelectorAll('#adbCommandsList .adb-command-btn').forEach(el => el.classList.remove('selected'));
          btn.classList.add('selected');
        });

        list.appendChild(btn);
      });
    }

    function focusAndRevealAdbCommand(el, margin = 12) {
      if (!el) return;
      const container = document.getElementById('adbCommandsListContainer');
      if (!container) return;
      const cr = container.getBoundingClientRect();
      const er = el.getBoundingClientRect();
      if (er.top < cr.top + margin) {
        container.scrollTop -= (cr.top + margin - er.top);
      } else if (er.bottom > cr.bottom - margin) {
        container.scrollTop += (er.bottom - (cr.bottom - margin));
      }
      requestAnimationFrame(() => el.focus({ preventScroll: true }));
    }

    function buildAdbCommandsHeader(triggerBtn) {
      const header = document.getElementById('adbCommandsHeader');
      if (!header) return;
      header.innerHTML = '';
      const source = triggerBtn?.closest?.('button, .sys-btn, .card') || triggerBtn || null;

      const icon = source?.querySelector?.('img');
      if (icon) {
        const iconClone = icon.cloneNode(true);
        iconClone.style.height = '26px';
        iconClone.style.width = '26px';
        iconClone.style.objectFit = 'contain';
        header.appendChild(iconClone);
      } else {
        const fallbackIcon = document.createElement('img');
        fallbackIcon.src = 'https://appassets.androidplatform.net/assets/webview/icons/misc/ic4_developer.png';
        fallbackIcon.alt = '';
        fallbackIcon.style.height = '26px';
        fallbackIcon.style.width = '26px';
        fallbackIcon.style.objectFit = 'contain';
        header.appendChild(fallbackIcon);
      }

      const title = document.createElement('span');
      title.textContent = source?.innerText?.trim() || 'ADB команды';
      header.appendChild(title);
    }

    // Сброс выделения команд, если фокус ушёл из списка (например, на иконки в шапке)
    function bindAdbCommandsFocusReset() {
      const modal = document.getElementById('adbCommandsModal');
      if (!modal || modal.dataset.focusResetBound) return;
      modal.dataset.focusResetBound = '1';
      modal.addEventListener('focusin', (e) => {
        const list = document.getElementById('adbCommandsList');
        if (!list) return;
        if (!list.contains(e.target)) {
          document.querySelectorAll('#adbCommandsList .adb-command-btn.selected')
            .forEach(el => el.classList.remove('selected'));
        }
      });
    }

    function openAdbCommandsModal(triggerBtn = null) {
      saveMainScroll();
      bindAdbCommandsFocusReset();
      const modal = document.getElementById('adbCommandsModal');
      if (!modal) return;

      const miscModal = document.getElementById('miscModal');
      const miscMoreModal = document.getElementById('miscMoreModal');
      modal.dataset.restoreMisc = '0';
      modal.dataset.restoreMiscMore = '0';

      if (miscModal && miscModal.style.display === 'flex') {
        miscModal.setAttribute('inert', '');
        miscModal.style.pointerEvents = 'none';
        modal.dataset.restoreMisc = '1';
      }
      if (miscMoreModal && miscMoreModal.style.display === 'flex') {
        miscMoreModal.setAttribute('inert', '');
        miscMoreModal.style.pointerEvents = 'none';
        modal.dataset.restoreMiscMore = '1';
      }

      const originBtn = triggerBtn || lastAdbCommandsTriggerButton || document.activeElement;
      lastFocusedElementAdbCommands = originBtn || document.activeElement;
      document.activeElement?.blur();

      buildAdbCommandsHeader(originBtn);

      renderAdbCommandsList();
      const closeBtn = document.getElementById('adbCommandsCloseBtn');
      if (closeBtn && !closeBtn.dataset.focusBound) {
        closeBtn.dataset.focusBound = '1';
        closeBtn.addEventListener('focus', () => {
          document.querySelectorAll('#adbCommandsList .adb-command-btn.selected')
            .forEach(btn => btn.classList.remove('selected'));
        });
      }
      modal.style.display = 'flex';
      bringModalToFront(modal);
      document.body.classList.add('modal-open');

      const list = document.getElementById('adbCommandsList');
      setTimeout(() => {
        const first = list?.querySelector('.adb-command-btn');
        if (first) {
          focusAndRevealAdbCommand(first);
        } else {
          document.getElementById('adbCommandsCloseBtn')?.focus({ preventScroll: true });
        }
      }, 100);
    }

    function closeAdbCommandsModal() {
      const modal = document.getElementById('adbCommandsModal');
      if (!modal) return;

      modal.style.display = 'none';
      modal.style.zIndex = '';
      document.body.classList.remove('modal-open');
      document.querySelectorAll('#adbCommandsList .adb-command-btn.selected').forEach(btn => btn.classList.remove('selected'));

      let needRestoreModalClass = false;
      if (modal.dataset.restoreMisc === '1') {
        const misc = document.getElementById('miscModal');
        if (misc) {
          misc.removeAttribute('inert');
          misc.style.pointerEvents = '';
          if (misc.style.display === 'flex') needRestoreModalClass = true;
        }
        modal.dataset.restoreMisc = '0';
      }
      if (modal.dataset.restoreMiscMore === '1') {
        const miscMore = document.getElementById('miscMoreModal');
        if (miscMore) {
          miscMore.removeAttribute('inert');
          miscMore.style.pointerEvents = '';
          if (miscMore.style.display === 'flex') needRestoreModalClass = true;
        }
        modal.dataset.restoreMiscMore = '0';
      }
      if (!needRestoreModalClass && anyModalOpen()) {
        needRestoreModalClass = true;
      }
      if (needRestoreModalClass) {
        document.body.classList.add('modal-open');
      }

      const target = lastFocusedElementAdbCommands;
      lastFocusedElementAdbCommands = null;
      if (target && document.body.contains(target)) {
        setTimeout(() => target.focus({ preventScroll: true }), 60);
      }
      lastAdbCommandsTriggerButton = null;
      restoreMainScroll();
      restoreGroupModalOverlay();
    }

    function sendAdbCommand(command, label, options = {}) {
      const trimmed = (command || '').trim();
      if (!trimmed) {
        showToast({ message: 'Команда не задана', type: 'warning' });
        return;
      }
      const ai = window.AndroidInterface;
      if (!ai || (typeof ai.runAdbShellCommand !== 'function' && typeof ai.runAdbShellCommandWithResult !== 'function')) {
        showToast({ message: 'ADB недоступен в этом режиме', type: 'error' });
        return;
      }
      const singleToast = !!(options && options.singleToast);
      try {
        if (singleToast && typeof ai.runAdbShellCommandWithResult === 'function') {
          const ok = !!ai.runAdbShellCommandWithResult(trimmed, label || '', true);
          showToast({
            message: ok ? `✅ ${(label || trimmed)} выполнено` : `❌ ${(label || trimmed)}: ошибка выполнения`,
            type: ok ? 'success' : 'error'
          });
          return;
        }
        if (typeof ai.runAdbShellCommand === 'function') {
          ai.runAdbShellCommand(trimmed, label || '');
          return;
        }
        ai.runAdbShellCommandWithResult(trimmed, label || '', false);
      } catch (err) {
        console.error('ADB command error', err);
        showToast({ message: 'Не удалось отправить команду', type: 'error' });
      }
    }

    function applyBatteryOptimizationWhitelist() {
      return runAdbBatch({
        items: BATTERY_WHITELIST_PACKAGES,
        perItemStatus: (pkg) => {
          showStatus(
            `⚡ ${pkg}: добавление в исключения <span class="spin"><img src="https://appassets.androidplatform.net/assets/webview/icons/title/ic_load_round.png" style="height:29px; vertical-align:middle;"></span>`,
            "#00cfff",
            2500
          );
        },
        buildCommands: (pkg) => ([
          { command: `dumpsys deviceidle whitelist +${pkg}`, label: `Whitelist ${pkg}` },
          { command: `appops set ${pkg} RUN_ANY_IN_BACKGROUND allow`, label: `Run in background ${pkg}` }
        ]),
        doneStatusMessage: 'Приложения добавлены в исключения энергосбережения'
      });
    }

    function getAdbInterfaceOrWarn(actionLabel) {
      const ai = window.AndroidInterface;
      if (!ai || typeof ai.runAdbShellCommand !== 'function') {
        const message = actionLabel
          ? `ADB недоступен: ${actionLabel}`
          : 'ADB недоступен в этом режиме';
        showToast({ message, type: 'error' });
        return null;
      }
      return ai;
    }

    function isAdbSessionConnected() {
      try {
        const raw = window.AndroidInterface?.getAdbConnectionInfo?.();
        if (!raw || raw === 'undefined') return false;
        const info = typeof raw === 'string' ? JSON.parse(raw) : raw;
        return !!info?.connected;
      } catch (err) {
        console.warn('isAdbSessionConnected parse error', err);
        return false;
      }
    }

    function ensureAdbSessionConnected(actionLabel) {
      if (isAdbSessionConnected()) return true;
      const message = actionLabel
        ? `ADB не подключен: ${actionLabel}`
        : 'ADB не подключен';
      showToast({ message, type: 'error' });
      return false;
    }

    function getUserPackages() {
      try {
        const api = window.AndroidInterface;
        if (!api || typeof api.getUserInstalledPackages !== 'function') return [];
        const raw = api.getUserInstalledPackages();
        if (!raw || raw === 'undefined') return [];
        const data = typeof raw === 'string' ? JSON.parse(raw) : raw;
        if (!Array.isArray(data)) return [];
        return data
          .map((pkg) => (typeof pkg === 'string' ? pkg.trim() : ''))
          .filter((pkg) => pkg.length > 0);
      } catch (err) {
        console.warn('getUserPackages error', err);
        showToast({ message: 'Не удалось получить список приложений', type: 'error' });
        return [];
      }
    }

    const MODAL_ADB_HEADER_IDS = [
      'miscHeader',
      'miscMoreHeader',
      'adbScannerHeader',
      'adbManualHeader',
      'adbCommandsHeader',
      'screenSaverHeader',
      'modalGroupHeader',
      'atvAppsHeader'
    ];
    const MODAL_ADB_HEADER_SELECTOR = MODAL_ADB_HEADER_IDS.map((id) => `#${id}`).join(', ');

    function createModalAdbIndicator() {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'modal-adb-indicator disconnected';
      const img = document.createElement('img');
      img.src = ADB_ICON_DISCONNECTED;
      img.alt = 'ADB статус';
      img.loading = 'lazy';
      btn.appendChild(img);
      btn.setAttribute('aria-label', 'ADB не подключен');
      btn.title = 'ADB не подключен';
      btn.addEventListener('click', reconnectLastAdbFromChip);
      return btn;
    }

    function createModalQuickActionButton(action) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'modal-quick-action';
      btn.style.width = '36px';
      btn.style.height = '36px';
      btn.style.padding = '4px';
      btn.style.border = '2px solid transparent';
      btn.style.borderRadius = '50%';
      btn.style.background = 'transparent';
      btn.style.display = 'inline-flex';
      btn.style.alignItems = 'center';
      btn.style.justifyContent = 'center';
      btn.style.transition = 'border-color .2s ease, box-shadow .2s ease, background-color .2s ease';
      btn.dataset.action = action.key;
      btn.title = action.label;
      btn.setAttribute('aria-label', action.label);

      const img = document.createElement('img');
      img.src = action.icon;
      img.alt = action.label;
      img.loading = 'lazy';
      btn.appendChild(img);

      btn.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        lowerGroupModalForOverlay();
        try {
          action.run?.(btn, event);
        } catch (err) {
          console.warn(`modal quick action ${action.key} failed`, err);
        }
      });

      // focus/hover стили (дополнительно к CSS, чтобы работало для динамики)
      btn.addEventListener('focus', () => {
        btn.style.borderColor = '#fff';
        btn.style.boxShadow = '0 0 0 2px rgba(255,255,255,0.25)';
        btn.style.background = 'rgba(255,255,255,0.08)';
      });
      btn.addEventListener('blur', () => {
        btn.style.borderColor = 'transparent';
        btn.style.boxShadow = 'none';
        btn.style.background = 'transparent';
      });
      btn.addEventListener('mouseenter', () => {
        btn.style.borderColor = '#fff';
        btn.style.boxShadow = '0 0 0 2px rgba(255,255,255,0.25)';
        btn.style.background = 'rgba(255,255,255,0.08)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.borderColor = 'transparent';
        btn.style.boxShadow = 'none';
        btn.style.background = 'transparent';
      });

      return btn;
    }

    function ensureModalQuickActions(container, content, indicator) {
      const modalEl = content?.closest?.('.modal');
      const isAtv = modalEl && modalEl.id === 'atvAppsModal';

      if (modalEl && modalEl.id === 'adbScannerModal') {
        container.querySelectorAll('.modal-quick-action').forEach((btn) => btn.remove());
        return;
      }

      const skipKeys = new Set();
      if (content?.querySelector?.('#adbCommandsHeader')) {
        skipKeys.add('modal-action-adb-commands');
      }
      if (content?.querySelector?.('#screenSaverHeader')) {
        skipKeys.add('modal-action-screen-saver');
      }

      const allowedActions = isAtv
        ? [modalActionAtvRefresh]
        : MODAL_HEADER_ACTIONS.filter((action) => !skipKeys.has(action.key) && action.key !== 'modal-action-atv-refresh');
      const allowedKeys = new Set(allowedActions.map((action) => action.key));

      container.querySelectorAll('.modal-quick-action').forEach((btn) => {
        const key = btn.dataset.action;
        if (!allowedKeys.has(key)) {
          btn.remove();
        }
      });

      const insertBeforeNode = indicator && indicator.parentElement === container ? indicator : null;
      allowedActions.forEach((action) => {
        if (!action) return;
        let btn = container.querySelector(`.modal-quick-action[data-action="${action.key}"]`);
        if (!btn) {
          btn = createModalQuickActionButton(action);
        }
        if (insertBeforeNode) {
          container.insertBefore(btn, insertBeforeNode);
        } else if (!btn.parentElement) {
          container.appendChild(btn);
        }
      });

      // Обеспечиваем порядок согласно allowedActions
      allowedActions.forEach((action) => {
        if (!action) return;
        const btn = container.querySelector(`.modal-quick-action[data-action="${action.key}"]`);
        if (!btn || !indicator) return;
        const currentOrder = Array.from(container.children);
        const targetIndex = currentOrder.indexOf(indicator);
        const btnIndex = currentOrder.indexOf(btn);
        if (btnIndex > targetIndex || btn.nextSibling !== indicator) {
          container.insertBefore(btn, indicator);
        }
      });
    }

    function bringModalToFront(modal) {
      if (!modal) return;
      modalOverlayCounter += MODAL_Z_STEP;
      modal.style.zIndex = String(modalOverlayCounter);
    }

    function lowerGroupModalForOverlay() {
      const groupModal = document.getElementById('modal');
      if (!groupModal) return;
      if (groupModal.style.display !== 'flex') return;
      if (groupModal.dataset.overlaySuppressed === '1') return;
      groupModal.dataset.overlaySuppressed = '1';
      groupModal.style.zIndex = '900';
    }

    function restoreGroupModalOverlay() {
      const groupModal = document.getElementById('modal');
      if (!groupModal) return;
      if (groupModal.dataset.overlaySuppressed !== '1') return;
      delete groupModal.dataset.overlaySuppressed;
      groupModal.style.zIndex = '';
    }

    function ensureModalAdbIndicators() {
      const headerSelector = MODAL_ADB_HEADER_SELECTOR;
      document.querySelectorAll('.modal .modal-content').forEach((content) => {
        const modalEl = content.closest('.modal');
        const isAtvModal = modalEl && modalEl.id === 'atvAppsModal';
        const hasHeader = headerSelector ? content.querySelector(headerSelector) : false;
        if (!hasHeader) {
          const tools = content.querySelector('.modal-header-tools');
          if (tools) {
            tools.remove();
          }
          const strayIndicator = content.querySelector('.modal-adb-indicator');
          if (strayIndicator && strayIndicator.parentElement === content) {
            strayIndicator.remove();
          }
          return;
        }

        let tools = content.querySelector('.modal-header-tools');
        if (!tools) {
          tools = document.createElement('div');
          tools.className = 'modal-header-tools';
          content.appendChild(tools);
        } else if (!tools.classList.contains('modal-header-tools')) {
          tools.className = 'modal-header-tools';
        }

        if (isAtvModal) {
          tools.querySelectorAll('.modal-adb-indicator').forEach((btn) => btn.remove());
          const strayIndicator = content.querySelector('.modal-adb-indicator');
          if (strayIndicator && strayIndicator.parentElement === content) {
            strayIndicator.remove();
          }
          ensureModalQuickActions(tools, content, null);
          return;
        }

        let indicator = tools.querySelector('.modal-adb-indicator');
        if (!indicator) {
          indicator = content.querySelector('.modal-adb-indicator') || createModalAdbIndicator();
          tools.appendChild(indicator);
        } else if (indicator.parentElement !== tools) {
          tools.appendChild(indicator);
        }

        ensureModalQuickActions(tools, content, indicator);
      });
    }

    function ensureModalHeaderStructure(header) {
      if (!header) return null;
      header.classList.add('modal-header');
      let titleWrap = header.querySelector('.modal-header-title');
      if (!titleWrap) {
        titleWrap = document.createElement('span');
        titleWrap.className = 'modal-header-title';
        while (header.firstChild) {
          titleWrap.appendChild(header.firstChild);
        }
        header.appendChild(titleWrap);
      }
      return titleWrap;
    }

    function setModalHeaderTitle(headerId, builder) {
      const header = document.getElementById(headerId);
      if (!header) return null;
      const titleWrap = ensureModalHeaderStructure(header);
      if (!titleWrap) return null;
      if (typeof builder === 'function') {
        titleWrap.innerHTML = '';
        builder(titleWrap);
      }
      return titleWrap;
    }

    function initModalAdbHeaders() {
      MODAL_ADB_HEADER_IDS.forEach((id) => {
        const header = document.getElementById(id);
        if (header) {
          ensureModalHeaderStructure(header);
        }
      });
      ensureModalAdbIndicators();
      syncModalAdbIndicators();
    }

    function syncModalAdbIndicators(forceState) {
      const connected = typeof forceState === 'boolean' ? forceState : isAdbSessionConnected();
      const title = connected
        ? 'ADB подключен. Нажмите для переподключения'
        : 'ADB не подключён. Нажмите для переподключения';
      const iconSrc = connected ? ADB_ICON_CONNECTED : ADB_ICON_DISCONNECTED;
      document.querySelectorAll('.modal-adb-indicator').forEach((btn) => {
        btn.classList.toggle('connected', connected);
        btn.classList.toggle('disconnected', !connected);
        btn.setAttribute('aria-label', title);
        btn.title = title;
        const img = btn.querySelector('img');
        if (img && img.src !== iconSrc) {
          img.src = iconSrc;
        }
      });
    }

    function reconnectLastAdbFromChip(event) {
      event?.preventDefault?.();
      event?.stopPropagation?.();
      refreshLastAdbConnection();
      const btn = document.getElementById('lastAdbConnectionBtn');
      const host = btn?.dataset?.host?.trim();
      if (!host) {
        showToast({ message: 'Нет сохранённого ADB-подключения', type: 'warning' });
        return;
      }
      showToast({ message: 'Переподключаемся к последнему ADB…', type: 'blue', duration: 2500 });
      connectToLastAdb();
    }

    function runAdbBatch(options = {}) {
      ignoreNextEnter = true;
      const {
        items = [],
        buildCommands = () => [],
        startMessage = '',
        doneMessage = '',
        doneStatusMessage = '',
        emptyMessage = '',
        adbActionLabel = '',
        perItemStatus = null,
        delay = 450,
        silent = true
      } = options;

      const queue = (items || [])
        .map(item => typeof item === 'string' ? item.trim() : item)
        .filter(item => {
          if (typeof item === 'string') return item.length > 0;
          return !!item;
        });

      if (!queue.length) {
        if (emptyMessage) showToast({ message: emptyMessage, type: 'warning' });
        return Promise.resolve(false);
      }

      const ai = getAdbInterfaceOrWarn(adbActionLabel || startMessage || 'операция');
      if (!ai) return Promise.resolve(false);

      if (startMessage) {
        showToast({ message: startMessage, type: 'info', duration: 4000 });
      }

      let index = 0;

      return new Promise((resolve) => {
        const finish = () => {
          const statusText = doneStatusMessage || doneMessage;
          if (statusText) {
            showToast({ message: statusText, type: 'success' });
            showStatus(`✅ ${statusText}`, '#00cfff', 4000);
          } else if (doneMessage) {
            showToast({ message: doneMessage, type: 'success' });
          }
          resolve(true);
        };

        const tick = () => {
          if (index >= queue.length) {
            finish();
            return;
          }
          const item = queue[index++];
          const cmdsRaw = buildCommands(item) || [];
          const commands = Array.isArray(cmdsRaw) ? cmdsRaw : [cmdsRaw];
          commands.forEach(entry => {
            const command = typeof entry === 'string' ? entry : entry?.command;
            if (!command) return;
            const label = typeof entry === 'object' ? (entry.label || '') : '';
            try {
              ai.runAdbShellCommand(command, label || '', !!silent);
            } catch (err) {
              console.warn('ADB batch error', err);
              showToast({ message: `Ошибка: ${command}`, type: 'error' });
            }
          });
          if (typeof perItemStatus === 'function') {
            perItemStatus(item, index, queue.length);
          }
          setTimeout(tick, delay);
        };

        tick();
      });
    }

    function normalizeListenerComponent(entry) {
      if (!entry) return null;
      const pkg = (entry.pkg || '').trim();
      let component = (entry.service || '').trim();
      if (!pkg || !component) return null;
      if (component.startsWith('/')) {
        component = `${pkg}${component}`;
      }
      if (component.startsWith('.')) {
        component = `${pkg}${component}`;
      }
      if (!component.includes('/')) {
        component = `${pkg}/${component}`;
      }
      return component;
    }

    function applyUsageStatsAccess() {
      return runAdbBatch({
        items: USAGE_STATS_PACKAGES,
        buildCommands: (pkg) => [
          { command: `pm grant ${pkg} android.permission.PACKAGE_USAGE_STATS`, label: `Grant usage stats ${pkg}` },
          { command: `appops set ${pkg} GET_USAGE_STATS allow`, label: `AppOps usage ${pkg}` }
        ],
        perItemStatus: (pkg) => {
          showStatus(`📊 ${pkg}: обновляем доступ к истории использования`, '#00cfff', 2500);
        }
      });
    }

    function applyManageStorageAccess() {
      return runAdbBatch({
        items: MANAGE_STORAGE_PACKAGES,
        buildCommands: (pkg) => ({
          command: `appops set --uid ${pkg} MANAGE_EXTERNAL_STORAGE allow`,
          label: `Storage access ${pkg}`
        }),
        perItemStatus: (pkg) => {
          showStatus(`💾 ${pkg}: MANAGE_EXTERNAL_STORAGE`, '#00cfff', 2500);
        }
      });
    }

    function applyUnknownSourcesPermission() {
      const actionLabel = 'Разрешение установки из неизвестных источников';
      if (window.AndroidInterface?.grantUnknownSourcesPermissionsAsync) {
        if (!ensureAdbSessionConnected(actionLabel)) return Promise.resolve(false);
        try {
          window.AndroidInterface.grantUnknownSourcesPermissionsAsync();
          return Promise.resolve(true);
        } catch (err) {
          console.warn('grantUnknownSourcesPermissionsAsync failed, fallback to JS', err);
        }
      }
      if (!ensureAdbSessionConnected(actionLabel)) return Promise.resolve(false);
      const ai = getAdbInterfaceOrWarn(actionLabel);
      if (!ai || typeof ai.runAdbShellCommandWithResult !== 'function') {
        showToast({ message: 'Нет поддержки runAdbShellCommandWithResult', type: 'error' });
        return Promise.resolve(false);
      }
      const packages = getUserPackages();
      if (!packages.length) {
        showToast({ message: 'Нет пользовательских приложений для обновления', type: 'warning' });
        return Promise.resolve(false);
      }

      return new Promise((resolve) => {
        const queue = [...packages];
        let failures = 0;
        const delayMs = 180;
        const concurrency = Math.min(3, queue.length);

        const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

        const handlePackage = async (pkg) => {
          let primaryOk = false;
          try {
            primaryOk = !!ai.runAdbShellCommandWithResult(
              `appops set ${pkg} REQUEST_INSTALL_PACKAGES allow`,
              `Unknown sources ${pkg}`,
              true
            );
          } catch (err) {
            console.warn('Unknown sources primary command error', err);
          }
          if (!primaryOk) {
            let fallbackOk = false;
            try {
              fallbackOk = !!ai.runAdbShellCommandWithResult(
                `appops set --uid ${pkg} REQUEST_INSTALL_PACKAGES allow`,
                `Unknown sources UID ${pkg}`,
                true
              );
            } catch (err) {
              console.warn('Unknown sources fallback command error', err);
            }
            if (!fallbackOk) {
              failures += 1;
            }
          }
          await sleep(delayMs);
        };

        const worker = async () => {
          while (queue.length) {
            const pkg = queue.shift();
            if (!pkg) break;
            await handlePackage(pkg);
          }
        };

        showToast({ message: 'Обновляем разрешения на установку APK…', type: 'warning' });

        Promise.all(
          Array.from({ length: concurrency || 1 }, () => worker())
        ).then(() => {
          const statusText = failures
            ? `Разрешение выдано, но ${failures} пакетов сообщило об ошибке`
            : 'Выдано разрешение на установку APK из неизвестных источников';
          showToast({ message: statusText, type: failures ? 'warning' : 'success' });
          resolve(true);
        });
      });
    }

    function applyOverlayAccess() {
      return runAdbBatch({
        items: OVERLAY_PACKAGES,
        buildCommands: (pkg) => ({
          command: `appops set ${pkg} SYSTEM_ALERT_WINDOW allow`,
          label: `Overlay ${pkg}`
        }),
        perItemStatus: (pkg) => {
          showStatus(`🪟 ${pkg}: SYSTEM_ALERT_WINDOW`, '#00cfff', 2500);
        }
      });
    }

    function applyMicrophonePermission() {
      if (window.AndroidInterface?.grantMicrophonePermissionsAsync) {
        const actionLabel = 'Разрешение микрофона';
        if (!ensureAdbSessionConnected(actionLabel)) return Promise.resolve(false);
        try {
          window.AndroidInterface.grantMicrophonePermissionsAsync();
          return Promise.resolve(true);
        } catch (err) {
          console.warn('grantMicrophonePermissionsAsync failed, fallback to JS', err);
        }
      }
      if (!MICROPHONE_PERMISSION) {
        showToast({ message: 'Не задано имя разрешения микрофона', type: 'warning' });
        return Promise.resolve(false);
      }
      const actionLabel = 'Разрешение микрофона';
      if (!ensureAdbSessionConnected(actionLabel)) return Promise.resolve(false);
      const ai = getAdbInterfaceOrWarn(actionLabel);
      if (!ai || typeof ai.runAdbShellCommandWithResult !== 'function') {
        showToast({ message: 'Нет поддержки runAdbShellCommandWithResult', type: 'error' });
        return Promise.resolve(false);
      }
      const dynamicPackages = getUserPackages();
      const manualPackages = Array.isArray(MICROPHONE_PERMISSION_PACKAGES) ? MICROPHONE_PERMISSION_PACKAGES : [];
      const packages = Array.from(new Set([...manualPackages, ...dynamicPackages])).filter(Boolean);
      if (!packages.length) {
        showToast({ message: 'Нет приложений для выдачи микрофона', type: 'warning' });
        return Promise.resolve(false);
      }

      return new Promise((resolve) => {
        const queue = [...packages];
        const delayMs = 150;
        const concurrency = Math.min(3, queue.length);

        const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

        const handlePackage = async (pkg) => {
          try {
            ai.runAdbShellCommandWithResult(
              `pm grant ${pkg} ${MICROPHONE_PERMISSION}`,
              `Grant mic ${pkg}`,
              true
            );
          } catch (err) {
            console.warn('applyMicrophonePermission error', pkg, err);
          }
          await sleep(delayMs);
        };

        const worker = async () => {
          while (queue.length) {
            const pkg = queue.shift();
            if (!pkg) break;
            await handlePackage(pkg);
          }
        };

        showToast({ message: 'Выдаём разрешения микрофона…', type: 'warning' });

        Promise.all(
          Array.from({ length: concurrency || 1 }, () => worker())
        ).then(() => {
          const statusText = 'Разрешение микрофона обновлено';
          showToast({ message: statusText, type: 'success' });
          resolve(true);
        });
      });
    }

    function applyWriteSettingsAccess() {
      return runAdbBatch({
        items: WRITE_SETTINGS_PACKAGES,
        buildCommands: (pkg) => ({
          command: `appops set ${pkg} WRITE_SETTINGS allow`,
          label: `Write settings ${pkg}`
        }),
        perItemStatus: (pkg) => {
          showStatus(`⚙️ ${pkg}: WRITE_SETTINGS`, '#00cfff', 2500);
        }
      });
    }

    function applyProjectMediaAccess() {
      return runAdbBatch({
        items: PROJECT_MEDIA_PACKAGES,
        buildCommands: (pkg) => ({
          command: `appops set ${pkg} PROJECT_MEDIA allow`,
          label: `Project media ${pkg}`
        }),
        perItemStatus: (pkg) => {
          showStatus(`🎥 ${pkg}: PROJECT_MEDIA`, '#00cfff', 2500);
        }
      });
    }

    function applyExactAlarmAccess() {
      return runAdbBatch({
        items: EXACT_ALARM_PACKAGES,
        buildCommands: (pkg) => ({
          command: `appops set ${pkg} SCHEDULE_EXACT_ALARM allow`,
          label: `Exact alarm ${pkg}`
        }),
        perItemStatus: (pkg) => {
          showStatus(`⏰ ${pkg}: будильники и напоминания`, '#00cfff', 2500);
        }
      });
    }

    function applyNotificationListeners() {
      return runAdbBatch({
        items: NOTIFICATION_LISTENER_SERVICES,
    buildCommands: (entry) => {
      const component = normalizeListenerComponent(entry);
      if (!component) return [];
      return [{
        command: `cmd notification allow_listener ${component}`,
        label: `Allow listener ${component}`
      }];
    },
    perItemStatus: (entry) => {
      const pkg = entry?.pkg || entry;
      showStatus(`🔔 ${pkg}: разрешаем доступ к уведомлениям`, '#00cfff', 2500);
    }
  });
}

function applyAccessibilityServices() {
  const ai = getAdbInterfaceOrWarn('Включение сервиса специальных возможностей');
  if (!ai) return Promise.resolve(false);
  if (!Array.isArray(ACCESSIBILITY_SERVICES) || !ACCESSIBILITY_SERVICES.length) {
    showToast({ message: 'Нет служб для включения доступа', type: 'warning' });
    return Promise.resolve(false);
  }
  const joined = ACCESSIBILITY_SERVICES.join(':');
  const commands = [
    {
      command: `settings put secure enabled_accessibility_services "${joined}"`,
      label: 'Enable accessibility services'
    },
    {
      command: 'settings put secure accessibility_enabled 1',
      label: 'Accessibility toggle'
    }
  ];
  if (Array.isArray(ACCESSIBILITY_PACKAGES) && ACCESSIBILITY_PACKAGES.length) {
    ACCESSIBILITY_PACKAGES.forEach((pkg) => {
      commands.push({
        command: `appops set ${pkg} ACCESS_RESTRICTED_SETTINGS allow`,
        label: `Restricted settings ${pkg}`
      });
      commands.push({
        command: `appops set --uid ${pkg} ACCESS_RESTRICTED_SETTINGS allow`,
        label: `Restricted settings uid ${pkg}`
      });
    });
  }
  let hasError = false;
  commands.forEach(({ command, label }) => {
    try {
      ai.runAdbShellCommand(command, label, true);
    } catch (err) {
      hasError = true;
      console.warn('applyAccessibilityServices error', err);
      showToast({ message: `Ошибка: ${label || command}`, type: 'error' });
    }
  });
  if (!hasError) {
    showStatus('♿ Службы доступности включены', '#00cfff', 4000);
    showToast({ message: 'Доступ к службам доступности выдан', type: 'success' });
  }
  return Promise.resolve(!hasError);
}

    function applyDefaultKeyboardIme() {
      return new Promise((resolve) => {
        const ai = getAdbInterfaceOrWarn('Назначение клавиатуры');
        if (!ai) {
          resolve(false);
          return;
        }
        if (!DEFAULT_KEYBOARD_IME) {
          showToast({ message: 'Компонент клавиатуры не задан', type: 'warning' });
          resolve(false);
          return;
        }

        const commands = [
          { command: `ime enable ${DEFAULT_KEYBOARD_IME}`, label: 'Enable keyboard IME' },
          { command: `ime set ${DEFAULT_KEYBOARD_IME}`, label: 'Set keyboard IME' }
        ];

        const runImeCommands = () => {
          commands.forEach(({ command, label }) => {
            try {
              ai.runAdbShellCommand(command, label, true);
            } catch (err) {
              console.warn('applyDefaultKeyboardIme command error', err);
            }
          });
        };

        const isTargetImeActive = () => {
          try {
            const value = window.AndroidInterface?.getCurrentInputMethod?.();
            if (!value || value === 'undefined') return false;
            return value.trim() === DEFAULT_KEYBOARD_IME;
          } catch (err) {
            console.warn('isTargetImeActive error', err);
            return false;
          }
        };

        const ensureIme = (silent = false) => {
          if (isTargetImeActive()) {
            if (!silent) {
              showStatus('⌨️ Клавиатура LeanKey включена и назначена по умолчанию', '#00cfff', 4000);
              showToast({ message: 'Клавиатура назначена основной', type: 'success' });
            }
            return true;
          }
          runImeCommands();
          setTimeout(() => {
            if (isTargetImeActive() && !silent) {
              showStatus('⌨️ Клавиатура LeanKey включена и назначена по умолчанию', '#00cfff', 4000);
              showToast({ message: 'Клавиатура назначена основной', type: 'success' });
            }
          }, 1000);
          return false;
        };

        const finalize = () => resolve(true);

        const initialApplied = ensureIme();
        if (initialApplied) {
          finalize();
          return;
        }
        setTimeout(() => ensureIme(true), 2000);
        setTimeout(finalize, 2500);
      });
    }

    function applyScreenSaverDefaults() {
      const ai = getAdbInterfaceOrWarn('Настройка заставки');
      if (!ai) return Promise.resolve(false);
      const commands = [
        { command: 'settings put system screen_off_timeout 1800000', label: 'Screen off timeout' },
        { command: 'settings put secure sleep_timeout 28800000', label: 'Sleep timeout' }
      ];
      let hasError = false;
      commands.forEach(({ command, label }) => {
        try {
          ai.runAdbShellCommand(command, label, true);
        } catch (err) {
          hasError = true;
          console.warn('applyScreenSaverDefaults error', err);
          showToast({ message: `Ошибка: ${label || command}`, type: 'error' });
        }
      });
      const pkg = DEFAULT_SCREENSAVER_PACKAGE || DEFAULT_SCREENSAVER_COMPONENT?.split('/')?.[0];
      if (!hasError && pkg && window.AndroidInterface?.setScreenSaverPackage) {
        try {
          window.AndroidInterface.setScreenSaverPackage(pkg);
        } catch (err) {
          hasError = true;
          console.warn('setScreenSaverPackage from auto error', err);
        }
      }
      if (!hasError) {
        showStatus('🌌 Aerial Views активирована, таймеры обновлены', '#00cfff', 4000);
        showToast({ message: 'Заставка настроена', type: 'success' });
      }
      return Promise.resolve(!hasError);
    }

    const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    // === Spatial navigation helpers (геометрия вместо rows/cols) ===
    function getFocusable(scope = document) {
      return Array.from(scope.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'))
        .filter(el => !el.disabled && el.offsetParent !== null);
    }

    function center(rect) {
      return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
    }

    function findNextByDirection(currentEl, direction, scopeEl) {
      const items = getFocusable(scopeEl);
      if (!currentEl || !items.length) return null;
      const cur = center(currentEl.getBoundingClientRect());
      const isH = direction === 'left' || direction === 'right';

      const fitsDirection = (dx, dy) => {
        if (direction === 'left') return dx < -2;
        if (direction === 'right') return dx > 2;
        if (direction === 'up') return dy < -2;
        if (direction === 'down') return dy > 2;
        return false;
      };

      const slope = 1.2;
      const pad = 32;
      const bandH = 36; // держим ряд при горизонтальной навигации
      const bandV = 48; // держим колонку при вертикальной навигации

      const withinBand = (dx, dy) => {
        const adx = Math.abs(dx);
        const ady = Math.abs(dy);
        if (isH) {
          // Для горизонтали: разрешаем только текущий ряд (узкая полоса)
          return ady <= bandH;
        }
        // Для вертикали пока не ограничиваем колонку, оставляем прежний конус/фолбэк
        return true;
      };

      const withinCone = (dx, dy) => {
        const adx = Math.abs(dx);
        const ady = Math.abs(dy);
        if (isH) return ady <= adx * slope + pad;
        return adx <= ady * slope + pad;
      };

      const scoreItem = (dx, dy, penalty = 0) => {
        const primary = isH ? Math.abs(dx) : Math.abs(dy);
        const secondary = isH ? Math.abs(dy) : Math.abs(dx);
        return primary + secondary * 0.1 + penalty;
      };

      const pick = (opts) => {
        let best = null;
        let bestScore = Infinity;
        let bestIndex = -1;
        items.forEach((el, idx) => {
          if (el === currentEl) return;
          const c = center(el.getBoundingClientRect());
          const dx = c.x - cur.x;
          const dy = c.y - cur.y;
          if (!fitsDirection(dx, dy)) return;
          if (opts.band && !withinBand(dx, dy)) return;
          if (opts.cone && !withinCone(dx, dy)) return;
          const score = scoreItem(dx, dy, opts.penalty || 0);
          if (score < bestScore - 1e-6 || (Math.abs(score - bestScore) < 1e-6 && idx < bestIndex)) {
            bestScore = score;
            best = el;
            bestIndex = idx;
          }
        });
        return best;
      };

      // Приоритет 1: стараемся держать тот же ряд/колонку
      let cand = pick({ band: true });
      if (cand) return cand;
      // Приоритет 2: конус
      cand = pick({ cone: true });
      if (cand) return cand;
      // Фолбэк: любое по направлению с лёгким штрафом
      cand = pick({ cone: false, penalty: 50 });
      return cand;
    }

    function handleDpadInScope(e, scopeEl) {
      const dir = e.key === 'ArrowLeft' ? 'left'
        : e.key === 'ArrowRight' ? 'right'
          : e.key === 'ArrowUp' ? 'up'
            : e.key === 'ArrowDown' ? 'down' : null;
      if (!dir) return;
      const active = document.activeElement;
      if (!scopeEl.contains(active)) return;
      e.preventDefault();
      const next = findNextByDirection(active, dir, scopeEl);
      if (next) {
        try { next.focus({ preventScroll: true }); } catch (_) { next.focus(); }
        try { next.scrollIntoView({ block: 'nearest', inline: 'nearest' }); } catch (_) { next.scrollIntoView(); }
      }
    }

    function focusFirst(scope) {
      const first = getFocusable(scope)[0];
      if (first) {
        try { first.focus({ preventScroll: true }); } catch (_) { first.focus(); }
      }
    }

const NAVIGATION_MODALS = [
      // 'installMethodModal', // локальный хендлер, исключаем из глобального DPAD
      'launcherActionsModal',
      'launcherModal',
      'atvAppActionsModal',
      'adbManualConnectModal',
      'screenSaverTimeoutModal',
      'adbCommandsModal',
      'adbScannerModal',
      'adbRemoteModal',
      'miscMoreModal',
      'miscModal',
      'atvAppsModal',
      'screenSaverModal',
      'autostartModal',
      'modal'
    ];

    document.addEventListener('keydown', (e) => {
      // Back/Escape обрабатываются ниже отдельно
      if (e.key === 'Back' || e.key === 'Escape') return;

  // Во время загрузки списка ATV блокируем любую навигацию/действия
  const atvModal = document.getElementById('atvAppsModal');
  if (typeof isAtvInputBlocked === 'function'
      && isAtvInputBlocked()
      && atvModal?.style.display === 'flex') {
    e.preventDefault();
    return;
  }

      // Спец-правила для модалки таймаута заставки:
      // если фокус в инпуте и стрелка вниз — идём на кнопку "Применить"
      if (document.getElementById('screenSaverTimeoutModal')?.style.display === 'flex') {
        const input = document.getElementById('screenSaverTimeoutInput');
        const applyBtn = document.getElementById('screenSaverTimeoutApply');
        const cancelBtn = document.getElementById('screenSaverTimeoutCancel');
        if (document.activeElement === input && e.key === 'ArrowDown' && applyBtn) {
          e.preventDefault();
          try { applyBtn.focus({ preventScroll: true }); } catch (_) { applyBtn.focus(); }
          return;
        }
        if (document.activeElement === cancelBtn && e.key === 'ArrowLeft' && applyBtn) {
          e.preventDefault();
          try { applyBtn.focus({ preventScroll: true }); } catch (_) { applyBtn.focus(); }
          return;
        }
      }

    // Для модалки выбора способа установки работаем только локальным хендлером
    if (document.getElementById('installMethodModal')?.style.display === 'flex') {
      return;
    }

      for (const id of NAVIGATION_MODALS) {
        const m = document.getElementById(id);
        if (m && m.style.display === 'flex') {
          handleDpadInScope(e, m);
          return;
        }
      }
    }, true);

    async function runAllAutoPermissions() {
      const actionLabel = 'Авторазрешения';
      if (!getAdbInterfaceOrWarn(actionLabel)) return;
      if (!ensureAdbSessionConnected(actionLabel)) return;
      showToast({ message: 'Запуск авторазрешений…', type: 'warning' });

      try {
        await Promise.all([
          applyBatteryOptimizationWhitelist(),
          applyUsageStatsAccess(),
          applyManageStorageAccess(),
          applyOverlayAccess(),
          applyWriteSettingsAccess(),
          applyProjectMediaAccess(),
          applyExactAlarmAccess(),
          applyAccessibilityServices(),
          applyScreenSaverDefaults(),
          applyNotificationListeners()
        ]);

        await applyUnknownSourcesPermission();
        await applyMicrophonePermission();

        await wait(2500);
        await applyDefaultKeyboardIme();
        await wait(300);
      } catch (err) {
        console.warn('runAllAutoPermissions error', err);
      } finally {
        try {
          window.AndroidInterface?.onAutoPermissionsFinished?.();
        } catch (err) {
          console.warn('onAutoPermissionsFinished error', err);
        }
      }
    }


    function openAdbCommandsFromButton(triggerBtn) {
      ignoreNextEnter = true;
      lastAdbCommandsTriggerButton = triggerBtn || null;
      try {
        if (window.AndroidInterface?.openRunAdbCommandsModal) {
          window.AndroidInterface.openRunAdbCommandsModal();
          return;
        }
      } catch (err) {
        console.warn('openRunAdbCommandsModal failed, fallback to JS modal', err);
      }
      openAdbCommandsModal(triggerBtn);
    }

    let lastAdbRemoteTrigger = null;
    function openAdbRemoteModal(triggerBtn = null) {
      // TEMP: bypass ADB check for remote modal
      // if (!ensureAdbSessionConnected('Пульт ДУ')) return;
      saveMainScroll();
      lastAdbRemoteTrigger = triggerBtn || document.activeElement;
      document.activeElement?.blur();
      const modal = document.getElementById('adbRemoteModal');
      if (!modal) return;
      modal.style.display = 'flex';
      bringModalToFront(modal);
      document.body.classList.add('modal-open');
      const firstBtn = modal.querySelector('.adb-remote-btn');
      if (firstBtn) setTimeout(() => firstBtn.focus({ preventScroll: true }), 80);
    }

    function closeAdbRemoteModal() {
      const modal = document.getElementById('adbRemoteModal');
      if (!modal) return;
      modal.classList.remove('keyboard-open');
      const panel = document.getElementById('adbRemoteKeyboardPanel');
      if (panel) panel.style.display = 'none';
      var input = document.getElementById('adbRemoteKeyboardInput');
      if (input) {
        if (adbRemoteKeyboardInputListener) {
          input.removeEventListener('input', adbRemoteKeyboardInputListener);
          adbRemoteKeyboardInputListener = null;
        }
        if (adbRemoteKeyboardKeydownListener) {
          input.removeEventListener('keydown', adbRemoteKeyboardKeydownListener);
          adbRemoteKeyboardKeydownListener = null;
        }
      }
      adbRemoteKeyboardLastValue = '';
      if (adbRemoteRepeatUseNative || adbRemoteRepeatState.size) {
        stopAdbRemoteRepeat({ currentTarget: modal });
      }
      modal.style.display = 'none';
      modal.style.zIndex = '';
      document.body.classList.remove('modal-open');
      const target = lastAdbRemoteTrigger;
      lastAdbRemoteTrigger = null;
      restoreMainScroll();
      if (target && document.body.contains(target)) {
        setTimeout(() => target.focus({ preventScroll: true }), 60);
      }
      restoreGroupModalOverlay();
    }

    function sendAdbRemoteKey(keyCode, longPress = false) {
      const ai = getAdbInterfaceOrWarn('Пульт ДУ');
      if (!ai) return;
      if (!ensureAdbSessionConnected('Пульт ДУ')) return;
      if (typeof ai.sendAdbKeyEvent === 'function') {
        ai.sendAdbKeyEvent(Number(keyCode), !!longPress);
        return;
      }
      const cmd = `input keyevent ${longPress ? '--longpress ' : ''}${Number(keyCode)}`;
      if (typeof ai.runAdbShellCommand === 'function') {
        ai.runAdbShellCommand(cmd, '', true);
      }
    }

    /** Отправить на ТВ нажатие Backspace (удалить символ). */
    function sendAdbRemoteBackspace() {
      sendAdbRemoteKey(67);
    }

    /** Экранирование строки для adb shell "input text ..." (пробел→%s, %→%%, \→\%). Порядок: сначала % и \. */
    function escapeAdbInputText(str) {
      if (str == null || typeof str !== 'string') return '';
      return str
        .replace(/%/g, '%%')
        .replace(/\\/g, '\\%')
        .replace(/ /g, '%s');
    }

    /** Показать статус метода ввода в UI */
    function updateKeyboardStatus(message) {
      const status = document.getElementById('adbRemoteKeyboardStatus');
      if (status) {
        status.textContent = message;
        setTimeout(() => { if (status) status.textContent = ''; }, 3000);
      }
    }
    
    // Сделаем функцию глобальной для вызова из Kotlin
    window.updateKeyboardStatus = updateKeyboardStatus;

    /** Проверить статус поддержки Unicode на ТВ */
    function checkAdbKeyboardStatus() {
      const ai = window.AndroidInterface;
      if (!ai || typeof ai.checkAdbKeyboardSupport !== 'function') {
        updateKeyboardStatus('проверка недоступна');
        return;
      }
      updateKeyboardStatus('проверка...');
      ai.checkAdbKeyboardSupport();
    }

    /** Показать предложение установки ADBKeyboard */
    function showAdbKeyboardInstallPrompt() {
      updateKeyboardStatus('используем встроенные методы');
    }

    /** Отправить фрагмент текста на ТВ (для посимвольной отправки и кнопки «Отправить»). Предпочтительно нативный runAdbInputText — корректная кириллица. */
    function sendAdbInputTextChunk(text) {
      if (!text || typeof text !== 'string') return;
      const ai = window.AndroidInterface;
      if (!ai) return;
      if (text === ' ') {
        updateKeyboardStatus('пробел');
        if (typeof ai.sendAdbKeyEvent === 'function') ai.sendAdbKeyEvent(62, false);
        else if (typeof ai.runAdbShellCommand === 'function') ai.runAdbShellCommand('input keyevent 62', '', true);
        return;
      }
      const hasNonAscii = /[^\x00-\x7F]/.test(text);
      if (hasNonAscii) updateKeyboardStatus('Unicode...');
      if (typeof ai.runAdbInputText === 'function') {
        ai.runAdbInputText(text);
        return;
      }
      updateKeyboardStatus('fallback');
      if (typeof ai.runAdbShellCommand !== 'function') return;
      const escaped = escapeAdbInputText(text);
      const cmd = 'input text "' + escaped.replace(/"/g, '\\"') + '"';
      ai.runAdbShellCommand(cmd, '', true);
    }

    var adbRemoteKeyboardLastValue = '';
    var adbRemoteKeyboardLastSelectionStart = 0;
    var adbRemoteKeyboardRemoteCursor = 0;
    var adbRemoteKeyboardInputListener = null;
    var adbRemoteKeyboardKeydownListener = null;
    var adbRemoteKeyboardCursorListener = null;

    function syncAdbRemoteCursor(targetPos) {
      if (typeof targetPos !== 'number' || targetPos < 0) return;
      const diff = targetPos - adbRemoteKeyboardRemoteCursor;
      if (!diff) return;
      const steps = Math.min(Math.abs(diff), 60);
      const keyCode = diff > 0 ? 22 : 21;
      for (var i = 0; i < steps; i++) {
        sendAdbRemoteKey(keyCode);
      }
      adbRemoteKeyboardRemoteCursor += diff > 0 ? steps : -steps;
    }

    function toggleAdbRemoteKeyboardPanel() {
      const panel = document.getElementById('adbRemoteKeyboardPanel');
      const input = document.getElementById('adbRemoteKeyboardInput');
      if (!panel || !input) return;
      const modal = document.getElementById('adbRemoteModal');
      const isHidden = panel.style.display === 'none';
      panel.style.display = isHidden ? 'block' : 'none';
      if (modal) modal.classList.toggle('keyboard-open', isHidden);
      if (isHidden) {
        adbRemoteKeyboardLastValue = '';
        adbRemoteKeyboardLastSelectionStart = 0;
        adbRemoteKeyboardRemoteCursor = 0;
        input.value = '';
        if (adbRemoteKeyboardInputListener) {
          input.removeEventListener('input', adbRemoteKeyboardInputListener);
          adbRemoteKeyboardInputListener = null;
        }
        if (adbRemoteKeyboardKeydownListener) {
          input.removeEventListener('keydown', adbRemoteKeyboardKeydownListener);
          adbRemoteKeyboardKeydownListener = null;
        }
        if (adbRemoteKeyboardCursorListener) {
          input.removeEventListener('click', adbRemoteKeyboardCursorListener);
          input.removeEventListener('keyup', adbRemoteKeyboardCursorListener);
          input.removeEventListener('touchend', adbRemoteKeyboardCursorListener);
          input.removeEventListener('focus', adbRemoteKeyboardCursorListener);
          adbRemoteKeyboardCursorListener = null;
        }
        adbRemoteKeyboardInputListener = function (e) {
          if (e && e.isComposing) return;
          const cur = input.value;
          const ai = window.AndroidInterface;
          if (!ai || typeof ai.runAdbShellCommand !== 'function') return;
          const prevCursor = adbRemoteKeyboardLastSelectionStart;
          syncAdbRemoteCursor(prevCursor);
          if (cur.length > adbRemoteKeyboardLastValue.length) {
            var added = cur.slice(adbRemoteKeyboardLastValue.length);
            sendAdbInputTextChunk(added);
            adbRemoteKeyboardRemoteCursor += added.length;
          } else if (cur.length < adbRemoteKeyboardLastValue.length) {
            var n = adbRemoteKeyboardLastValue.length - cur.length;
            for (var i = 0; i < n; i++) {
              if (typeof ai.sendAdbKeyEvent === 'function') ai.sendAdbKeyEvent(67, false);
              else ai.runAdbShellCommand('input keyevent 67', '', true);
            }
            adbRemoteKeyboardRemoteCursor = Math.max(0, adbRemoteKeyboardRemoteCursor - n);
          }
          adbRemoteKeyboardLastValue = cur;
          adbRemoteKeyboardLastSelectionStart = typeof input.selectionStart === 'number'
            ? input.selectionStart
            : cur.length;
        };
        adbRemoteKeyboardKeydownListener = function (e) {
          if (e.key !== 'Backspace') return;
          if (input.value !== '') return;
          var ai = window.AndroidInterface;
          if (!ai || (typeof ai.sendAdbKeyEvent !== 'function' && typeof ai.runAdbShellCommand !== 'function')) return;
          e.preventDefault();
          if (typeof ai.sendAdbKeyEvent === 'function') ai.sendAdbKeyEvent(67, false);
          else ai.runAdbShellCommand('input keyevent 67', '', true);
        };
        adbRemoteKeyboardCursorListener = function () {
          const pos = typeof input.selectionStart === 'number' ? input.selectionStart : 0;
          if (pos === adbRemoteKeyboardLastSelectionStart) return;
          adbRemoteKeyboardLastSelectionStart = pos;
          syncAdbRemoteCursor(pos);
        };
        input.addEventListener('input', adbRemoteKeyboardInputListener);
        input.addEventListener('keydown', adbRemoteKeyboardKeydownListener);
        input.addEventListener('click', adbRemoteKeyboardCursorListener);
        input.addEventListener('keyup', adbRemoteKeyboardCursorListener);
        input.addEventListener('touchend', adbRemoteKeyboardCursorListener);
        input.addEventListener('focus', adbRemoteKeyboardCursorListener);
        setTimeout(function () { input.focus(); }, 100);
      } else {
        if (adbRemoteKeyboardInputListener) {
          input.removeEventListener('input', adbRemoteKeyboardInputListener);
          adbRemoteKeyboardInputListener = null;
        }
        if (adbRemoteKeyboardKeydownListener) {
          input.removeEventListener('keydown', adbRemoteKeyboardKeydownListener);
          adbRemoteKeyboardKeydownListener = null;
        }
        if (adbRemoteKeyboardCursorListener) {
          input.removeEventListener('click', adbRemoteKeyboardCursorListener);
          input.removeEventListener('keyup', adbRemoteKeyboardCursorListener);
          input.removeEventListener('touchend', adbRemoteKeyboardCursorListener);
          input.removeEventListener('focus', adbRemoteKeyboardCursorListener);
          adbRemoteKeyboardCursorListener = null;
        }
        adbRemoteKeyboardLastValue = '';
        adbRemoteKeyboardLastSelectionStart = 0;
        adbRemoteKeyboardRemoteCursor = 0;
        input.blur();
      }
    }

    function sendAdbInputTextToDevice() {
      const ai = getAdbInterfaceOrWarn('Пульт ДУ');
      if (!ai) return;
      const input = document.getElementById('adbRemoteKeyboardInput');
      const raw = input ? input.value : '';
      const text = raw;
      if (!text || text.length === 0) {
        if (typeof showToast === 'function') showToast({ message: 'Введите текст', type: 'warning' });
        return;
      }
      if (typeof ai.runAdbInputText === 'function') {
        ai.runAdbInputText(text);
      } else if (typeof ai.runAdbShellCommand === 'function') {
        const escaped = escapeAdbInputText(text);
        const cmd = 'input text "' + escaped.replace(/"/g, '\\"') + '"';
        ai.runAdbShellCommand(cmd, 'Ввод текста', true);
      }
      if (typeof showToast === 'function') showToast({ message: 'Текст отправлен на ТВ', type: 'success' });
      if (input) {
        input.value = '';
        adbRemoteKeyboardLastValue = '';
      }
    }

    function pasteFromPhoneAndSendToDevice() {
      const ai = getAdbInterfaceOrWarn('Пульт ДУ');
      if (!ai) return;
      function tryNativeClipboard() {
        if (typeof window.AndroidInterface !== 'undefined' && typeof window.AndroidInterface.getClipboardText === 'function') {
          try {
            return window.AndroidInterface.getClipboardText() || '';
          } catch (e) { return ''; }
        }
        return '';
      }
      function doSend(text) {
        const t = (text || '');
        if (!t || t.length === 0) {
          if (typeof showToast === 'function') showToast({ message: 'В буфере нет текста', type: 'warning' });
          return;
        }
        if (typeof ai.runAdbInputText === 'function') {
          ai.runAdbInputText(t);
        } else if (typeof ai.runAdbShellCommand === 'function') {
          const escaped = escapeAdbInputText(t);
          const cmd = 'input text "' + escaped.replace(/"/g, '\\"') + '"';
          ai.runAdbShellCommand(cmd, 'Вставка с телефона', true);
        } else {
          if (typeof showToast === 'function') showToast({ message: 'ADB интерфейс недоступен', type: 'error' });
          return;
        }
        if (typeof showToast === 'function') showToast({ message: 'Текст с телефона отправлен на ТВ', type: 'success' });
      }
      const nativeText = tryNativeClipboard();
      if (nativeText !== '') {
        doSend(nativeText);
        return;
      }
      if (typeof navigator !== 'undefined' && navigator.clipboard && typeof navigator.clipboard.readText === 'function') {
        navigator.clipboard.readText().then(function (text) {
          doSend(text || '');
        }).catch(function () {
          if (typeof showToast === 'function') showToast({ message: 'Нет доступа к буферу обмена', type: 'error' });
        });
        return;
      }
      if (typeof showToast === 'function') showToast({ message: 'Буфер обмена недоступен', type: 'warning' });
    }

    const adbRemoteDpadState = {
      keyCode: null,
      timeoutId: null,
      intervalId: null,
      useNative: false
    };

    function getDpadKeyFromEvent(event) {
      const dpad = event.currentTarget;
      if (!dpad) return null;
      const rect = dpad.getBoundingClientRect();
      const x = event.clientX - (rect.left + rect.width / 2);
      const y = event.clientY - (rect.top + rect.height / 2);
      const deadZone = rect.width * 0.12;
      if (Math.abs(x) < deadZone && Math.abs(y) < deadZone) return null;
      if (Math.abs(x) >= Math.abs(y)) return x > 0 ? 22 : 21;
      return y > 0 ? 20 : 19;
    }

    function getDpadDirectionFromEvent(event) {
      const dpad = event.currentTarget;
      if (!dpad) return null;
      const rect = dpad.getBoundingClientRect();
      const x = event.clientX - (rect.left + rect.width / 2);
      const y = event.clientY - (rect.top + rect.height / 2);
      const deadZone = rect.width * 0.12;
      if (Math.abs(x) < deadZone && Math.abs(y) < deadZone) return null;
      if (Math.abs(x) >= Math.abs(y)) return x > 0 ? 'right' : 'left';
      return y > 0 ? 'down' : 'up';
    }

    function startAdbDpad(event) {
      event.preventDefault();
      event.stopPropagation();
      const keyCode = getDpadKeyFromEvent(event);
      if (!keyCode) return;
      const dir = getDpadDirectionFromEvent(event);
      if (dir) event.currentTarget.dataset.dir = dir;
      startDpadRepeat(keyCode);
    }

    function moveAdbDpad(event) {
      if (adbRemoteDpadState.keyCode == null) return;
      const keyCode = getDpadKeyFromEvent(event);
      if (!keyCode || keyCode === adbRemoteDpadState.keyCode) return;
      const dir = getDpadDirectionFromEvent(event);
      if (dir) event.currentTarget.dataset.dir = dir;
      stopDpadRepeat();
      startDpadRepeat(keyCode);
    }

    function stopAdbDpad(event) {
      event?.preventDefault?.();
      event?.stopPropagation?.();
      const dpad = event?.currentTarget;
      if (dpad) delete dpad.dataset.dir;
      stopDpadRepeat();
    }

    let okHoldTimer = null;
    let okHoldFired = false;
    let okHoldActive = false;
    function startOkHold(event) {
      event.preventDefault();
      event.stopPropagation();
      okHoldActive = true;
      okHoldFired = false;
      clearTimeout(okHoldTimer);
      okHoldTimer = setTimeout(() => {
        okHoldFired = true;
        sendAdbRemoteKey(23, true);
      }, 500);
    }

    function stopOkHold(event) {
      event?.preventDefault?.();
      event?.stopPropagation?.();
      if (!okHoldActive) return;
      okHoldActive = false;
      clearTimeout(okHoldTimer);
      if (!okHoldFired) {
        sendAdbRemoteKey(23, false);
      }
      okHoldFired = false;
    }

    let pwrHoldTimer = null;
    let pwrHoldFired = false;
    let pwrHoldActive = false;
    function startPwrHold(event) {
      event.preventDefault();
      event.stopPropagation();
      pwrHoldActive = true;
      pwrHoldFired = false;
      clearTimeout(pwrHoldTimer);
      pwrHoldTimer = setTimeout(() => {
        pwrHoldFired = true;
        sendAdbRemoteKey(26, true);
      }, 450);
    }

    function stopPwrHold(event) {
      event?.preventDefault?.();
      event?.stopPropagation?.();
      if (!pwrHoldActive) return;
      pwrHoldActive = false;
      clearTimeout(pwrHoldTimer);
      if (!pwrHoldFired) {
        sendAdbRemoteKey(26, false);
      }
      pwrHoldFired = false;
    }

    function startDpadRepeat(keyCode) {
      const ai = getAdbInterfaceOrWarn('Пульт ДУ');
      if (!ai) return;
      if (!ensureAdbSessionConnected('Пульт ДУ')) return;
      adbRemoteDpadState.keyCode = keyCode;
      if (typeof ai.startAdbKeyRepeat === 'function') {
        adbRemoteDpadState.useNative = true;
        ai.startAdbKeyRepeat(keyCode, 180, 85);
        return;
      }
      sendAdbRemoteKey(keyCode);
      const initialDelay = 150;
      const intervalMs = 70;
      adbRemoteDpadState.timeoutId = setTimeout(() => {
        adbRemoteDpadState.intervalId = setInterval(() => sendAdbRemoteKey(keyCode), intervalMs);
      }, initialDelay);
    }

    function stopDpadRepeat() {
      const ai = window.AndroidInterface;
      if (adbRemoteDpadState.useNative && ai && typeof ai.stopAdbKeyRepeat === 'function') {
        ai.stopAdbKeyRepeat();
        adbRemoteDpadState.useNative = false;
      }
      if (adbRemoteDpadState.timeoutId) clearTimeout(adbRemoteDpadState.timeoutId);
      if (adbRemoteDpadState.intervalId) clearInterval(adbRemoteDpadState.intervalId);
      adbRemoteDpadState.timeoutId = null;
      adbRemoteDpadState.intervalId = null;
      adbRemoteDpadState.keyCode = null;
    }

    let backHoldTimer = null;
    let backHoldFired = false;
    let backHoldActive = false;
    function startBackHold(event) {
      event.preventDefault?.();
      event.stopPropagation?.();
      backHoldActive = true;
      backHoldFired = false;
      const ai = getAdbInterfaceOrWarn('Пульт ДУ');
      if (ai && typeof ai.startBackHold === 'function') {
        ai.startBackHold(500);
        return;
      }
      clearTimeout(backHoldTimer);
      backHoldTimer = setTimeout(() => {
        backHoldFired = true;
        sendAdbRemoteKey(4, true);
      }, 500);
    }

    function stopBackHold(event) {
      event.preventDefault?.();
      event.stopPropagation?.();
      if (!backHoldActive) return;
      backHoldActive = false;
      const ai = window.AndroidInterface;
      if (ai && typeof ai.stopBackHold === 'function') {
        ai.stopBackHold();
        return;
      }
      clearTimeout(backHoldTimer);
      if (!backHoldFired) {
        sendAdbRemoteKey(4, false);
      }
    }

    const adbRemoteRepeatState = new Map();
    let adbRemoteRepeatActive = false;
    let adbRemoteRepeatUseNative = false;
    function startAdbRemoteRepeat(event) {
      const btn = event.currentTarget;
      const keyCode = Number(btn?.dataset?.key);
      if (!keyCode) return;
      event.preventDefault();
      event.stopPropagation();
      const ai = getAdbInterfaceOrWarn('Пульт ДУ');
      if (!ai) return;
      if (!ensureAdbSessionConnected('Пульт ДУ')) return;
      if (typeof ai.startAdbKeyRepeat === 'function') {
        adbRemoteRepeatUseNative = true;
        ai.startAdbKeyRepeat(keyCode, 180, 85);
        return;
      }
      if (adbRemoteRepeatState.has(btn)) return;
      adbRemoteRepeatActive = true;
      sendAdbRemoteKey(keyCode);
      const initialDelay = 150;
      const intervalMs = 70;
      const timeoutId = setTimeout(() => {
        const intervalId = setInterval(() => sendAdbRemoteKey(keyCode), intervalMs);
        adbRemoteRepeatState.set(btn, { intervalId, timeoutId: null });
      }, initialDelay);
      adbRemoteRepeatState.set(btn, { intervalId: null, timeoutId });
    }

    function stopAdbRemoteRepeat(event) {
      const btn = event.currentTarget;
      const ai = window.AndroidInterface;
      if (adbRemoteRepeatUseNative && ai && typeof ai.stopAdbKeyRepeat === 'function') {
        ai.stopAdbKeyRepeat();
        adbRemoteRepeatUseNative = false;
        return;
      }
      const state = adbRemoteRepeatState.get(btn);
      if (!state) return;
      event.preventDefault?.();
      event.stopPropagation?.();
      if (state.timeoutId) clearTimeout(state.timeoutId);
      if (state.intervalId) clearInterval(state.intervalId);
      adbRemoteRepeatState.delete(btn);
      adbRemoteRepeatActive = false;
    }

    document.addEventListener('pointerup', () => {
      adbRemoteRepeatState.forEach((_, btn) => stopAdbRemoteRepeat({ currentTarget: btn }));
      const dpad = document.getElementById('adbRemoteDpad');
      if (dpad) delete dpad.dataset.dir;
      stopDpadRepeat();
    }, { passive: true });
    document.addEventListener('touchend', () => {
      adbRemoteRepeatState.forEach((_, btn) => stopAdbRemoteRepeat({ currentTarget: btn }));
      const dpad = document.getElementById('adbRemoteDpad');
      if (dpad) delete dpad.dataset.dir;
      stopDpadRepeat();
    }, { passive: true });

    function openScreenSaverModal(triggerBtn = null) {
  saveMainScroll();
      lastScreenSaverTrigger = triggerBtn || document.activeElement;
      document.activeElement?.blur();
      const modal = document.getElementById('screenSaverModal');
      if (!modal) return;
  setModalHeaderTitle('screenSaverHeader', (container) => {
    try {
      const btn = triggerBtn || lastScreenSaverTrigger || document.querySelector('.system-buttons .sys-btn[onclick*="openScreenSaverModal"]');
      const btnIcon = btn?.querySelector('img');
      const titleText = btn?.innerText?.trim() || 'Заставка';
      const fallbackIcon = 'https://appassets.androidplatform.net/assets/webview/icons/misc/ic12_ScreenServer.png';
      const iconSrc = btnIcon?.src || fallbackIcon;
      if (iconSrc) {
        const icon = document.createElement('img');
        icon.src = iconSrc;
        icon.alt = '';
        icon.style.height = '25px';
        icon.style.width = '25px';
        icon.style.objectFit = 'contain';
        container.appendChild(icon);
      }
      const title = document.createElement('span');
      title.textContent = titleText;
      container.appendChild(title);
    } catch (_e) {
      container.textContent = 'Заставка';
    }
  });
      modal.style.display = 'flex';
      bringModalToFront(modal);
      document.body.classList.add('modal-open');
      requestScreenSaverState();
      setTimeout(() => {
    const focusTarget = modal.querySelector('.screen-saver-body .sys-btn');
        focusTarget?.focus({ preventScroll: true });
      }, 80);
    }

    function closeScreenSaverModal() {
      const modal = document.getElementById('screenSaverModal');
      if (!modal) return;
      const timeoutModal = document.getElementById('screenSaverTimeoutModal');
      if (timeoutModal && timeoutModal.style.display === 'flex') {
        closeScreenSaverTimeoutModal();
      }
      modal.style.display = 'none';
      modal.style.zIndex = '';
      document.body.classList.remove('modal-open');
      const target = lastScreenSaverTrigger;
      lastScreenSaverTrigger = null;
      if (target && document.body.contains(target)) {
        setTimeout(() => target.focus({ preventScroll: true }), 60);
      }
  restoreMainScroll();
      restoreGroupModalOverlay();
    }

    function requestScreenSaverState() {
      window.AndroidInterface?.requestScreenSaverState();
    }

    window.updateScreenSaverState = function(payload) {
      let data = payload;
      try {
        if (typeof payload === 'string') {
          data = JSON.parse(payload);
        }
      } catch (e) {
        data = {};
      }
      const stateEl = document.getElementById('screenSaverState');
      const currentEl = document.getElementById('screenSaverCurrent');
      const idleBtn = document.getElementById('screenSaverIdleBtn');
      const sleepBtn = document.getElementById('screenSaverSleepBtn');
      const toggleBtn = document.getElementById('screenSaverToggleBtn');

      const enabled = data?.enabled ?? false;
      currentScreenSaverComponent = typeof data?.component === 'string' && data.component.trim().length ? data.component : null;
      stateEl.textContent = enabled ? 'Включена' : 'Отключена';
      stateEl.style.color = enabled ? '#00e676' : '#ff5252';

      currentEl.textContent = data?.current || '—';

      const screenMinutes = msToMinutes(data?.screenTimeoutMs);
      const sleepMinutes = msToMinutes(data?.sleepTimeoutMs);
      screenSaverTimeoutState.screen = screenMinutes;
      screenSaverTimeoutState.sleep = sleepMinutes;
      if (idleBtn) {
        idleBtn.textContent = formatMinutesLabel(screenMinutes);
      }
      if (sleepBtn) {
        sleepBtn.textContent = formatMinutesLabel(sleepMinutes);
      }
      if (toggleBtn) {
        toggleBtn.textContent = enabled ? 'Отключить заставку' : 'Включить заставку';
      }
    }

    function msToMinutes(ms) {
      if (!Number.isFinite(ms) || ms <= 0) return null;
      const minutes = Math.round(ms / 60000);
      if (!Number.isFinite(minutes) || minutes <= 0) return null;
      return minutes;
    }

    function formatMinutesLabel(minutes) {
      if (!Number.isFinite(minutes) || minutes <= 0) return '—';
      return `${minutes} мин`;
    }

    function openScreenSaverTimeoutModal(type) {
      const modal = document.getElementById('screenSaverTimeoutModal');
      if (!modal) return;
      screenSaverTimeoutModalType = type;
      const label = SCREEN_SAVER_TIMEOUT_LABELS[type] || 'Таймер';
      const parent = document.getElementById('screenSaverModal');
      modal.dataset.restoreScreen = '0';
      if (parent && parent.style.display === 'flex') {
        parent.setAttribute('inert', '');
        parent.style.pointerEvents = 'none';
        modal.dataset.restoreScreen = '1';
      }
      screenSaverTimeoutReturnEl = document.activeElement;
      document.activeElement?.blur();
      modal.style.display = 'flex';
      bringModalToFront(modal);
      document.body.classList.add('modal-open');
      const value = sanitizeScreenSaverMinutes(screenSaverTimeoutState[type], type);
      setScreenSaverTimeoutInput(value);
      document.getElementById('screenSaverTimeoutTitle').textContent = label;
      document.getElementById('screenSaverTimeoutLabel').textContent = `Минуты для: ${label}`;
      setTimeout(() => {
        document.getElementById('screenSaverTimeoutInput')?.focus({ preventScroll: true });
      }, 80);
    }

    function closeScreenSaverTimeoutModal() {
      const modal = document.getElementById('screenSaverTimeoutModal');
      if (!modal || modal.style.display !== 'flex') return;
      modal.style.display = 'none';
      modal.style.zIndex = '';
      if (modal.dataset.restoreScreen === '1') {
        const parent = document.getElementById('screenSaverModal');
        if (parent) {
          parent.removeAttribute('inert');
          parent.style.pointerEvents = '';
        }
        modal.dataset.restoreScreen = '0';
      }
      if (!anyModalOpen()) {
        document.body.classList.remove('modal-open');
      } else {
        document.body.classList.add('modal-open');
      }
      if (screenSaverTimeoutReturnEl && document.body.contains(screenSaverTimeoutReturnEl)) {
        screenSaverTimeoutReturnEl.focus({ preventScroll: true });
      }
      screenSaverTimeoutReturnEl = null;
      screenSaverTimeoutModalType = null;
    }

    function sanitizeScreenSaverMinutes(value, type) {
      const fallback = SCREEN_SAVER_TIMEOUT_DEFAULTS[type] ?? SCREEN_SAVER_TIMEOUT_DEFAULTS.screen;
      let minutes = parseInt(value, 10);
      if (!Number.isFinite(minutes) || minutes <= 0) {
        minutes = fallback;
      }
      return clampScreenSaverMinutes(minutes);
    }

    function clampScreenSaverMinutes(value) {
      return Math.min(SCREEN_SAVER_TIMEOUT_LIMITS.max, Math.max(SCREEN_SAVER_TIMEOUT_LIMITS.min, value));
    }

    function setScreenSaverTimeoutInput(value) {
      const input = document.getElementById('screenSaverTimeoutInput');
      if (!input) return;
      input.value = clampScreenSaverMinutes(value);
    }

    function applyScreenSaverTimeout() {
      if (!screenSaverTimeoutModalType) {
        closeScreenSaverTimeoutModal();
        return;
      }
      const input = document.getElementById('screenSaverTimeoutInput');
      if (!input) return;
      let minutes = parseInt(input.value, 10);
      if (!Number.isFinite(minutes)) {
        showToast({ message: 'Введите значение в минутах', type: 'warning' });
        input.focus({ preventScroll: true });
        return;
      }
      minutes = clampScreenSaverMinutes(minutes);
      const ai = window.AndroidInterface;
      if (!ai || typeof ai.setScreenSaverTimeout !== 'function') {
        showToast({ message: 'Функция недоступна', type: 'error' });
        closeScreenSaverTimeoutModal();
        return;
      }
      ai.setScreenSaverTimeout(screenSaverTimeoutModalType, minutes * 60000);
      closeScreenSaverTimeoutModal();
    }

    function setScreenSaverPackage(pkg) {
      if (!pkg) return;
      window.AndroidInterface?.setScreenSaverPackage(pkg);
    }

    function RunScreenSaverSettings() {
      const component = currentScreenSaverComponent || '';
      window.AndroidInterface?.runScreenSaverPreview?.(component);
    }

    function toggleScreenSaver() {
      window.AndroidInterface?.toggleScreenSaverEnabled();
    }

    function resetScreenSaverSettings() {
      window.AndroidInterface?.resetScreenSaverSettings();
    }

    // === Конфиг (только новый формат) и рендер групп ===
    function getConfigUrl() {
      // URL конфига всегда приходит из приложения
      return window.AndroidInterface?.getConfigUrl?.() || "";
    }

    async function ensureConfig() {
      if (cachedConfig) return cachedConfig;
      const url = getConfigUrl();
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error('Не удалось загрузить конфиг');
      const cfg = await r.json();
      cachedConfig = cfg;
      return cfg;
    }

    function createGroupIcon(url) {
      const isSvg = /\.svg(\?|$)/i.test(url);
      const makeImg = () => {
        const img = document.createElement('img');
        img.src = url;
        img.alt = '';
        img.style.height = '24px';
        img.style.width = '24px';
        img.style.objectFit = 'contain';
        return img;
      };

      if (!isSvg) return makeImg();

      const img = makeImg();
      img.onerror = () => {
        // Фолбэк: CSS background-image (часто рендерится в WebView, когда <img> с SVG нет)
        const box = document.createElement('div');
        box.style.width = '25px';
        box.style.height = '25px';
        box.style.backgroundImage = `url("${url}")`;
        box.style.backgroundRepeat = 'no-repeat';
        box.style.backgroundSize = 'contain';
        box.style.backgroundPosition = 'center';
        img.replaceWith(box);
      };
      return img;
    }

    function renderGroupsFromConfig(config) {
      const container = document.getElementById('groupCards') || document.querySelector('.card-container');
      if (!container) return;
      container.innerHTML = '';

      const groups = config.groups || {};
      const entries = Object.entries(groups);
      if (!entries.length) {
        container.innerHTML = '<div style="opacity:.7">Нет групп</div>';
        return;
      }

      entries.forEach(([groupKey, groupObj]) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.setAttribute('tabindex', '0');
        card.dataset.group = groupKey;

        if (groupObj && groupObj.icon) {
          const iconEl = createGroupIcon(groupObj.icon);
          card.appendChild(iconEl);
        }
        const label = document.createElement('div');
        label.className = 'group-title';
        label.textContent = groupKey;
        card.appendChild(label);

        card.onclick = () => { selectCard(card); startInstall(); };
        card.onfocus = () => selectCard(card);

        container.appendChild(card);
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      initModalAdbHeaders();
      ensureConfig()
        .then(cfg => { renderGroupsFromConfig(cfg); })
        .catch(() => { /* покажем ошибку при попытке открыть */ });
      refreshAdbStatusIndicator();
      setInterval(refreshAdbStatusIndicator, 5000);
      refreshLastAdbConnection();
    });

    let lastStartAttempt = 0;
    const START_DEBOUNCE_MS = 500;

    async function startInstall() {
      const now = Date.now();
      if (now - lastStartAttempt < START_DEBOUNCE_MS) return;
      lastStartAttempt = now;

      const group = currentGroup;
      const password = savedPassword;
      const status = document.getElementById('status');
      if (!group) { status.innerHTML = "❗ Пожалуйста, выберите пакет."; status.style.color = "red"; status.classList.add('visible'); return; }

      try {
        const config = await ensureConfig();
        const groupInfo = (config.groups || {})[group];
        if (!groupInfo) { status.innerHTML = "❌ Группа не найдена!"; status.style.color = "red"; status.classList.add('visible'); return; }
        if ((groupInfo.password || "") !== (password || "")) { showToast({ message: "🔒 Неверный пароль!" }); return; }
        cachedConfig = config;
        lastFocusedElement = document.activeElement;
        showGroupList(config);
      } catch (error) {
        status.innerHTML = "❌ Ошибка загрузки конфигурации."; status.style.color = "red"; status.classList.add('visible');
      }
    }

    function showStatus(message, color, timeout = 4000) {
      const status = document.getElementById('status');
      status.innerHTML = message; status.style.color = color; status.classList.add('visible');
      clearTimeout(status.hideTimer);
      status.hideTimer = setTimeout(() => status.classList.remove('visible'), timeout);
    }

    function getToastStack(position = 'bottom-center') {
      const id = `toast-stack-${position}`; let stack = document.getElementById(id);
      if (stack) return stack;
      const [v,h] = position.split('-');
      stack = document.createElement('div');
      stack.id = id;
      stack.className = `toast-stack toast-stack--${v} ${h === 'center' ? 'toast-stack--centerX' : (h === 'left' ? 'toast-stack--left' : 'toast-stack--right')} ${v === 'center' ? 'toast-stack--center' : ''}`;
      document.body.appendChild(stack);
      return stack;
    }
    function showToast({ message, type="info", iconUrl=null, withSpin=false, position="bottom-center", variant="default", duration=3000, anchor=null, offset=10, colors=null }) {
      if (!message) return;
      const styles = {
        success: { bg: "rgba(0,128,0,.85)", text: "#fff" },
        error:   { bg: "rgba(220,0,0,.9)",  text: "#fff" },
        warning: { bg: "rgba(255,165,0,.9)", text: "#000" },
        info:    { bg: "rgba(242,0,0,.85)", text: "#fff" },
        blue:    { bg: "rgba(0,123,255,.9)", text: "#fff" },
        pink:    { bg: "rgba(255,105,180,.9)", text: "#000" }
      };
      const scheme = colors || styles[type] || styles.info;

      const toast = document.createElement('div');
      toast.className = 'toast' + (variant==='pill'?' toast--pill':'') + (variant==='compact'?' toast--compact':'') + (variant==='card'?' toast--card':'');
      toast.style.backgroundColor = scheme.bg; toast.style.color = scheme.text;
      let html = '';
      if (withSpin) html += `<span class="spin">⏳</span>`;
      html += `<span>${message}</span>`;
      if (iconUrl) html += `<img src="${iconUrl}" alt="" style="height:20px; width:20px; object-fit:contain; vertical-align:middle;">`;
      toast.innerHTML = html;

      let cleanup;
      if (anchor) {
        const el = typeof anchor === 'string' ? document.querySelector(anchor) : anchor;
        const rect = el?.getBoundingClientRect();
        toast.classList.add('toast--anchored'); document.body.appendChild(toast);
        const top = (rect?.bottom ?? 0) + offset;
        const left = (rect ? rect.left + rect.width / 2 : window.innerWidth / 2);
        toast.style.top = `${top}px`; toast.style.left = `${left}px`; toast.style.transform = 'translateX(-50%)';
        cleanup = () => toast.remove();
      } else {
        const stack = getToastStack(position); stack.appendChild(toast);
        cleanup = () => { toast.remove(); if (!stack.children.length) stack.remove(); };
      }
      requestAnimationFrame(() => toast.classList.add('show'));
      const hide = () => { toast.classList.remove('show'); setTimeout(cleanup, 250); };
      const timer = setTimeout(hide, duration);
      toast.addEventListener('click', () => { clearTimeout(timer); hide(); });
    }

    // ===== Выбор элементов в списке группы =====
    let groupSelectMode = false;
    let groupSelectedKeys = new Set();
    let groupItemsByKey = new Map();
    let groupItemCounter = 0;
    const GROUP_LONG_PRESS_MS = 600;
    let groupModalSuppressKeyUntil = 0;

    function resetGroupSelectionState() {
      groupSelectMode = false;
      groupSelectedKeys.clear();
      groupItemsByKey.clear();
      groupItemCounter = 0;
      updateInstallAllButton();
    }

    function updateInstallAllButton() {
      const btn = document.getElementById('installAllBtn');
      const actions = document.getElementById('groupSelectActions');
      const selectAllBtn = document.getElementById('selectAllBtn');
      const list = document.getElementById('modalList');
      const total = groupItemsByKey.size;
      const selected = groupSelectedKeys.size;

      if (list) list.classList.toggle('selection-mode', groupSelectMode);
      if (actions) actions.classList.toggle('visible', groupSelectMode);
      if (selectAllBtn) {
        const allSelected = total > 0 && selected === total;
        selectAllBtn.textContent = allSelected ? 'Снять все' : 'Выбрать все';
        selectAllBtn.disabled = total === 0;
      }

      if (!btn) return;
      if (groupSelectMode) {
        btn.textContent = selected ? `Установить выбранные (${selected})` : 'Установить выбранные';
        btn.disabled = selected === 0;
        btn.classList.toggle('disabled', btn.disabled);
      } else {
        btn.textContent = 'Установить всё';
        btn.disabled = false;
        btn.classList.remove('disabled');
      }
    }

    function selectAllGroupItems() {
      const total = groupItemsByKey.size;
      if (!total) return;
      const allSelected = groupSelectedKeys.size === total;
      if (allSelected) {
        clearGroupSelection();
        return;
      }
      groupSelectMode = true;
      groupSelectedKeys.clear();
      document.querySelectorAll('#modalList .component-btn').forEach(btn => {
        const key = btn.dataset.itemKey;
        if (!key) return;
        groupSelectedKeys.add(key);
        btn.classList.add('selected');
      });
      updateInstallAllButton();
    }

    function clearGroupSelection() {
      groupSelectedKeys.clear();
      groupSelectMode = false;
      document.querySelectorAll('#modalList .component-btn.selected')
        .forEach(btn => btn.classList.remove('selected'));
      updateInstallAllButton();
    }

    function createGroupItemKey(type, item) {
      const base = item?.uid || item?.url || item?.file || item?.label || '';
      const safeBase = (typeof base === 'string' && base.trim()) ? base.trim() : 'item';
      return `${type}:${safeBase}:${groupItemCounter++}`;
    }

    function toggleGroupSelection(itemKey, btn) {
      if (groupSelectedKeys.has(itemKey)) {
        groupSelectedKeys.delete(itemKey);
        btn?.classList.remove('selected');
      } else {
        groupSelectedKeys.add(itemKey);
        btn?.classList.add('selected');
      }
      if (groupSelectedKeys.size === 0) {
        groupSelectMode = false;
      }
      updateInstallAllButton();
    }

    function enterGroupSelectMode(itemKey, btn) {
      if (!groupSelectMode) groupSelectMode = true;
      toggleGroupSelection(itemKey, btn);
    }

    function attachGroupItemHandlers(btn, itemKey, onActivate) {
      let longPressTimer = null;
      let ignoreClick = false;
      let keyLongPressTimer = null;
      let keyLongPressFired = false;
      const clear = () => {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
      };
      const clearKey = () => {
        if (keyLongPressTimer) {
          clearTimeout(keyLongPressTimer);
          keyLongPressTimer = null;
        }
        keyLongPressFired = false;
      };

      btn.addEventListener('pointerdown', (e) => {
        if (e.button && e.button !== 0) return;
        clear();
        longPressTimer = setTimeout(() => {
          ignoreClick = true;
          enterGroupSelectMode(itemKey, btn);
        }, GROUP_LONG_PRESS_MS);
      });
      btn.addEventListener('pointerup', clear);
      btn.addEventListener('pointerleave', clear);
      btn.addEventListener('pointercancel', clear);

      btn.addEventListener('keydown', (e) => {
        const isActivateKey = ['Enter', 'OK', 'NumpadEnter', ' '].includes(e.key);
        if (!isActivateKey) return;
        if (Date.now() < groupModalSuppressKeyUntil) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (e.repeat) { e.preventDefault(); e.stopPropagation(); return; }
        clearKey();
        keyLongPressTimer = setTimeout(() => {
          keyLongPressFired = true;
          ignoreClick = true;
          enterGroupSelectMode(itemKey, btn);
        }, GROUP_LONG_PRESS_MS);
        e.preventDefault();
        e.stopPropagation();
      });

      btn.addEventListener('keyup', (e) => {
        const isActivateKey = ['Enter', 'OK', 'NumpadEnter', ' '].includes(e.key);
        if (!isActivateKey) return;
        if (Date.now() < groupModalSuppressKeyUntil) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (keyLongPressTimer) {
          clearTimeout(keyLongPressTimer);
          keyLongPressTimer = null;
        }
        ignoreClick = true;
        if (!keyLongPressFired) {
          if (groupSelectMode) {
            toggleGroupSelection(itemKey, btn);
          } else {
            onActivate?.();
          }
        }
        keyLongPressFired = false;
        e.preventDefault();
        e.stopPropagation();
      });

      btn.addEventListener('click', (e) => {
        if (ignoreClick) {
          ignoreClick = false;
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (groupSelectMode) {
          e.preventDefault();
          toggleGroupSelection(itemKey, btn);
          return;
        }
        onActivate?.();
      });
    }

    function installSingleApp(app) {
      const method = window.AndroidInterface?.getInstallMethod?.() || 'sai';
      const statusMsg = method === 'adb'
        ? `ADB установка...<span class="spin"><img src="https://appassets.androidplatform.net/assets/webview/icons/title/ic_load_round.png" style="height:29px; vertical-align:middle;"></span>`
        : `Загрузка APK...<span class="spin"><img src="https://appassets.androidplatform.net/assets/webview/icons/title/ic_load_round.png" style="height:29px; vertical-align:middle;"></span>`;
      showStatus(statusMsg, "#00cfff", 4000);
      window.AndroidInterface?.installSingle(app.url, app.file || "Приложение");
    }

    function installSingleBackup(backup) {
      if (backup.files) {
        showStatus(`Копирование бэкапов... <span class="spin"><img src="https://appassets.androidplatform.net/assets/webview/icons/title/ic_load_round.png" style="height:29px; vertical-align:middle;"></span>`, "#00cfff", 4000);
        window.AndroidInterface?.copyFilesWithTargets(JSON.stringify(backup.files));
      } else {
        const urls = backup.urls || (backup.url ? [backup.url] : []);
        if (!urls.length) return;
        showStatus(`Копирование бэкапов... <span class="spin"><img src="https://appassets.androidplatform.net/assets/webview/icons/title/ic_load_round.png" style="height:29px; vertical-align:middle;"></span>`, "#00cfff", 4000);
        window.AndroidInterface?.copyMultipleBackups(JSON.stringify(urls), backup.target_folder || 'Download');
      }
    }

    function openLinkItem(link) {
      showStatus("🔗 Открытие инструкции...", "green", 3000);
      window.AndroidInterface?.openLink(link.url);
    }

    function installSingleItem(item) {
      if (!item) return;
      if (item.type === 'app') installSingleApp(item.data);
      else if (item.type === 'backup') installSingleBackup(item.data);
      else if (item.type === 'link') openLinkItem(item.data);
    }

    function collectSelectedItems() {
      const items = [];
      groupSelectedKeys.forEach((key) => {
        const item = groupItemsByKey.get(key);
        if (item) items.push(item);
      });
      return items;
    }

    function runSelectedItemsFallback(items) {
      let index = 0;
      const runNext = () => {
        if (index >= items.length) return;
        installSingleItem(items[index++]);
        setTimeout(runNext, 350);
      };
      runNext();
    }

    function installSelectedItems(items) {
      if (!items.length) return;
      const apps = items.filter(i => i.type === 'app').map(i => i.data);
      const backups = items.filter(i => i.type === 'backup').map(i => i.data);
      const links = items.filter(i => i.type === 'link').map(i => i.data);

      if (apps.length || backups.length) {
        if (window.AndroidInterface?.startSelectedInstallation) {
          window.AndroidInterface.startSelectedInstallation(JSON.stringify({ group: currentGroup || '', apps, backups }));
        } else {
          runSelectedItemsFallback(items);
        }
        if (links.length) {
          showToast({ message: 'Ссылки не входят в пакетную установку', type: 'warning', duration: 3000 });
        }
        return;
      }

      if (links.length) {
        links.forEach(link => window.AndroidInterface?.openLink?.(link.url));
      }
    }

    // ===== Список группы =====
    function showGroupList(config)  {
      const modal = document.getElementById('modal');
      const list  = document.getElementById('modalList');
      list.innerHTML = "";
      resetGroupSelectionState();
      groupModalSuppressKeyUntil = Date.now() + 400;


      document.activeElement?.blur();
      document.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));

      modal.style.display = "flex";
      document.body.classList.add("modal-open"); // Блокируем скролл основного интерфейса
      setTimeout(() => { document.querySelector('#modalList .component-btn')?.focus({ preventScroll: true }); }, 80);

      const apps    = (config.apps || []).filter(app => (app.tags || []).includes(currentGroup));
      const backups = (config.backups || []).filter(backup => (backup.tags || []).includes(currentGroup));
      const links   = (config.links || []).filter(link => (link.tags || []).includes(currentGroup));
      if (apps.length === 0 && backups.length === 0 && links.length === 0) list.innerHTML = "Нет доступных компонентов.";

      // Заголовок: иконка + имя группы
      setModalHeaderTitle('modalGroupHeader', (container) => {
        const groupInfo = (config.groups || {})[currentGroup];
        if (groupInfo && groupInfo.icon) {
          const iconEl = createGroupIcon(groupInfo.icon);
          iconEl.style.height = '25px';
          iconEl.style.width = '25px';
          container.appendChild(iconEl);
        }
        const title = document.createElement('span');
        title.textContent = currentGroup;
        container.appendChild(title);
      });

      apps.forEach(app => {
        const btn = document.createElement('button');
        btn.className = 'component-btn'; btn.setAttribute('tabindex','0'); btn.textContent = app.file;
        const itemKey = createGroupItemKey('app', app);
        groupItemsByKey.set(itemKey, { type: 'app', data: app });
        btn.dataset.itemKey = itemKey;
        attachGroupItemHandlers(btn, itemKey, () => installSingleApp(app));
        list.appendChild(btn);
      });

      backups.forEach(backup => {
        const btn = document.createElement('button');
        btn.className = 'component-btn'; btn.setAttribute('tabindex','0'); btn.textContent = backup.file;
        const itemKey = createGroupItemKey('backup', backup);
        groupItemsByKey.set(itemKey, { type: 'backup', data: backup });
        btn.dataset.itemKey = itemKey;
        attachGroupItemHandlers(btn, itemKey, () => installSingleBackup(backup));
        list.appendChild(btn);
      });

      links.forEach(link => {
        const btn = document.createElement('button');
        btn.className = 'component-btn'; btn.setAttribute('tabindex','0'); btn.textContent = link.file;
        const itemKey = createGroupItemKey('link', link);
        groupItemsByKey.set(itemKey, { type: 'link', data: link });
        btn.dataset.itemKey = itemKey;
        attachGroupItemHandlers(btn, itemKey, () => openLinkItem(link));
        list.appendChild(btn);
      });

      modal.style.display = "flex";
      setTimeout(() => { document.querySelector('#modalList .component-btn')?.focus({ preventScroll: true }); }, 80);
    }


    

    function installAll() {
      if (groupSelectMode) {
        const items = collectSelectedItems();
        if (!items.length) return;
        installSelectedItems(items);
        return;
      }
      if (window.AndroidInterface) {
        requestAnimationFrame(() => {
          setTimeout(() => {
            window.AndroidInterface.startInstallation(currentGroup);
          }, 100);  // Можно увеличить задержку до 200-300, если совсем не видно
        });
      }
    }

 function installAllSend() {
  /* showStatus("⏳ Началась загрузка приложений, ожидайте!!! <span class='spin'>⏳</span>", "orange", 4000); */
  showStatus(`Началась загрузка приложений, ожидайте!!!<span class="spin"><img src="https://appassets.androidplatform.net/assets/webview/icons/title/ic_load_round.png" style="height:29px; vertical-align:middle;"></span>`, "#00cfff", 4000);
 }

 function installSelectedSend() {
  showStatus(`Началась установка выбранных компонентов...<span class="spin"><img src="https://appassets.androidplatform.net/assets/webview/icons/title/ic_load_round.png" style="height:29px; vertical-align:middle;"></span>`, "#00cfff", 4000);
 }
    


    function closeModal() {
      const modal = document.getElementById('modal');
      resetGroupSelectionState();
      modal.style.display = "none";
      document.body.classList.remove("modal-open"); // Разблокируем скролл основного интерфейса
      restoreGroupModalOverlay();
      if (lastFocusedElement && document.body.contains(lastFocusedElement)) {
        if (lastFocusedElement.classList?.contains('card')) selectCard(lastFocusedElement);
        lastFocusedElement.focus?.({ preventScroll: true });
      }
    }

    function handleBackButton() {
      if (document.getElementById('launcherActionsModal')?.style.display === 'flex') closeLauncherActions();
      else if (document.getElementById('launcherModal')?.style.display === 'flex') closeLaunchersModal();
      else if (document.getElementById('atvAppActionsModal')?.style.display === 'flex') closeAtvAppActions();
      else if (document.getElementById('atvAppsModal')?.style.display === 'flex') closeAtvAppsModal();
      else if (document.getElementById('installMethodModal')?.style.display === 'flex') closeInstallMethodSettings();
      else if (document.getElementById('screenSaverModal')?.style.display === 'flex') closeScreenSaverModal();
      else if (document.getElementById('adbRemoteModal')?.style.display === 'flex') {
        const panel = document.getElementById('adbRemoteKeyboardPanel');
        if (panel && panel.style.display === 'block') {
          toggleAdbRemoteKeyboardPanel();
        } else {
          closeAdbRemoteModal();
        }
      }
      else if (document.getElementById('adbCommandsModal')?.style.display === 'flex') closeAdbCommandsModal();
      else if (document.getElementById('miscMoreModal')?.style.display === 'flex') closeMiscMoreModal();
      else if (document.getElementById('adbManualConnectModal')?.style.display === 'flex') closeAdbManualConnectModal();
      else if (document.getElementById('adbScannerModal')?.style.display === 'flex') closeAdbScanner();
      else if (document.getElementById('miscModal')?.style.display === 'flex') closeMiscModal();
      else if (document.getElementById('autostartModal')?.style.display === 'flex') closeAutostartModal();
      else if (document.getElementById('modal')?.style.display === 'flex') {
        if (groupSelectMode) {
          clearGroupSelection();
        } else {
          closeModal();
        }
      }
      else { window.AndroidInterface.requestAppExit(); }
    }

    // Глобальное закрытие модалок по Back/Escape
    document.addEventListener('keydown', (e) => {
      if (e.key !== 'Back' && e.key !== 'Escape') return;
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      handleBackButton();
    }, true);

    

   function updateProgress(current=null, total=null, percent=0, label) {
      const container = document.getElementById("progress-container");
      const bar = document.getElementById("progress-bar");
      const text = document.getElementById("progress-text");
      container.style.display = "block"; 
      bar.style.width = percent + "%";
      
      // Проверяем на undefined и null значения
      if (current !== null && total !== null && current !== undefined && total !== undefined && label) {
        text.innerHTML = `Загрузка приложения:&nbsp;&nbsp; ${label}&nbsp;&nbsp;&nbsp;&nbsp;${percent}%`;
      } else {
        text.innerText = `Загрузка...`;
      }
      if (percent >= 100 && (current === null || current === total)) {
        setTimeout(() => { container.style.display = "none"; bar.style.width = "0%"; text.innerHTML = ""; }, 1500);
      }
    }
    function updateProgressWithLabel(current, total, percent, label) {
      const container = document.getElementById("progress-container");
      const bar = document.getElementById("progress-bar");
      const text = document.getElementById("progress-text");
      container.style.display = "block"; bar.style.width = percent + "%"; text.innerText = `Загрузка ${label}: ${percent}%`;
      if (percent >= 100 && current === total) setTimeout(() => { container.style.display = "none"; bar.style.width = "0%"; text.innerText = ""; }, 1500);
    }

    function openAutostartModal(opener = null) {
      if (lastAdbIndicatorConnected) {
        showToast({ message: 'Автозапуск доступен только в локальном режиме', type: 'warning', duration: 3500 });
        return;
      }
      autostartOpener = opener instanceof HTMLElement
        ? opener
        : (document.activeElement instanceof HTMLElement ? document.activeElement : null);
      lastFocusedElement = autostartOpener;

      autostartReturnModal = null;
      const miscMore = document.getElementById('miscMoreModal');
      const misc = document.getElementById('miscModal');
      if (miscMore && miscMore.style.display === 'flex') {
        autostartReturnModal = 'miscMore';
        lastFocusedElementMiscMore = null;
        closeMiscMoreModal();
        if (misc && misc.style.display === 'flex') {
          closeMiscModal(false);
        }
      } else if (misc && misc.style.display === 'flex') {
        autostartReturnModal = 'misc';
        closeMiscModal(false);
      }
      const modal = document.getElementById('autostartModal');
      const list = document.getElementById('autostartList');
      const current = document.getElementById('autostartCurrent');
      current.innerHTML = '<span style="color:#00cfff;">Без автозапуска</span>';

      window.AndroidInterface?.getCurrentAutostartApp();

      // Сброс текущего фокуса перед открытием
      document.activeElement?.blur();
      document.body.classList.add('modal-open');
      modal.style.display = 'flex';
      list.innerHTML = '<div style="grid-column:1/-1; text-align:center;">⏳ Загрузка...</div>';

      window.AndroidInterface?.getUserApps();

      // Фолбэк-фокус, если список придёт поздно
      setTimeout(() => {
        const first = list.querySelector('.card');
        if (first) first.focus({ preventScroll: true }); else { modal.setAttribute('tabindex','-1'); modal.focus(); }
      }, 500);
    }

    function setCurrentAutostartApp(appLabel, appIcon) {
      const current = document.getElementById("autostartCurrent");
      current.innerHTML = `
        <span style="font-weight:bold; color:#00cfff;">Активное:</span>
        <img src="${appIcon}" alt="" style="height:24px; vertical-align:middle; margin:0 6px;">
        <span style="font-weight:bold;">${appLabel}</span>`;
    }

    function closeAutostartModal() {
      const modal = document.getElementById('autostartModal');
      modal.style.display = 'none';
      document.body.classList.remove('modal-open');

      const returnModal = autostartReturnModal;
      const opener = autostartOpener;
      autostartReturnModal = null;
      autostartOpener = null;

      if (returnModal === 'miscMore') {
        openMiscModal();
        setTimeout(() => {
          openMiscMoreModal();
          if (opener && document.body.contains(opener)) {
            setTimeout(() => opener.focus?.({ preventScroll: true }), 120);
          }
        }, 50);
        return;
      }
      if (returnModal === 'misc') {
        openMiscModal();
        if (opener && document.body.contains(opener)) {
          setTimeout(() => opener.focus?.({ preventScroll: true }), 120);
        }
        return;
      }

      const focusTarget = opener || lastFocusedElement;
      if (focusTarget && document.body.contains(focusTarget)) {
        setTimeout(() => focusTarget.focus?.({ preventScroll: true }), 50);
      }
    }

    /* === helpers для автозапуска === */
    function getAutostartCols() {
      const grid = document.getElementById('autostartList');
      if (!grid) return 5;
      const cs = getComputedStyle(grid);
      const tpl = cs.getPropertyValue('grid-template-columns');
      const count = (tpl || '').split(' ').filter(Boolean).length;
      return count || 5;
    }
    function focusAndRevealAuto(el, margin = 12) {
      const container = document.getElementById('autostartListContainer');
      if (!el || !container) return;
      const cr = container.getBoundingClientRect();
      const er = el.getBoundingClientRect();
      if (er.top < cr.top + margin) container.scrollTop -= (cr.top + margin - er.top);
      else if (er.bottom > cr.bottom - margin) container.scrollTop += (er.bottom - (cr.bottom - margin));
      requestAnimationFrame(() => el.focus({ preventScroll: true }));
    }

    function renderAppSelection(json) {
      const apps = JSON.parse(json);
      const list = document.getElementById('autostartList');
      list.innerHTML = '';

      apps.forEach(app => {
        const card = document.createElement('div');
        card.className = 'card';
        card.setAttribute('tabindex', '0');
        card.innerHTML = `<img src="${app.icon}" alt="" style="height:24px;"><br>${app.label}`;

        card.onclick = (ev) => {
          ev.preventDefault(); ev.stopPropagation();
          window.AndroidInterface.saveAutostartPackage(app.package);
          setCurrentAutostartApp(app.label, app.icon);
          showToast({ message: `${app.label} установлено как автозапуск`, iconUrl: app.icon, type: "success" });
        };

        // ВАЖНО: не менять "Выбрано" при навигации — оставляем как ты просил
        card.onfocus = () => {
          document.querySelectorAll('#autostartList .card').forEach(c => c.classList.remove('selected'));
          card.classList.add('selected');
          const cur = document.getElementById("autostartCurrent");
          if (cur) cur.textContent = "Выбрано: " + applabel;
          focusAndRevealAuto(card);
        };
        card.onblur = () => card.classList.remove('selected');

        list.appendChild(card);
      });

      // Явно фокусируем первую карточку и страхуемся повторной установкой фокуса
      const ensureFirstFocus = () => {
        const first = list.querySelector('.card');
        if (!first) return;
        const active = document.activeElement;
        if (!list.contains(active)) first.focus({ preventScroll: true });
      };
      setTimeout(ensureFirstFocus, 50);
      setTimeout(ensureFirstFocus, 200);
      setTimeout(ensureFirstFocus, 600);

      // Принудительно сбрасываем любые старые выделения и выставляем выделение на первой карточке
      const hardResetFocus = () => {
        const container = document.getElementById('autostartListContainer');
        if (container) container.scrollTop = 0;
        list.querySelectorAll('.card.selected').forEach(c => c.classList.remove('selected'));
        const first = list.querySelector('.card');
        if (first) {
          first.classList.add('selected');
          first.focus({ preventScroll: true });
        }
      };
      requestAnimationFrame(hardResetFocus);
      setTimeout(hardResetFocus, 0);
      setTimeout(hardResetFocus, 150);
    }

    function disableAutostart() {
      window.AndroidInterface?.DeleteAutostartPackage("");
      const current = document.getElementById('autostartCurrent');
      if (current) current.innerHTML = '<span style="color:#00cfff;">Автозапуск отключён</span>';
      showToast({ message: "Автозапуск отключён" });
    }

    function hideProgress() {
      const container = document.getElementById('progress-container');
      const bar = document.getElementById('progress-bar');
      const text = document.getElementById('progress-text');
      if (container) container.style.display = 'none';
      if (bar) bar.style.width = '0%';
      if (text) text.innerText = '';
    }

    function onInstalledAppsReceived(appsJson) {
      const container = document.getElementById('appList');
      if (!container) return;
      container.innerHTML = '';
      let apps;
      try { apps = JSON.parse(appsJson); }
      catch (e) { container.innerHTML = 'Ошибка чтения списка.'; return; }

      apps.forEach(app => {
        const btn = document.createElement('button');
        btn.textContent = `${app.name} (${app.package})`;
        btn.onclick = () => { window.AndroidInterface.setAutostartPackage(app.package); alert("Установлено: " + app.name); closeAutostartModal(); };
        container.appendChild(btn);
        container.appendChild(document.createElement('br'));
      });
    }

    // Снятие выделения с группы при фокусе на нижних кнопках и новых иконках
    document.querySelectorAll(".system-buttons .sys-btn, #passwordBtn, #startBtn, .password-row-icon-btn, .adb-status-icon").forEach(btn => {
      btn.addEventListener("focus", () => { document.querySelectorAll(".card").forEach(c => c.classList.remove("selected")); });
    });

    setTimeout(() => {
      document.getElementById('splash').style.display = 'none';
      document.getElementById('main-content').style.display = 'block';
      document.body.classList.remove('splash-open');
      document.documentElement.classList.remove('splash-open');
      // вернуть прокрутку после сплэша (сбрасываем inline overflow у <html>)
      document.documentElement.style.overflow = '';
      document.body.style.overflow = '';
    }, 4000);

    // misc modal open/close
    function openMiscModal(triggerBtn=null) {
      lastFocusedElement = document.activeElement;
      const modal = document.getElementById("miscModal");

      // Заголовок с иконкой и названием из кнопки-триггера (fallback на обычный h3, если #miscHeader нет)
      setModalHeaderTitle('miscHeader', (container) => {
        try {
          const btn = triggerBtn || document.querySelector('.system-buttons .sys-btn[onclick*="openMiscModal"]');
          const img = btn?.querySelector('img');
          const titleText = btn?.innerText?.trim() || 'Разное';
          if (img) {
            const icon = document.createElement('img');
            icon.src = img.src;
            icon.alt = '';
            icon.style.height = '25px';
            icon.style.width = '25px';
            icon.style.objectFit = 'contain';
            container.appendChild(icon);
          }
          const title = document.createElement('span');
          title.textContent = titleText;
          container.appendChild(title);
        } catch (e) {
          container.textContent = 'Разное';
        }
      });
      modal.style.display = "flex";
      document.body.classList.add("modal-open");
      document.activeElement?.blur();
      const firstBtn = modal.querySelector('.sys-btn');
      if (firstBtn) setTimeout(() => firstBtn.focus(), 100); else modal.focus();
    }
    function closeMiscModal(restoreFocus = true) {
      const modal = document.getElementById("miscModal");
      if (!modal) return;
      modal.style.display = "none";
      document.body.classList.remove("modal-open");
      // Сброс подсветки выбранных кнопок внутри «Разное», чтобы не оставалась фиктивная подсветка
      modal.querySelectorAll('.misc-buttons-container .sys-btn.selected').forEach(b => b.classList.remove('selected'));
      if (restoreFocus) {
        setTimeout(() => {
          if (lastFocusedElement && document.body.contains(lastFocusedElement)) lastFocusedElement.focus?.();
          lastFocusedElement = null;
        }, 50);
      }
    }

    function openMiscMoreModal(triggerBtn = null) {
      const mainModal = document.getElementById("miscModal");
      const moreModal = document.getElementById("miscMoreModal");
      if (!moreModal) return;

      lastFocusedElementMiscMore = triggerBtn || document.activeElement;

      setModalHeaderTitle('miscMoreHeader', (container) => {
        const btn = triggerBtn || document.querySelector('#miscModal .sys-btn[onclick*="openMiscMoreModal"]');
        const img = btn?.querySelector('img');
        const titleText = btn?.innerText?.trim() || 'Дополнительные функции';
        if (img) {
          const icon = document.createElement('img');
          icon.src = img.src;
          icon.alt = '';
          icon.style.height = '25px';
          icon.style.width = '25px';
          icon.style.objectFit = 'contain';
          container.appendChild(icon);
        }
        const title = document.createElement('span');
        title.textContent = titleText;
        container.appendChild(title);
      });

      if (mainModal) {
        mainModal.setAttribute("inert", "");
        mainModal.style.pointerEvents = "none";
      }

      document.activeElement?.blur();
      moreModal.style.display = "flex";
      document.body.classList.add("modal-open");

      const scrollContainer = moreModal.querySelector('.misc-buttons-container');
      if (scrollContainer) {
        scrollContainer.scrollTop = 0;
      }

      const firstBtn = moreModal.querySelector('.sys-btn');
      if (firstBtn) setTimeout(() => firstBtn.focus({ preventScroll: true }), 100);
      else moreModal.focus();
    }

    function closeMiscMoreModal() {
      const mainModal = document.getElementById("miscModal");
      const moreModal = document.getElementById("miscMoreModal");
      if (!moreModal) return;

      moreModal.style.display = "none";
      document.body.classList.remove("modal-open");

      if (mainModal) {
        mainModal.removeAttribute("inert");
        mainModal.style.pointerEvents = "";
        document.body.classList.add("modal-open");
      }

      setTimeout(() => {
        if (lastFocusedElementMiscMore && document.body.contains(lastFocusedElementMiscMore)) {
          lastFocusedElementMiscMore.focus?.({ preventScroll: true });
        }
        lastFocusedElementMiscMore = null;
      }, 50);
    }

  </script>
<script>
// 1) Режем автоповтор клавиши Enter/OK по всему приложению (CAPTURE + immediate)
document.addEventListener('keydown', function(e) {
  const isEnter = (e.key === 'Enter' || e.code === 'Enter' || e.key === 'NumpadEnter' || e.key === 'OK');
  if (isEnter && e.repeat) {
    e.preventDefault();
    e.stopImmediatePropagation();
  }
}, true);

// 2) Глобальный дебаунс «кликов от удержания» — пер-элементный
const __lastClickByEl = new WeakMap();
document.addEventListener('click', function(e) {
  const target = e.target.closest('button, [role="button"], .component-btn, #installAllBtn');
  if (!target) return;
  const now = Date.now();
  const last = __lastClickByEl.get(target) || 0;
  const interval = 700; // можно 500..900 мс

  if (now - last < interval) {
    e.preventDefault();
    e.stopImmediatePropagation();
    return;
  }
  __lastClickByEl.set(target, now);
}, true);

// Показать настройки метода установки (как модалка "Разное")
function showInstallMethodSettings(triggerBtn = null) {
    saveMainScroll();
    lastFocusedElement = triggerBtn || document.activeElement;
    
    // Получаем текущий метод установки
    const currentMethod = window.AndroidInterface?.getInstallMethod?.() || 'sai';
    
    // Устанавливаем текущий метод в радиокнопки
    const radioBtn = document.getElementById('method_' + currentMethod);
    if (radioBtn) {
        radioBtn.checked = true;
        document.querySelectorAll('#installMethodModal .method-option').forEach(option => option.classList.remove('selected'));
        radioBtn.closest('.method-option')?.classList.add('selected');
    }
    
    // freeze Разное, если открыто
    const misc = document.getElementById('miscModal');
    if (misc && misc.style.display === 'flex') {
      misc.setAttribute('inert', '');
      misc.style.pointerEvents = 'none';
    }
    
    // Показываем модалку
    const modal = document.getElementById("installMethodModal");
    modal.style.display = "flex";
    document.body.classList.add("modal-open");
    document.activeElement?.blur();
    __installMethodIndex = 0;
    const firstOption = modal.querySelector('.method-option');
    if (firstOption) setTimeout(() => firstOption.focus({ preventScroll: true }), 80); else modal.focus();
}

// Закрыть настройки метода установки (как модалка "Разное")
function closeInstallMethodSettings() {
    const modal = document.getElementById("installMethodModal");
    modal.style.display = "none";
    document.body.classList.remove("modal-open");
    
    // unfreeze Разное
    const misc = document.getElementById('miscModal');
    if (misc) { 
      misc.removeAttribute('inert'); 
      misc.style.pointerEvents = ''; 
    }
    
    restoreMainScroll();
    setTimeout(() => { if (lastFocusedElement && document.body.contains(lastFocusedElement)) lastFocusedElement.focus?.(); lastFocusedElement = null; }, 50);
}

// Обработка изменения метода установки
document.addEventListener('DOMContentLoaded', function() {
    const radioButtons = document.querySelectorAll('input[name="install_method"]');
    
    radioButtons.forEach(radio => {
        radio.addEventListener('change', function() {
            if (this.checked) {
                selectInstallMethod(this.value, this.closest('.method-option'));
            }
        });
    });
});

// Не позволяем фокусу попадать в radio, держим его на карточке
let __installMethodIndex = 0;

(function ensureInstallMethodFocus() {
  const modal = document.getElementById('installMethodModal');
  if (!modal) return;
  const radios = modal.querySelectorAll('.method-option input[type="radio"]');
  const cards = Array.from(modal.querySelectorAll('.method-option'));

  // назначаем tabindex для карточек и запоминаем порядок
  cards.forEach((card, idx) => {
    card.tabIndex = 0;
    card.dataset.methodIdx = String(idx);
  });

  radios.forEach(r => {
    r.setAttribute('tabindex', '-1');
    r.setAttribute('aria-hidden', 'true');
    r.disabled = true; // убираем фокус/навигацию внутрь radio
    r.style.pointerEvents = 'none';
    r.addEventListener('focus', (e) => {
      e.preventDefault();
      const card = r.closest('.method-option');
      if (card) card.focus({ preventScroll: true });
    }, true);
  });

  modal.addEventListener('focusin', (e) => {
    const cardTarget = e.target?.closest?.('.method-option');
    if (cardTarget) {
      const idx = Number(cardTarget.dataset.methodIdx ?? cards.indexOf(cardTarget));
      if (Number.isFinite(idx)) __installMethodIndex = Math.max(0, Math.min(idx, cards.length - 1));
      return; // уже на карточке — оставляем
    }

    const radio = e.target?.closest?.('input[type="radio"]');
    if (!radio) return;
    e.preventDefault();
    const radioCard = radio.closest('.method-option');
    if (radioCard) requestAnimationFrame(() => radioCard.focus({ preventScroll: true }));
  }, true);

  // на всякий случай фокусируем первую карточку при открытии
  modal.addEventListener('transitionend', () => {
    const first = cards[0];
    if (first && modal.style.display === 'flex') {
      first.focus({ preventScroll: true });
    }
  });
})();

// Простая навигация по карточкам installMethodModal
document.addEventListener('keydown', (e) => {
  const modal = document.getElementById('installMethodModal');
  if (!modal || modal.style.display !== 'flex') return;
  const keys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter','Back','Escape'];
  if (!keys.includes(e.key)) return;

  const cards = Array.from(modal.querySelectorAll('.method-option'));
  if (!cards.length) return;

  e.stopPropagation();
  e.stopImmediatePropagation();
  e.preventDefault();

  const activeCard = document.activeElement?.closest?.('.method-option');
  if (activeCard) {
    const idx = Number(activeCard.dataset.methodIdx ?? cards.indexOf(activeCard));
    if (Number.isFinite(idx)) __installMethodIndex = idx;
  }

  const clamp = (i) => Math.min(Math.max(i, 0), cards.length - 1);

  if (e.key === 'Enter') {
    const card = cards[clamp(__installMethodIndex)];
    card?.click();
    return;
  }
  if (e.key === 'Back' || e.key === 'Escape') {
    closeInstallMethodSettings();
    return;
  }

  const delta = (e.key === 'ArrowDown' || e.key === 'ArrowRight') ? 1 : -1;
  const next = clamp(__installMethodIndex + delta);
  __installMethodIndex = next;
  cards[next]?.focus({ preventScroll: true });
}, true);

function selectInstallMethod(method, targetElement = null) {
  if (__installMethodApplying) return;
  __installMethodApplying = true;
  try {
    // Снимаем выделение со всех опций
    document.querySelectorAll('#installMethodModal .method-option').forEach(option => {
      option.classList.remove('selected');
    });

    const radio = document.getElementById('method_' + method);
    const target = targetElement || radio?.closest('.method-option');

    if (target) {
      target.classList.add('selected');
    }

    if (radio && !radio.checked) {
      radio.checked = true;
    }

    if (window.AndroidInterface && window.AndroidInterface.setInstallMethod) {
      window.AndroidInterface.setInstallMethod(method);
    }
  } finally {
    setTimeout(() => { __installMethodApplying = false; }, 0);
  }
}

  
</script>

	<script>
  function openExternal(url) {
    try {
      if (window.AndroidInterface) {
        if (typeof AndroidInterface.openExternalLink === 'function') {
          AndroidInterface.openExternalLink(url);   // ваш предпочтительный метод
          return;
        }
        if (typeof AndroidInterface.openLink === 'function') {
          AndroidInterface.openLink(url);
          return;
        }
        if (typeof AndroidInterface.openUrl === 'function') {
          AndroidInterface.openUrl(url);
          return;
        }
      }
    } catch (e) { console.log(e); }
    // Фолбэк: откроется внутри WebView, если не перехватывать shouldOverrideUrlLoading
    window.location.href = url;
  }
	 function openInternal(url) {
    try {
      if (window.AndroidInterface && typeof AndroidInterface.openInternalLink === 'function') {
        AndroidInterface.openInternalLink(url);
        return;
      }
    } catch(e){ console.log(e); }

    window.location.assign(url);
  }
</script>

<!-- ATV Apps state and functions -->
<script>
const atvAppsState = {
  apps: [],
  filter: 'all',
  source: 'local',
  sourceLabel: 'Локальное устройство',
  localIcons: {},
  localLabels: {},
  localVersions: {},
  defaultIcon: null,
  loading: false
};

let atvLastFocusedAppEl = null;
let atvInputBlockUntil = 0;
function isAtvInputBlocked() {
  return atvAppsState.loading || Date.now() < atvInputBlockUntil;
}
let __mainScrollTop = null;
function saveMainScroll() {
  const scroller = document.scrollingElement || document.documentElement;
  __mainScrollTop = scroller.scrollTop;
}
function restoreMainScroll() {
  if (__mainScrollTop === null) return;
  const scroller = document.scrollingElement || document.documentElement;
  scroller.scrollTop = __mainScrollTop;
  __mainScrollTop = null;
}

const atvDefaultIcons = {
  user: 'https://appassets.androidplatform.net/assets/webview/icons/list/user.png',
  system: 'https://appassets.androidplatform.net/assets/webview/icons/list/system.png'
};
const atvLoadingHtml = `
  <div class="atv-loading">
    <div class="launcher-spinner" aria-hidden="true"></div>
    <div style="opacity:0.85;">Загрузка списка…</div>
  </div>
`;
const launcherLoadingHtml = `
  <div class="atv-loading">
    <div class="launcher-spinner" aria-hidden="true"></div>
    <div style="opacity:0.85;">Загрузка списка…</div>
  </div>
`;

function openAtvAppsModalFast(btn) {
  ignoreNextEnter = true;
  // Требуем активное ADB-подключение
  if (!isAdbSessionConnected()) {
    showToast({ message: 'ADB не подключен', type: 'warning', position: 'top-center' });
    ignoreNextEnter = false;
    return;
  }
  showToast({ message: 'Открываю список приложений', type: 'warning', position: 'bottom-center', duration: 2000 });

  const modal = document.getElementById('atvAppsModal');
  if (!modal) return;
  document.activeElement?.blur();
  modal.style.display = 'flex';
  document.body.classList.add('modal-open');
  // Обновляем заголовок и иконку из кнопки-триггера
  const header = document.getElementById('atvAppsHeader');
  const iconSrc = btn?.querySelector('img')?.src || 'https://appassets.androidplatform.net/assets/webview/icons/main/ic20_ATV.png';
  const titleText = (btn?.innerText || 'Приложения Android TV').trim();
  if (header) {
    header.innerHTML = `<img src="${iconSrc}" alt="" style="height:22px; vertical-align:middle; margin-right:6px;">${titleText}`;
  }
  setAtvAppsFilter('all', false);
  refreshAtvAppsList('remote');
  
  setTimeout(() => {
    const firstFilter = modal.querySelector('.app-filters .sys-btn');
    if (firstFilter) {
      firstFilter.focus({ preventScroll: true });
    } else {
      modal.focus();
    }
  }, 120);
}

function closeAtvAppsModal() {
  const modal = document.getElementById('atvAppsModal');
  if (!modal) return;
  modal.style.display = 'none';
  modal.style.zIndex = '';
  closeAtvAppActions();
  if (!anyModalOpen()) {
    document.body.classList.remove('modal-open');
  }
  setTimeout(() => {
    ignoreNextEnter = false;
  }, 100);
}

function setAtvAppsFilter(filter, rerender = true) {
  if (isAtvInputBlocked()) return;
  atvAppsState.filter = filter;
  document.querySelectorAll('#atvAppsFilters .sys-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.filter === filter);
  });
  if (rerender) renderAtvAppsList();
}

function refreshAtvAppsList(source = 'auto') {
  setAtvLoading(true);
  // Даем браузеру время прорисовать спиннер, затем дергаем тяжёлый вызов
  renderAtvAppsList();
  setTimeout(() => {
    try {
      const raw = window.AndroidInterface?.getAppsInventory?.(source) || '';
      handleAtvAppsPayload(raw);
    } catch (e) {
      handleAtvAppsPayload('{}');
      console.warn('getAppsInventory error', e);
      showToast?.({ message: '❌ Ошибка получения списка', type: 'error' });
    }
  }, 30);
}

function handleAtvAppsPayload(raw) {
  let data = null;
  try { data = JSON.parse(raw); } catch (_) {}
  if (!data || !Array.isArray(data.apps)) {
    showToast({ message: 'Не удалось получить список приложений', type: 'error' });
    renderAtvAppsList([]);
    setAtvLoading(false);
    return;
  }
  atvAppsState.apps = data.apps || [];
  atvAppsState.source = data.source || 'local';
  atvAppsState.sourceLabel = data.sourceLabel || (atvAppsState.source === 'adb' ? 'ADB устройство' : 'Локальное устройство');
  atvAppsState.localIcons = data.localIcons || {};
  atvAppsState.localLabels = data.localLabels || {};
  atvAppsState.localVersions = data.localVersions || {};
  atvAppsState.defaultIcon = data.defaultIcon || null;
  if (data.error) {
    showToast({ message: `Ошибка: ${data.error}`, type: 'warning' });
  }
  setAtvAdbIndicator(data?.adbConnected, atvAppsState.sourceLabel);
  setAtvLoading(false);
  renderAtvAppsList();
}

function setAtvLoading(flag) {
  atvAppsState.loading = !!flag;
  const modal = document.getElementById('atvAppsModal');
  if (modal) {
    modal.classList.toggle('atv-loading-active', !!flag);
  }
  // блокируем нажатия Enter на период загрузки
  if (flag) {
    atvInputBlockUntil = 0;
    document.activeElement?.blur();
    ignoreNextEnter = true;
  } else {
    atvInputBlockUntil = Date.now() + 450;
    setTimeout(() => { ignoreNextEnter = false; }, 120);
  }
  const refreshBtn = document.getElementById('modal-action-atv-refresh');
  if (refreshBtn) refreshBtn.disabled = !!flag;
}

function setAtvAdbIndicator(connected, label) {
  const btn = document.getElementById('atvAdbIndicator');
  if (!btn) return;
  btn.classList.toggle('connected', !!connected);
  btn.classList.toggle('disconnected', !connected);
  const img = btn.querySelector('img');
  if (img) {
    img.src = connected
      ? 'https://appassets.androidplatform.net/assets/webview/icons/network/ic_ADB_on.png'
      : 'https://appassets.androidplatform.net/assets/webview/icons/network/ic_ADB_off.png';
    img.alt = connected ? 'ADB подключен' : 'ADB не подключен';
  }
  btn.title = label || (connected ? 'ADB подключен' : 'ADB не подключен');
}

function getFilteredAtvApps() {
  const f = atvAppsState.filter;
  if (f === 'all') return atvAppsState.apps;
  if (f === 'user') return atvAppsState.apps.filter(a => a.type === 'user');
  if (f === 'system') return atvAppsState.apps.filter(a => a.type === 'system');
  if (f === 'system_launchable') return atvAppsState.apps.filter(a => a.type === 'system' && a.launchable === true);
  if (f === 'disabled') return atvAppsState.apps.filter(a => a.state === 'disabled');
  if (f === 'deleted') return atvAppsState.apps.filter(a => a.state === 'deleted');
  return atvAppsState.apps;
}

function renderAtvAppsList() {
  const list = document.getElementById('atvAppsList');
  if (!list) return;
  list.innerHTML = '';
  if (atvAppsState.loading) {
    list.innerHTML = atvLoadingHtml;
    return;
  }
  const apps = getFilteredAtvApps();
  if (!apps.length) {
    list.innerHTML = '<div style="text-align:center; opacity:0.7;">Список пуст</div>';
    return;
  }

  // Сортировка по алфавиту (по label или package)
  const sortedApps = [...apps].sort((a, b) => {
    const nameA = (a.label || atvAppsState.localLabels?.[a.package] || a.package).toLowerCase();
    const nameB = (b.label || atvAppsState.localLabels?.[b.package] || b.package).toLowerCase();
    return nameA.localeCompare(nameB, 'ru');
  });

  sortedApps.forEach(app => {
    const row = document.createElement('div');
    row.className = 'app-row';
    row.tabIndex = 0;
    row.onclick = () => openAtvAppActions(app);
    row.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); openAtvAppActions(app); } };
    row.onfocus = () => {
      document.querySelectorAll('#atvAppsList .app-row').forEach(r => r.classList.remove('selected'));
      row.classList.add('selected');
      row.scrollIntoView({ block: 'nearest' });
      atvLastFocusedAppEl = row;
    };
    row.onblur = () => row.classList.remove('selected');

    const img = document.createElement('img');
    img.className = 'app-icon';
    img.loading = 'lazy';
    const fallbackIcon = atvAppsState.defaultIcon || atvDefaultIcons[app.type === 'system' ? 'system' : 'user'];
    const localIcon = atvAppsState.localIcons?.[app.package];
    img.src = app.icon || localIcon || fallbackIcon;
    img.alt = app.label || app.package;

    const meta = document.createElement('div');
    meta.className = 'app-meta';

    const title = document.createElement('div');
    title.className = 'app-title';
    const localLabel = atvAppsState.localLabels?.[app.package];
    title.textContent = app.label || localLabel || app.package;

    const sub = document.createElement('div');
    sub.className = 'app-sub';

    const left = document.createElement('div');
    left.style.display = 'flex';
    left.style.flexDirection = 'column';
    left.style.gap = '2px';
    left.style.maxWidth = '70%';

    const pkg = document.createElement('span');
    pkg.textContent = app.package;
    pkg.style.whiteSpace = 'normal';
    pkg.style.wordBreak = 'break-all';

    const versionText = app.version || atvAppsState.localVersions?.[app.package];
    const version = document.createElement('span');
    version.textContent = versionText ? `v${versionText}` : '';
    version.style.opacity = '0.85';
    const state = document.createElement('span');
    state.className = 'app-state';
    const isDisabled = app.state === 'disabled';
    const isDeleted = app.state === 'deleted';
    if (isDisabled || isDeleted) {
      state.textContent = isDeleted ? 'удалено' : 'отключено';
      state.style.display = 'inline-flex';
      state.style.alignItems = 'center';
      state.style.gap = '4px';
      state.style.padding = '2px 8px';
      state.style.borderRadius = '10px';
      state.style.fontWeight = '700';
      state.style.textTransform = 'uppercase';
      state.style.fontSize = '11px';
      state.style.background = isDeleted ? 'red' : '#e66909';
      state.style.color = '#000';
    } else {
      state.textContent = '';
    }

    const bottomLine = document.createElement('div');
    bottomLine.style.display = 'flex';
    bottomLine.style.alignItems = 'center';
    bottomLine.style.gap = '6px';
    if (version.textContent) bottomLine.appendChild(version);
    if (state.textContent) bottomLine.appendChild(state);

    left.appendChild(pkg);
    if (bottomLine.children.length) left.appendChild(bottomLine);

    const badge = document.createElement('span');
    badge.className = 'app-badge';
    badge.classList.add(app.type === 'system' ? 'badge-system' : 'badge-user');
    badge.textContent = app.type === 'system' ? 'system' : 'user';

    sub.appendChild(left);
    sub.appendChild(badge);

    meta.appendChild(title);
    meta.appendChild(sub);

    row.appendChild(img);
    row.appendChild(meta);
    list.appendChild(row);
  });
}

function dumpLocalApps() {
  try {
    const msg = window.AndroidInterface?.dumpLocalAppsToDownloads?.() || '';
    showToast({ message: msg || 'Готово', type: 'info', position: 'top-center' });
  } catch (e) {
    console.warn('dumpLocalApps error', e);
    showToast({ message: 'Ошибка дампа', type: 'error', position: 'top-center' });
  }
}

let atvSelectedApp = null;
function openAtvAppActions(app) {
  if (isAtvInputBlocked()) return;
  atvSelectedApp = app;
  // запоминаем текущую строку списка для восстановления фокуса после закрытия
  if (!atvLastFocusedAppEl) {
    const activeRow = document.activeElement?.closest?.('.app-row');
    if (activeRow) atvLastFocusedAppEl = activeRow;
  }
  const modal = document.getElementById('atvAppActionsModal');
  if (!modal) return;
  const parentModal = document.getElementById('atvAppsModal');
  if (parentModal && parentModal.style.display === 'flex') {
    modal.dataset.restoreParent = '1';
    parentModal.setAttribute('inert', '');
    parentModal.style.pointerEvents = 'none';
  } else {
    modal.dataset.restoreParent = '0';
  }
  const title = document.getElementById('atvAppActionsTitle');
  if (title) {
    const iconSrc = app.icon
      || atvAppsState.localIcons?.[app.package]
      || atvAppsState.defaultIcon
      || atvDefaultIcons[app.type === 'system' ? 'system' : 'user'];
    const label = app.label || app.package;
    title.style.display = 'inline-flex';
    title.style.alignItems = 'center';
    title.style.justifyContent = 'center';
    title.style.gap = '8px';
    title.style.width = '100%';
    title.style.textAlign = 'center';
    title.innerHTML = iconSrc
      ? `<img src="${iconSrc}" alt="" style="height:22px;width:22px;object-fit:contain;"> <span>${label}</span>`
      : label;
  }
  const info = document.getElementById('atvAppActionsInfo');
  if (info) {
    const typeBadge = `
      <span style="display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:12px;
        background:${app.type === 'system' ? '#d0a447' : '#2abf6d'}; color:#000; font-weight:700; text-transform:uppercase; font-size:12px;">
        ${app.type === 'system' ? 'system' : 'user'}
      </span>`;
    const stateBadge = (app.state === 'disabled' || app.state === 'deleted') ? `
      <span style="display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:12px;
        background:${app.state === 'deleted' ? 'red' : '#e66909'}; color:#000; font-weight:700; text-transform:uppercase; font-size:12px;">
        ${app.state === 'deleted' ? 'удалено' : 'отключено'}
      </span>` : '';
    info.innerHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;gap:4px;flex-wrap:wrap;justify-content:center;color:#fff; margin-top:-4px;">
        <span style="color:#fff; font-size:11px; opacity:0.9; text-align:center;">${app.package}</span>
        <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;justify-content:center;">
          ${typeBadge}
          ${stateBadge}
        </div>
      </div>
    `;
  }

  const buttons = document.getElementById('atvAppActionsButtons');
  if (buttons) {
    buttons.innerHTML = '';
    
    // Для удалённых приложений показываем только "Включить" (восстановление)
    if (app.state === 'deleted') {
      buttons.appendChild(makeAtvActionBtn('enable', 'Включить'));
    } 
    // Для отключённых: "Включить" + "Открыть" + "Очистить данные"
    else if (app.state === 'disabled') {
      buttons.appendChild(makeAtvActionBtn('enable', 'Включить'));
      buttons.appendChild(makeAtvActionBtn('open', 'Открыть'));
      buttons.appendChild(makeAtvActionBtn('clear', 'Очистить данные'));
    } 
    // Для включённых: "Отключить" + "Открыть" + "Очистить данные" + "Отключить с очисткой"
    else {
      buttons.appendChild(makeAtvActionBtn('disable', 'Отключить'));
      buttons.appendChild(makeAtvActionBtn('open', 'Открыть'));
      buttons.appendChild(makeAtvActionBtn('clear', 'Очистить данные'));
      buttons.appendChild(makeAtvActionBtn('disable_clear', 'Отключить с очисткой'));
    }
    
    // Удаление доступно для user всегда, для system только по ADB, и не для deleted
    const allowDelete = (app.type === 'user') || (atvAppsState.source === 'adb');
    if (allowDelete && app.state !== 'deleted') {
      buttons.appendChild(makeAtvActionBtn('delete', 'Удалить'));
    }
    
    // Сохранение APK доступно только для не-deleted
    if (app.state !== 'deleted') {
      buttons.appendChild(makeAtvActionBtn('save', 'Сохранить (APK)'));
    }
    // Инфо по пакету — только для не-deleted
    if (app.state !== 'deleted') {
      buttons.appendChild(makeAtvActionBtn('info', 'Инфо'));
    }
  }

  modal.style.display = 'flex';
  document.body.classList.add('modal-open');
}

function closeAtvAppActions() {
  const modal = document.getElementById('atvAppActionsModal');
  if (!modal) return;
  modal.style.display = 'none';
  modal.style.zIndex = '';
  
  // Если есть открытая модалка ATV Apps, возвращаем на неё modal-open
  const parentModal = document.getElementById('atvAppsModal');
  if (parentModal && parentModal.style.display === 'flex') {
    if (modal.dataset.restoreParent === '1') {
      parentModal.removeAttribute('inert');
      parentModal.style.pointerEvents = '';
      modal.dataset.restoreParent = '0';
    }
    document.body.classList.add('modal-open');

    // возвращаем фокус на последнюю выбранную строку списка
    if (atvLastFocusedAppEl && document.body.contains(atvLastFocusedAppEl)) {
      const container = document.getElementById('atvAppsContainer');
      if (container) {
        const cr = container.getBoundingClientRect();
        const er = atvLastFocusedAppEl.getBoundingClientRect();
        if (er.top < cr.top + 12) container.scrollTop -= (cr.top + 12 - er.top);
        else if (er.bottom > cr.bottom - 12) container.scrollTop += (er.bottom - (cr.bottom - 12));
      }
      requestAnimationFrame(() => atvLastFocusedAppEl?.focus({ preventScroll: true }));
    }
  } else {
    document.body.classList.remove('modal-open');
  }
}

function makeAtvActionBtn(action, label) {
  const btn = document.createElement('button');
  btn.className = 'sys-btn';
  btn.textContent = label;
  btn.onclick = (e) => { e.stopPropagation(); handleAtvAppAction(action); };
  return btn;
}

function handleAtvAppAction(action) {
  if (!atvSelectedApp) return;
  if (action === 'info') {
    try {
      window.AndroidInterface?.openSettingsForPackage?.(atvSelectedApp.package);
    } catch (_) {}
    closeAtvAppActions();
    return;
  }
  if (action === 'disable' || action === 'disable_clear' || action === 'enable' || action === 'delete' || action === 'clear') {
    const name = atvSelectedApp.label || atvSelectedApp.package;
    try {
      window.AndroidInterface?.confirmAndPerformAppAction?.(
        action,
        atvSelectedApp.package,
        name,
        atvAppsState.source
      );
    } catch (_) {
      // fallback: ничего
    }
    return;
  }
  // Для прочих действий — старая логика без подтверждения
  try {
    const raw = window.AndroidInterface?.performAppAction?.(action, atvSelectedApp.package, atvAppsState.source) || '{"success":false}';
    let data = null;
    try { data = JSON.parse(raw); } catch (_) {}
    const ok = data?.success;
    const msg = data?.message || (ok ? 'Готово' : 'Ошибка');
    if (ok) {
      showToast?.({ message: `✅ ${msg}`, type: 'success' });
    } else {
      showToast?.({ message: `❌ ${msg}`, type: 'error' });
    }
  } catch (e) {
    showToast?.({ message: '❌ Ошибка выполнения', type: 'error' });
  } finally {
    closeAtvAppActions();
    if (atvSelectedApp) {
    const targetState =
      action === 'enable' ? 'enabled' :
      (action === 'disable' || action === 'disable_clear') ? 'disabled' :
      action === 'delete' ? 'deleted' :
      atvSelectedApp.state;

      const apps = atvAppsState.apps || [];
      const idx = apps.findIndex(a => a.package === atvSelectedApp.package);
      if (idx !== -1) {
        apps[idx] = { ...apps[idx], state: targetState };
        atvAppsState.apps = apps;
        renderAtvAppsList();
      }
    }
  }
}

// Оптимистичное обновление состояния приложения в списке (используется после подтверждения в native диалоге)
window.applyAtvActionState = function(action, pkg) {
  const apps = atvAppsState.apps || [];
  const idx = apps.findIndex(a => a.package === pkg);
  if (idx === -1) return;
  const targetState =
    action === 'enable' ? 'enabled' :
    (action === 'disable' || action === 'disable_clear') ? 'disabled' :
    action === 'delete' ? 'deleted' :
    apps[idx].state;
  apps[idx] = { ...apps[idx], state: targetState };
  atvAppsState.apps = apps;
  renderAtvAppsList();
};

const launcherState = {
  items: [],
  loading: false,
  sourceLabel: 'ADB устройство',
  adbConnected: false
};
let launcherSelectedItem = null;
let launcherLastFocusedEl = null;

function openLaunchersModal(btn) {
  ignoreNextEnter = true;
  if (!isAdbSessionConnected()) {
    showToast({ message: 'ADB не подключен', type: 'warning', position: 'top-center' });
    ignoreNextEnter = false;
    return;
  }

  const modal = document.getElementById('launcherModal');
  if (!modal) return;

  const header = document.getElementById('launcherHeader');
  const iconSrc = btn?.querySelector('img')?.src || 'https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png';
  if (header) {
    header.innerHTML = `<img src="${iconSrc}" alt="" style="height:22px; vertical-align:middle; margin-right:6px;">Лаунчеры`;
  }

  document.activeElement?.blur();
  modal.style.display = 'flex';
  document.body.classList.add('modal-open');
  refreshLaunchersList();

  setTimeout(() => {
    const first = modal.querySelector('#launcherList .app-row');
    if (first) first.focus({ preventScroll: true });
    else modal.focus();
  }, 120);
}

function closeLaunchersModal() {
  const modal = document.getElementById('launcherModal');
  if (!modal) return;
  modal.style.display = 'none';
  modal.style.zIndex = '';
  closeLauncherActions();
  if (!anyModalOpen()) {
    document.body.classList.remove('modal-open');
  }
  setTimeout(() => {
    ignoreNextEnter = false;
  }, 100);
}

function refreshLaunchersList() {
  setLauncherLoading(true);
  renderLaunchersList();
  setTimeout(() => {
    try {
      const raw = window.AndroidInterface?.getHomeLaunchersInventory?.() || '';
      handleLaunchersPayload(raw);
    } catch (e) {
      handleLaunchersPayload('{}');
      console.warn('getHomeLaunchersInventory error', e);
      showToast?.({ message: '❌ Ошибка получения лаунчеров', type: 'error' });
    }
  }, 30);
}

function handleLaunchersPayload(raw) {
  let data = null;
  try { data = JSON.parse(raw); } catch (_) {}
  if (!data || !Array.isArray(data.launchers)) {
    showToast({ message: 'Не удалось получить список лаунчеров', type: 'error' });
    launcherState.items = [];
    setLauncherLoading(false);
    renderLaunchersList();
    return;
  }

  launcherState.items = data.launchers || [];
  launcherState.sourceLabel = data.sourceLabel || 'ADB устройство';
  launcherState.adbConnected = !!data.adbConnected;
  if (data.error) {
    if (!launcherState.items.length) {
      showToast({ message: `Ошибка: ${data.error}`, type: 'warning' });
    } else {
      console.warn('Launcher inventory partial warnings:', data.error);
    }
  }
  setLauncherLoading(false);
  renderLaunchersList();
}

function setLauncherLoading(flag) {
  launcherState.loading = !!flag;
  const modal = document.getElementById('launcherModal');
  if (modal) {
    modal.classList.toggle('launcher-loading-active', !!flag);
  }
  const pickerWrap = document.getElementById('launcherSystemPickerWrap');
  if (pickerWrap) {
    pickerWrap.style.display = flag ? 'none' : 'flex';
  }
  if (flag) {
    ignoreNextEnter = true;
  } else {
    setTimeout(() => { ignoreNextEnter = false; }, 120);
  }
}

function renderLaunchersList() {
  const list = document.getElementById('launcherList');
  if (!list) return;
  list.innerHTML = '';
  if (launcherState.loading) {
    list.innerHTML = launcherLoadingHtml;
    return;
  }
  const items = launcherState.items || [];
  if (!items.length) {
    list.innerHTML = '<div style="text-align:center; opacity:0.7;">Лаунчеры не найдены</div>';
    return;
  }

  const sorted = [...items].sort((a, b) => (a.label || a.package || '').localeCompare((b.label || b.package || ''), 'ru'));
  sorted.forEach(item => {
    const row = document.createElement('div');
    row.className = 'app-row';
    row.tabIndex = 0;
    row.onclick = () => openLauncherActions(item);
    row.onkeydown = (e) => {
      if (e.key === 'Enter' || e.key === 'NumpadEnter' || e.key === 'OK') {
        e.preventDefault();
        openLauncherActions(item);
      }
    };
    row.onfocus = () => {
      document.querySelectorAll('#launcherList .app-row').forEach(r => r.classList.remove('selected'));
      row.classList.add('selected');
      row.scrollIntoView({ block: 'nearest' });
      launcherLastFocusedEl = row;
    };
    row.onblur = () => row.classList.remove('selected');

    const img = document.createElement('img');
    img.className = 'app-icon';
    img.loading = 'lazy';
    img.src = 'https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png';
    img.alt = item.label || item.package;

    const meta = document.createElement('div');
    meta.className = 'app-meta';

    const title = document.createElement('div');
    title.className = 'app-title';
    title.textContent = item.label || item.package || 'launcher';

    const sub = document.createElement('div');
    sub.className = 'app-sub';
    sub.style.display = 'flex';
    sub.style.flexDirection = 'column';
    sub.style.alignItems = 'flex-start';
    sub.style.gap = '3px';

    const pkg = document.createElement('span');
    pkg.textContent = item.package || '';
    pkg.style.wordBreak = 'break-all';
    pkg.style.opacity = '0.88';

    const badges = document.createElement('div');
    badges.style.display = 'flex';
    badges.style.gap = '6px';
    badges.style.flexWrap = 'wrap';

    const typeBadge = document.createElement('span');
    typeBadge.className = 'app-badge';
    typeBadge.classList.add(item.type === 'system' ? 'badge-system' : 'badge-user');
    typeBadge.textContent = item.type === 'system' ? 'system' : 'user';
    badges.appendChild(typeBadge);

    if (item.isActive) {
      const active = document.createElement('span');
      active.className = 'app-badge';
      active.style.background = '#2abf6d';
      active.style.color = '#000';
      active.textContent = 'active';
      badges.appendChild(active);
    }
    if (item.state && item.state !== 'enabled') {
      const state = document.createElement('span');
      state.className = 'app-badge';
      state.style.background = item.state === 'deleted' ? '#ff4d4f' : '#e66909';
      state.style.color = '#000';
      state.textContent = item.state;
      badges.appendChild(state);
    }

    sub.appendChild(pkg);
    sub.appendChild(badges);

    meta.appendChild(title);
    meta.appendChild(sub);
    row.appendChild(img);
    row.appendChild(meta);
    list.appendChild(row);
  });
}

function openLauncherActions(item) {
  launcherSelectedItem = item;
  if (!launcherLastFocusedEl) {
    const activeRow = document.activeElement?.closest?.('.app-row');
    if (activeRow) launcherLastFocusedEl = activeRow;
  }
  const modal = document.getElementById('launcherActionsModal');
  if (!modal) return;
  const parentModal = document.getElementById('launcherModal');
  if (parentModal && parentModal.style.display === 'flex') {
    modal.dataset.restoreParent = '1';
    parentModal.setAttribute('inert', '');
    parentModal.style.pointerEvents = 'none';
  } else {
    modal.dataset.restoreParent = '0';
  }

  const title = document.getElementById('launcherActionsTitle');
  if (title) {
    title.innerHTML = `<img src="https://appassets.androidplatform.net/assets/webview/icons/misc/ic20_ATV.png" alt="" style="height:22px;width:22px;object-fit:contain;"> <span>${item.label || item.package}</span>`;
  }
  const info = document.getElementById('launcherActionsInfo');
  if (info) {
    const safeActivity = item.activity || '-';
    info.innerHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;gap:4px;justify-content:center;">
        <span style="opacity:0.92;">${item.package || ''}</span>
        <span style="opacity:0.72;font-size:12px;word-break:break-all;text-align:center;">${safeActivity}</span>
      </div>
    `;
  }

  const buttons = document.getElementById('launcherActionsButtons');
  if (buttons) {
    buttons.innerHTML = '';
    if (item.state === 'disabled' || item.state === 'deleted') {
      buttons.appendChild(makeLauncherEnableBtn());
    } else {
      buttons.appendChild(makeLauncherDisableBtn());
    }
    buttons.appendChild(makeLauncherActionBtn(false, 'Сделать активным'));
    buttons.appendChild(makeLauncherActionBtn(true, 'Активным + отключить остальные'));
    buttons.appendChild(makeLauncherOpenPickerBtn());
  }

  modal.style.display = 'flex';
  document.body.classList.add('modal-open');
}

function closeLauncherActions() {
  const modal = document.getElementById('launcherActionsModal');
  if (!modal) return;
  modal.style.display = 'none';
  modal.style.zIndex = '';

  const parentModal = document.getElementById('launcherModal');
  if (parentModal && parentModal.style.display === 'flex') {
    if (modal.dataset.restoreParent === '1') {
      parentModal.removeAttribute('inert');
      parentModal.style.pointerEvents = '';
      modal.dataset.restoreParent = '0';
    }
    document.body.classList.add('modal-open');
    if (launcherLastFocusedEl && document.body.contains(launcherLastFocusedEl)) {
      requestAnimationFrame(() => launcherLastFocusedEl?.focus({ preventScroll: true }));
    }
  } else {
    document.body.classList.remove('modal-open');
  }
}

function makeLauncherActionBtn(disableOthers, label) {
  const btn = document.createElement('button');
  btn.className = 'sys-btn';
  btn.textContent = label;
  btn.onclick = (e) => {
    e.stopPropagation();
    handleLauncherAction(disableOthers);
  };
  return btn;
}

function makeLauncherOpenPickerBtn() {
  const btn = document.createElement('button');
  btn.className = 'sys-btn';
  btn.textContent = 'Системный выбор';
  btn.onclick = (e) => {
    e.stopPropagation();
    sendAdbCommand('am start -a android.settings.HOME_SETTINGS', 'Выбор лаунчера', { singleToast: true });
    closeLauncherActions();
  };
  return btn;
}

function makeLauncherEnableBtn() {
  const btn = document.createElement('button');
  btn.className = 'sys-btn';
  btn.textContent = 'Включить';
  btn.onclick = (e) => {
    e.stopPropagation();
    handleLauncherEnableOnly();
  };
  return btn;
}

function makeLauncherDisableBtn() {
  const btn = document.createElement('button');
  btn.className = 'sys-btn';
  btn.textContent = 'Отключить';
  btn.onclick = (e) => {
    e.stopPropagation();
    handleLauncherDisableOnly();
  };
  return btn;
}

function buildLauncherEnableCommand(pkg) {
  const quoted = `"${pkg}"`;
  const base = [
    `cmd package install-existing ${quoted} || pm install-existing ${quoted}`,
    `cmd package enable --user 0 ${quoted}`,
    `pm enable --user 0 ${quoted}`,
    `cmd package enable ${quoted}`
  ];
  if (pkg === 'com.google.android.apps.tv.launcherx' || pkg === 'com.google.android.tvlauncher' || pkg === 'com.android.tvlauncher') {
    base.push(
      'cmd package install-existing --user 0 "com.google.android.tungsten.setupwraith" || pm install-existing --user 0 "com.google.android.tungsten.setupwraith" || cmd package install-existing "com.google.android.tungsten.setupwraith" || pm install-existing "com.google.android.tungsten.setupwraith"',
      'cmd package enable --user 0 "com.google.android.tungsten.setupwraith" || pm enable --user 0 "com.google.android.tungsten.setupwraith" || cmd package enable "com.google.android.tungsten.setupwraith"'
    );
  }
  return base.join('; ');
}

function buildLauncherDisableCommand(pkg) {
  const quoted = `"${pkg}"`;
  const commands = [
    `cmd package disable-user --user 0 ${quoted} || pm disable-user --user 0 ${quoted}`
  ];
  if (pkg === 'com.google.android.apps.tv.launcherx') {
    commands.push('cmd package disable-user --user 0 "com.google.android.tungsten.setupwraith" || pm disable-user --user 0 "com.google.android.tungsten.setupwraith"');
  }
  return commands.join('; ');
}

function handleLauncherEnableOnly() {
  const item = launcherSelectedItem;
  if (!item?.package) return;
  try {
    sendAdbCommand(buildLauncherEnableCommand(item.package), `Включить ${item.label || item.package}`);
    closeLauncherActions();
    setTimeout(() => refreshLaunchersList(), 700);
  } catch (e) {
    console.warn('handleLauncherEnableOnly error', e);
    showToast({ message: '❌ Не удалось включить лаунчер', type: 'error' });
  }
}

function handleLauncherDisableOnly() {
  const item = launcherSelectedItem;
  if (!item?.package) return;
  try {
    window.AndroidInterface?.confirmAndDisableHomeLauncher?.(
      item.package,
      item.label || item.package
    );
  } catch (e) {
    console.warn('handleLauncherDisableOnly error', e);
    showToast({ message: '❌ Не удалось отключить лаунчер', type: 'error' });
  }
}

function handleLauncherAction(disableOthers) {
  const item = launcherSelectedItem;
  if (!item?.package) return;
  try {
    window.AndroidInterface?.confirmAndSetHomeLauncher?.(
      item.package,
      item.activity || '',
      item.label || item.package,
      !!disableOthers
    );
  } catch (e) {
    console.warn('confirmAndSetHomeLauncher error', e);
    showToast({ message: '❌ Не удалось отправить команду', type: 'error' });
  }
}

window.applyLauncherActiveState = function(pkg) {
  const items = launcherState.items || [];
  launcherState.items = items.map((it) => {
    if (it.package === pkg) return { ...it, isActive: true, state: 'enabled' };
    return { ...it, isActive: false };
  });
  renderLaunchersList();
};

// Back/Escape закрывают модалки
document.addEventListener('keydown', function(e) {
  if (e.key === 'Back' || e.key === 'Escape') {
    const launcherActions = document.getElementById('launcherActionsModal');
    const launcherMain = document.getElementById('launcherModal');
    if (launcherActions && launcherActions.style.display === 'flex') {
      e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
      closeLauncherActions(); return;
    }
    if (launcherMain && launcherMain.style.display === 'flex') {
      e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
      closeLaunchersModal(); return;
    }
    const actions = document.getElementById('atvAppActionsModal');
    const main = document.getElementById('atvAppsModal');
    if (actions && actions.style.display === 'flex') {
      e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
      closeAtvAppActions(); return;
    }
    if (main && main.style.display === 'flex') {
      e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
      closeAtvAppsModal(); return;
    }
  }
}, true);

// Закрытие по native back через AndroidInterface, если доступно
window.AndroidInterface?.registerOnBackPressed?.("atvAppsBackHandler");
window.atvAppsBackHandler = function() {
  const launcherActions = document.getElementById('launcherActionsModal');
  const launcherMain = document.getElementById('launcherModal');
  if (launcherActions && launcherActions.style.display === 'flex') {
    closeLauncherActions();
    return true;
  }
  if (launcherMain && launcherMain.style.display === 'flex') {
    closeLaunchersModal();
    return true;
  }
  const actions = document.getElementById('atvAppActionsModal');
  const main = document.getElementById('atvAppsModal');
  if (actions && actions.style.display === 'flex') {
    closeAtvAppActions();
    return true;
  }
  if (main && main.style.display === 'flex') {
    closeAtvAppsModal();
    return true;
  }
  return false;
};
</script>

<!-- Модалка настроек метода установки  -->
<div id="installMethodModal" class="modal" style="display:none;" tabindex="-1">
  <div class="modal-content">
    <h3>Способ установки:</h3>
    <div class="install-method-settings">
      <div class="method-option" onclick="selectInstallMethod('sai', this)" tabindex="0">
        <input type="radio" id="method_sai" name="install_method" value="sai" checked tabindex="-1">
        <label for="method_sai">
          <strong>Быстрая установка</strong><br>
          <small>FAST-метод (рекомендуется)</small>
        </label>
      </div>
      <div class="method-option" onclick="selectInstallMethod('standard', this)" tabindex="0">
        <input type="radio" id="method_standard" name="install_method" value="standard" tabindex="-1">
        <label for="method_standard">
          <strong>Стандартная установка</strong><br>
          <small>Встроенный установщик пакетов</small>
        </label>
      </div>
      <div class="method-option" onclick="selectInstallMethod('adb', this)" tabindex="0">
        <input type="radio" id="method_adb" name="install_method" value="adb" tabindex="-1">
        <label for="method_adb">
          <strong>Установка через ADB</strong><br>
          <small>Требуется в меню для разработчиков включить «Отладку по USB</small>
        </label>
      </div>
    </div>
  </div>
</div>
  
  
</body>
</html>
