package com.filin4ik.fastInstaller

import android.Manifest
import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.content.pm.PackageManager
import android.net.Uri
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.nsd.NsdManager
import android.net.nsd.NsdServiceInfo
import android.net.wifi.WifiManager
import android.os.*
import android.os.StatFs
import android.os.SystemClock
import android.os.Environment
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.FileProvider
import org.json.JSONArray
import org.json.JSONObject
import org.xmlpull.v1.XmlPullParser
import org.xmlpull.v1.XmlPullParserFactory
import java.io.*
import java.net.DatagramPacket
import java.net.DatagramSocket
import java.net.HttpURLConnection
import java.net.InetAddress
import java.net.URL
import java.net.SocketTimeoutException
import android.webkit.JavascriptInterface
import android.webkit.WebResourceError
import android.webkit.WebResourceRequest
import android.webkit.WebResourceResponse
import android.webkit.WebSettings
import android.webkit.WebView
import android.webkit.WebViewClient
import android.webkit.SslErrorHandler
import android.net.http.SslError
import androidx.webkit.WebViewAssetLoader
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import android.provider.Settings
import android.provider.OpenableColumns
import android.app.Activity
import android.content.pm.ApplicationInfo
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.drawable.BitmapDrawable
import android.graphics.drawable.Drawable
import android.graphics.Color
import android.util.Base64
import android.util.Log
import android.view.KeyEvent
import android.view.View
import android.widget.Toast
import android.widget.LinearLayout
import android.widget.EditText
import android.widget.ProgressBar
import android.widget.TextView
import android.text.InputType
import kotlin.math.roundToInt
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.IntentFilter
import android.content.pm.PackageInstaller
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.Executors
import java.util.concurrent.RejectedExecutionException
import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.ScheduledFuture
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicLong
import androidx.core.net.toUri
import androidx.core.content.edit
import androidx.core.graphics.createBitmap
import android.view.Gravity
import android.widget.ImageView
import android.widget.ImageButton
import android.widget.RelativeLayout
import android.graphics.drawable.Animatable
import android.content.ActivityNotFoundException
import android.content.ComponentName
import java.util.zip.ZipInputStream
import java.util.zip.ZipEntry
import dadb.AdbKeyPair
import dadb.Dadb
import okio.Buffer
import okio.ForwardingSource
import okio.source
import okio.Source
import okio.Timeout
import java.net.Socket
import java.net.InetSocketAddress
import java.net.NetworkInterface
import java.net.Inet4Address
import java.util.Locale
import java.util.UUID
import java.util.Collections
import kotlin.math.roundToLong
import android.view.LayoutInflater
import android.widget.Button
import com.filin4ik.fastInstaller.AutostartService

private const val START_URL = "https://f4iptv.github.io/Play/old/index.html"
private const val OFFLINE_PAGE_URL = "file:///android_asset/offline.html"
private const val DEVICE_DISCOVERY_TAG = "DeviceDiscovery"
private const val ADB_LOG_TAG = "FastInstallerADB"
private val KNOWN_DREAM_COMPONENTS = mapOf(
    "com.neilturner.aerialviews" to "com.neilturner.aerialviews/.ui.screensaver.DreamActivity",
    "com.codingbuffalo.aerialdream" to "com.codingbuffalo.aerialdream/.AerialDream",
    "com.google.android.backdrop" to "com.google.android.backdrop/com.google.android.backdrop.Backdrop"
)
private val KNOWN_DREAM_LABELS = mapOf(
    "com.neilturner.aerialviews/.ui.screensaver.DreamActivity" to "Aerial Views",
    "com.codingbuffalo.aerialdream/.Aerial Dream" to "Aerial Dream",
    "com.codingbuffalo.aerialdream/.AerialDream" to "Aerial Dream",
    "com.google.android.apps.tv.dreamx/.service.Backdrop" to "–°–∏—Å—Ç–µ–º–Ω–∞—è (Google TV)",
    "com.google.android.backdrop/com.google.android.backdrop.Backdrop" to "–°–∏—Å—Ç–µ–º–Ω–∞—è (Android TV)"
)
private val SYSTEM_DREAM_COMPONENTS = listOf(
    "com.google.android.apps.tv.dreamx/.service.Backdrop",
    "com.google.android.backdrop/com.google.android.backdrop.Backdrop"
)

private data class JsAppEntry(
    val label: String,
    val packageName: String,
    val type: String,   // user | system
    val state: String,  // enabled | disabled | deleted
    val icon: String?,
    val version: String?
)

private fun JsAppEntry.toJson(): JSONObject {
    return JSONObject().apply {
        put("label", label)
        put("package", packageName)
        put("type", type)
        put("state", state)
        icon?.let { put("icon", it) }
        version?.let { put("version", it) }
    }
}

// ‚Äî‚Äî‚Äî InstallMeta + –ø–∞—Ä—Å–∏–Ω–≥ APK ‚Äî‚Äî‚Äî
data class InstallMeta(
    val packageName: String,
    val label: String,
    val iconBase64: String? // –æ—Å—Ç–∞–≤–∏–º –Ω–∞ –±—É–¥—É—â–µ–µ (–ø.5), —Å–µ–π—á–∞—Å –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º
)

private data class ScreenSaverState(
    val enabled: Boolean,
    val currentLabel: String,
    val screenTimeoutMs: Long?,
    val sleepTimeoutMs: Long?,
    val component: String?
)

private data class StorageUsage(
    val usedBytes: Long,
    val totalBytes: Long
)

private fun extractApkMeta(context: Context, apkFile: File): InstallMeta {
    val pm = context.packageManager
    val pkgInfo = pm.getPackageArchiveInfo(apkFile.absolutePath, 0)

    val fallback = apkFile.nameWithoutExtension
    if (pkgInfo == null || pkgInfo.applicationInfo == null) {
        // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ —Å–º–æ–≥–ª–∏ –ø—Ä–æ—á–∏—Ç–∞—Ç—å ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ —Ñ–∞–π–ª—É
        return InstallMeta(
            packageName = fallback,
            label = fallback,
            iconBase64 = null
        )
    }

    val appInfo = pkgInfo.applicationInfo!!

    // –û—á–µ–Ω—å –≤–∞–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø—É—Ç–∏, –∏–Ω–∞—á–µ label –∏ icon –Ω–µ –∑–∞–≥—Ä—É–∑—è—Ç—Å—è
    appInfo.sourceDir = apkFile.absolutePath
    appInfo.publicSourceDir = apkFile.absolutePath

    val label = runCatching {
        pm.getApplicationLabel(appInfo).toString()
    }.getOrElse { fallback }

    val iconBase64 = runCatching {
        val icon = pm.getApplicationIcon(appInfo)
        encodeIconToBase64(icon, 96)
    }.getOrNull()

    return InstallMeta(
        packageName = pkgInfo.packageName ?: fallback,
        label = label,
        iconBase64 = iconBase64
    )
}




/**
 * –ü–æ–ª—É—á–∞–µ callback –æ—Ç PackageInstaller (—á–µ—Ä–µ–∑ —è–≤–Ω—ã–π PendingIntent) –∏
 * —Ä–µ—Ç—Ä–∞–Ω—Å–ª–∏—Ä—É–µ—Ç –µ–≥–æ –≤–Ω—É—Ç—Ä—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–∞ –Ω–∞—à ACTION, —á—Ç–æ–±—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π
 * —Ä–µ—Å–∏–≤–µ—Ä –≤ SessionApkInstaller –ø—Ä–∏–Ω—è–ª –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–µ extras.
 */


private fun drawableToBitmap(drawable: Drawable, width: Int? = null, height: Int? = null): Bitmap {
    if (drawable is BitmapDrawable && drawable.bitmap != null) return drawable.bitmap
    val w = width ?: (drawable.intrinsicWidth.takeIf { it > 0 } ?: 96)
    val h = height ?: (drawable.intrinsicHeight.takeIf { it > 0 } ?: 96)
    val bmp = createBitmap(w, h)
    val canvas = Canvas(bmp)
    drawable.setBounds(0, 0, canvas.width, canvas.height)
    drawable.draw(canvas)
    return bmp
}

private fun encodeIconToBase64(icon: Drawable, targetSizePx: Int = 96): String {
    val bmp = drawableToBitmap(icon, targetSizePx, targetSizePx)
    val out = ByteArrayOutputStream()
    bmp.compress(Bitmap.CompressFormat.PNG, 100, out)
    return Base64.encodeToString(out.toByteArray(), Base64.NO_WRAP)
}

private fun String.htmlEscape(): String =
    this.replace("&","&amp;").replace("<","&lt;").replace(">","&gt;")

private fun String.jsEscape(): String =
    this.replace("\\", "\\\\")
        .replace("'", "\\'")
        .replace("\"", "\\\"")
        .replace("\n", "\\n")
        .replace("\r", "\\r")
        .replace("\t", "\\t")




/**
 * –ü–æ–ª—É—á–∞–µ—Ç callback –æ—Ç PackageInstaller (—á–µ—Ä–µ–∑ —è–≤–Ω—ã–π PendingIntent) –∏
 * —Ä–µ—Ç—Ä–∞–Ω—Å–ª–∏—Ä—É–µ—Ç –µ–≥–æ –≤–Ω—É—Ç—Ä—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–∞ –Ω–∞—à ACTION, —á—Ç–æ–±—ã –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π
 * —Ä–µ—Å–∏–≤–µ—Ä –≤ SessionApkInstaller –ø—Ä–∏–Ω—è–ª –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–µ extras.
 */
class InstallStatusRelay : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        // –ë–µ—Ä—ë–º –≤—Å–µ extras –∫–∞–∫ –µ—Å—Ç—å –∏ –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º –≤–Ω—É—Ç—Ä—å –ø–∞–∫–µ—Ç–∞
        val relay = Intent(SessionApkInstaller.ACTION_INSTALL_STATUS(context))
            .setPackage(context.packageName)
            .putExtras(intent)
        context.sendBroadcast(relay)
    }
}

// –î–ª—è –æ—á–µ—Ä–µ–¥–∏: —Ñ–∞–π–ª + —Å–ø–æ—Å–æ–± —É—Å—Ç–∞–Ω–æ–≤–∫–∏ (—á–µ—Ä–µ–∑ —Å–µ—Å—Å–∏—é –∏–ª–∏ –æ–±—ã—á–Ω—ã–π)
data class QueueItem(val file: File, val viaSession: Boolean)

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è URL —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
data class DownloadUrlItem(
    val url: String,
    val fileName: String,
    val viaSession: Boolean
)

data class DeviceIdentity(
    val friendlyName: String,
    val source: String,
    val lastUpdated: Long
)

data class AdbScanHost(
    val ip: String,
    val port: Int = 5555,
    val latencyMs: Int? = null,
    val friendlyName: String? = null
)

private data class AdbCopyEntry(
    val url: String,
    val targetFolder: String,
    val remoteName: String
)

data class BackupRecord(
    val id: String = UUID.randomUUID().toString(),
    val deviceId: String,
    val sessionId: String,
    val path: String,
    val isRemote: Boolean,
    val timestamp: Long = System.currentTimeMillis()
)

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã—Ö —Å–µ—Å—Å–∏–π
data class PreparedSession(
    val sessionId: Int, 
    val session: PackageInstaller.Session, 
    val meta: InstallMeta
)

data class ToggleRequest(
    val packages: List<String>,
    val disable: Boolean
)


private data class WebViewMeta(
    val packageName: String,
    val versionCode: Long,
    val versionName: String,
    val apkUrl: String
)




// ‚Äî‚Äî‚Äî ADB Connection Manager (RSA) ‚Äî‚Äî‚Äî
class AdbConnectionManager(private val context: Context) {
    private var dadb: Dadb? = null
    private var adbKeyPair: AdbKeyPair? = null
    private var isConnected = false
    @Volatile private var awaitingAuth = false
    private var lastHost: String = ""
    private var lastPort: Int = 0
    private var remoteSdkVersion: Int? = null
    private var lastRemoteSdkQueryMs: Long = 0L
    private val adbOperationLock = Any()
    private val privateKeyFile = File(context.filesDir, "adbkey")
    private val publicKeyFile = File(context.filesDir, "adbkey.pub")

    data class ConnectionStatus(
        val isConnected: Boolean,
        val host: String = "",
        val port: Int = 0,
        val error: String? = null
    )

    companion object {
        const val DEFAULT_PORT = 5555
        const val LOCAL_HOST = "127.0.0.1"
        private const val STREAMING_INSTALL_MIN_SDK = Build.VERSION_CODES.Q
        private const val REMOTE_SDK_CACHE_TTL_MS = 30_000L
        private const val REMOTE_TMP_DIR = "/data/local/tmp/fastinstaller"
        private const val TRANSFER_BUFFER_SIZE = 512 * 1024 // 512KB chunks
        private const val PROGRESS_UPDATE_STEP = 5
    }

    @Synchronized
    private fun ensureAdbKeyPair(): AdbKeyPair {
        adbKeyPair?.let { return it }

        if (!privateKeyFile.exists() || !publicKeyFile.exists()) {
            generateKeyPair()
        }

        val pair = runCatching { AdbKeyPair.read(privateKeyFile, publicKeyFile) }
            .getOrElse {
                generateKeyPair()
                AdbKeyPair.read(privateKeyFile, publicKeyFile)
            }
        adbKeyPair = pair
        return pair
    }

    private fun generateKeyPair() {
        runCatching { privateKeyFile.parentFile?.mkdirs() }
        runCatching { AdbKeyPair.generate(privateKeyFile, publicKeyFile) }
            .onFailure {
                runCatching { privateKeyFile.delete() }
                runCatching { publicKeyFile.delete() }
                AdbKeyPair.generate(privateKeyFile, publicKeyFile)
            }
    }

    @Synchronized
    fun connect(host: String = "127.0.0.1", port: Int = DEFAULT_PORT): ConnectionStatus {
        return try {
            disconnect()
            val keyPair = ensureAdbKeyPair()
            dadb = Dadb.create(host, port, keyPair)
            isConnected = true
            awaitingAuth = true
            setPreferredTarget(host, port)
            remoteSdkVersion = null
            lastRemoteSdkQueryMs = 0L
            ConnectionStatus(true, host, port, null)
        } catch (e: Exception) {
            ConnectionStatus(false, error = e.message)
        }
    }

    fun silentPing(): Boolean {
        val device = dadb ?: return false
        return try {
            device.shell("echo ping >/dev/null")
            awaitingAuth = false
            true
        } catch (_: Exception) {
            false
        }
    }

    @Synchronized
    fun ensureConnected(onProgress: ((String) -> Unit)? = null): Boolean {
        if (isConnected && dadb != null) {
            if (awaitingAuth) return true
            if (silentPing()) return true
            disconnect()
        }
        onProgress?.invoke("üîå –ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ ADB‚Ä¶")

        val targetHost = lastHost.ifBlank { LOCAL_HOST }
        val targetPort = if (lastPort > 0) lastPort else DEFAULT_PORT

        val st = connect(targetHost, targetPort)
        if (st.isConnected) {
            onProgress?.invoke("‚úÖ ADB –ø–æ–¥–∫–ª—é—á–µ–Ω: ${st.host}:${st.port}")
            return true
        }
        onProgress?.invoke("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è: ${st.error ?: "unknown"}")
        return false
    }

    @Synchronized
    fun disconnect(resetPreferredTarget: Boolean = false) {
        runCatching { dadb?.close() }
        dadb = null
        isConnected = false
        awaitingAuth = false
        remoteSdkVersion = null
        lastRemoteSdkQueryMs = 0L
        if (resetPreferredTarget) {
            lastHost = ""
            lastPort = 0
        }
    }

    @Synchronized
    fun setPreferredTarget(host: String, port: Int = DEFAULT_PORT) {
        lastHost = host
        lastPort = port
    }

    @Synchronized
    fun resetPreferredTarget() {
        lastHost = ""
        lastPort = 0
    }

    @Synchronized
    fun preferLocalTarget() {
        setPreferredTarget(LOCAL_HOST, DEFAULT_PORT)
    }

    @Synchronized
    fun getRemoteSdkVersion(forceRefresh: Boolean = false): Int? {
        val now = SystemClock.elapsedRealtime()
        val cached = remoteSdkVersion
        if (!forceRefresh && cached != null && now - lastRemoteSdkQueryMs < REMOTE_SDK_CACHE_TTL_MS) {
            return cached
        }
        val device = dadb ?: return cached
        val sdk = runCatching {
            val response = device.shell("getprop ro.build.version.sdk")
            response.allOutput.trim().toIntOrNull()
        }.getOrNull()
        if (sdk != null) {
            remoteSdkVersion = sdk
        }
        lastRemoteSdkQueryMs = now
        return remoteSdkVersion
    }

    private fun isStreamingInstallSupported(forceRefresh: Boolean = false): Pair<Boolean, Int?> {
        val sdk = getRemoteSdkVersion(forceRefresh = forceRefresh || remoteSdkVersion == null)
        val supported = sdk != null && sdk >= STREAMING_INSTALL_MIN_SDK
        return supported to sdk
    }

    // –ö–æ–ø–∏—è ‚Üí —É—Å—Ç–∞–Ω–æ–≤–∫–∞ pm install -r -d -—Ç
    fun installApk(apkFile: File, onProgress: (String) -> Unit = {}): Boolean {
        if (!ensureConnected(onProgress)) return false
        return try {
            synchronized(adbOperationLock) {
            val totalSize = apkFile.length()
            if (totalSize <= 0L) {
                onProgress("‚ùå –ü—É—Å—Ç–æ–π APK, —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞")
                return false
            }

            // –ò–∑–≤–ª–µ–∫–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ APK –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–∫–æ–Ω–∫–∏
            val meta = extractApkMeta(context, apkFile)
            val iconHtml = if (meta.iconBase64 != null) {
                "<img src='data:image/png;base64,${meta.iconBase64}' style='height:18px; width:18px; object-fit:contain; vertical-align:bottom; margin-left:5px;'>"
            } else {
                "‚¨ÜÔ∏è"
            }

            val installerPkg = context.packageName
            val args = arrayOf("-r", "-d", "-t", "-g", "--user", "0", "-i", installerPkg)

            val device = dadb ?: run {
                onProgress("‚ùå ADB –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω")
                return false
            }

            val (streamingSupported, remoteSdk) = isStreamingInstallSupported(forceRefresh = true)
            onProgress("‚ÑπÔ∏è SDK —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: ${remoteSdk ?: "–Ω–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å"} ‚Üí —Ä–µ–∂–∏–º: ${if (streamingSupported) "streaming" else "legacy"}")

            if (remoteSdk != null && remoteSdk <= Build.VERSION_CODES.P) {
                onProgress("‚ÑπÔ∏è Android ${remoteSdk}, –∏—Å–ø–æ–ª—å–∑—É—é –Ω–∞–¥—ë–∂–Ω—ã–π —Ä–µ–∂–∏–º —É—Å—Ç–∞–Ω–æ–≤–∫–∏‚Ä¶")
                return installApkLegacy(device, apkFile, args, onProgress)
            }

            if (streamingSupported) {
                var sent = 0L
                var lastPercent = -PROGRESS_UPDATE_STEP
                val progressSource = object : ForwardingSource(apkFile.source()) {
                    private val chunk = TRANSFER_BUFFER_SIZE.toLong()
                    override fun read(sink: Buffer, byteCount: Long): Long {
                        val read = super.read(sink, minOf(byteCount, chunk))
                        if (read > 0) {
                            sent += read
                            val percent = (sent * 100 / totalSize).toInt().coerceIn(0, 100)
                            if (percent == 100 || percent - lastPercent >= PROGRESS_UPDATE_STEP) {
                                lastPercent = percent
                                onProgress("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ:$iconHtml $percent%")
                            }
                        }
                        return read
                    }
                }

                val streamingResult = try {
                    progressSource.use {
                        device.install(it, totalSize, *args)
                    }
                    if (lastPercent < 100) {
                        onProgress("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ:$iconHtml 100%")
                    }
                    onProgress("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")
                    true
                } catch (e: Exception) {
                    onProgress("‚ö†Ô∏è –ü–æ—Ç–æ–∫–æ–≤–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å: ${e.message ?: "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"}. –ü–µ—Ä–µ—Ö–æ–∂—É –≤ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π —Ä–µ–∂–∏–º‚Ä¶")
                    null
                }
                if (streamingResult != null) {
                    return streamingResult
                }
            } else {
                onProgress("‚ÑπÔ∏è –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø–æ—Ç–æ–∫–æ–≤—É—é —É—Å—Ç–∞–Ω–æ–≤–∫—É, –∫–æ–ø–∏—Ä—É—é APK –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ‚Ä¶")
            }
            installApkLegacy(device, apkFile, args, onProgress)
            }
        } catch (e: Exception) {
            onProgress("‚ùå–ò—Å–∫–ª—é—á–µ–Ω–∏–µ: ${e.javaClass.simpleName}: ${e.message}")
            return false
        }
    }

    private fun installApkLegacy(
        device: Dadb,
        apkFile: File,
        args: Array<String>,
        onProgress: (String) -> Unit
    ): Boolean {
        val remoteName = "apk_${System.currentTimeMillis()}_${sanitizeRemoteFileName(apkFile.name)}"
        val remotePath = pushFileToDevice(apkFile, REMOTE_TMP_DIR, remoteName, onProgress) ?: return false
        return try {
            val command = buildString {
                append("pm install ")
                args.forEach { append(it).append(' ') }
                append(shellQuote(remotePath))
            }
            val output = device.shell(command).allOutput.trim()
            val success = isInstallSuccess(output)
            if (success) {
                onProgress("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ")
            } else {
                val reason = output.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞" }
                onProgress("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: $reason")
            }
            success
        } finally {
            cleanupRemoteFiles(listOf(remotePath))
        }
    }

    fun runShellCommand(command: String, onProgress: (String) -> Unit = {}): Boolean {
        try {
            if (!ensureConnected(onProgress)) return false
            val response = dadb?.shell(command) ?: return false
            awaitingAuth = false
            val result = response.allOutput.trim()
            if (result.isNotBlank()) {
                onProgress(result)
            }
            if (result.isBlank()) {
                return true
            }
            val normalized = result.lowercase(Locale.ROOT)
            val hasFailure = listOf(
                "fail",
                "failure",
                "exception",
                "error:",
                "not allowed",
                "permission denied",
                "unknown package",
                "could not",
                "invalid",
                "does not exist"
            ).any { normalized.contains(it) }
            return !hasFailure
        } catch (e: Exception) {
            onProgress("‚ùå ADB shell error: ${e.message}")
            return false
        }
    }

    fun installSplitApks(
        apkFiles: List<File>,
        label: String? = null,
        onProgress: (String) -> Unit = {}
    ): Boolean {
        if (apkFiles.isEmpty()) {
            onProgress("‚ùå –ù–µ—Ç APK-—Ñ–∞–π–ª–æ–≤ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏")
            return false
        }
        if (!ensureConnected(onProgress)) return false
        return try {
            synchronized(adbOperationLock) {
            val device = dadb ?: run {
                onProgress("‚ùå ADB –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω")
                return false
            }
            val installerPkg = context.packageName
            val args = arrayOf("-r", "-t", "-g", "--user", "0", "-i", installerPkg)
            val ordered = apkFiles
                .sortedWith(compareBy<File> { if (it.name.equals("base.apk", true)) 0 else 1 }.thenBy { it.name })
            val title = label?.takeIf { it.isNotBlank() } ?: ordered.firstOrNull()?.nameWithoutExtension ?: "–ø–∞–∫–µ—Ç–∞"
            onProgress("üöÄ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–ø–ª–∏—Ç–æ–≤: $title")
            val (streamingSupported, remoteSdk) = isStreamingInstallSupported(forceRefresh = true)
            onProgress("‚ÑπÔ∏è SDK —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: ${remoteSdk ?: "–Ω–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å"} ‚Üí —Ä–µ–∂–∏–º: ${if (streamingSupported) "streaming" else "legacy"}")
            if (streamingSupported) {
                val streamingResult = try {
                    device.installMultiple(ordered, *args)
                    onProgress("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: $title")
                    true
                } catch (e: Exception) {
                    onProgress("‚ö†Ô∏è –ü–æ—Ç–æ–∫–æ–≤–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å: ${e.message ?: "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"}. –ü–µ—Ä–µ—Ö–æ–∂—É –≤ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π —Ä–µ–∂–∏–º‚Ä¶")
                    null
                }
                if (streamingResult != null) {
                    return streamingResult
                }
            } else {
                onProgress("‚ÑπÔ∏è –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ø–æ—Ç–æ–∫–æ–≤—É—é —É—Å—Ç–∞–Ω–æ–≤–∫—É, –≤—ã–≥—Ä—É–∂–∞—é APK —á–µ—Ä–µ–∑ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–π —Ä–µ–∂–∏–º‚Ä¶")
            }

            installSplitApksLegacy(device, ordered, args, title, onProgress)
            }
        } catch (e: Exception) {
            onProgress("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: ${e.message}")
            false
        }
    }

    private fun installSplitApksLegacy(
        device: Dadb,
        apkFiles: List<File>,
        args: Array<String>,
        title: String,
        onProgress: (String) -> Unit
    ): Boolean {
        val remotePaths = mutableListOf<String>()
        try {
            apkFiles.forEachIndexed { index, file ->
                val remoteName = "split_${index}_${System.currentTimeMillis()}_${sanitizeRemoteFileName(file.name)}"
                val remotePath = pushFileToDevice(file, REMOTE_TMP_DIR, remoteName, onProgress) ?: return false
                remotePaths += remotePath
            }

            val command = buildString {
                append("pm install-multiple ")
                args.forEach { append(it).append(' ') }
                remotePaths.forEach { append(shellQuote(it)).append(' ') }
            }.trim()

            val output = device.shell(command).allOutput.trim()
            val success = isInstallSuccess(output)
            if (success) {
                onProgress("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: $title")
            } else {
                val reason = output.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞" }
                onProgress("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: $reason")
            }
            return success
        } finally {
            cleanupRemoteFiles(remotePaths)
        }
    }

    fun getCurrentStatus(): ConnectionStatus {
        return if (isConnected && dadb != null) {
            ConnectionStatus(true, lastHost, lastPort, null)
        } else {
            ConnectionStatus(false, lastHost, lastPort, null)
        }
    }

    fun shellOutput(command: String): String? {
        return shellForOutput(command)
    }

    fun pullFileFromDevice(remotePath: String, localFile: File, onProgress: (String) -> Unit = {}): Boolean {
        return try {
            if (!ensureConnected(onProgress)) return false
            val device = dadb ?: return false
            localFile.parentFile?.mkdirs()
            val fileName = localFile.name
            onProgress("‚¨áÔ∏è $fileName")
            device.pull(localFile, remotePath)
            true
        } catch (e: Exception) {
            onProgress("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å ${localFile.name}: ${e.message}")
            false
        }
    }

    private fun shellForOutput(command: String): String? {
        return try {
            if (!ensureConnected()) return null
            val response = dadb?.shell(command) ?: return null
            response.allOutput
                .trim()
                .takeIf { it.isNotBlank() }
        } catch (_: Exception) {
            null
        }
    }

    fun queryFriendlyDeviceName(): String? {
        val commands = listOf(
            "settings get global device_name",
            "settings get secure device_name",
            "settings get system device_name",
            "settings get global bluetooth_name",
            "getprop ro.product.marketname",
            "getprop ro.product.vendor.marketname",
            "getprop ro.product.model",
            "getprop ro.product.vendor.model",
            "getprop ro.product.name"
        )
        for (cmd in commands) {
            val candidate = shellForOutput(cmd)?.cleanupFriendlyName()
            if (!candidate.isNullOrBlank() && !isGenericDeviceName(candidate)) {
                return candidate
            }
        }
        return null
    }

    private fun String.cleanupFriendlyName(): String? {
        val sanitized = this
            .replace('\n', ' ')
            .replace('\r', ' ')
            .replace(Regex("\\s+"), " ")
            .trim()
            .trim('"')
        if (sanitized.isBlank()) return null
        val lower = sanitized.lowercase(Locale.US)
        if (lower == "null" || lower == "undefined" || lower == "unknown" || lower == "none") return null
        return sanitized
    }

    fun pushFileToDevice(localFile: File, remoteDir: String, remoteFileName: String, onProgress: (String) -> Unit = {}): String? {
        if (!ensureConnected(onProgress)) return null
        return try {
            synchronized(adbOperationLock) {
                val device = dadb ?: return null
                val safeDir = normalizeRemoteDir(remoteDir)
                val safeName = sanitizeRemoteFileName(remoteFileName)
                val remotePath = if (safeDir.endsWith("/")) safeDir + safeName else "$safeDir/$safeName"
                runCatching {
                    device.shell("mkdir -p ${shellQuote(safeDir)}")
                }
                val totalSize = localFile.length().coerceAtLeast(1L)
                var sent = 0L
                var lastPercent = -PROGRESS_UPDATE_STEP
                var lastProgressTime = 0L
                val progressSource = object : ForwardingSource(localFile.source()) {
                    private val chunk = TRANSFER_BUFFER_SIZE.toLong()
                    override fun read(sink: Buffer, byteCount: Long): Long {
                        // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä —á—Ç–µ–Ω–∏—è –∫—Ä—É–ø–Ω—ã–º —á–∞–Ω–∫–æ–º –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
                        val read = super.read(sink, minOf(byteCount, chunk))
                        if (read > 0) {
                            sent += read
                            val percent = (sent * 100 / totalSize).toInt().coerceIn(0, 100)
                            val now = System.currentTimeMillis()
                            // –¢—Ä–æ—Ç—Ç–ª–∏–Ω–≥ UI –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: –Ω–µ —á–∞—â–µ 3 —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É –∏–ª–∏ –Ω–∞ 100%
                            if (percent == 100 || (percent - lastPercent >= PROGRESS_UPDATE_STEP && now - lastProgressTime > 333)) {
                                lastPercent = percent
                                lastProgressTime = now
                                onProgress("‚¨ÜÔ∏è $safeName ‚Üí $safeDir: $percent%")
                            }
                        }
                        return read
                    }
                }
                progressSource.use {
                    device.push(it, remotePath, 0x1B4, localFile.lastModified()) // 0664
                }
                if (lastPercent < 100) {
                    onProgress("‚¨ÜÔ∏è $safeName ‚Üí $safeDir: 100%")
                }
                onProgress("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ: $safeName")
                remotePath
            }
        } catch (e: Exception) {
            onProgress("‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–¥–∞—á–∏ $remoteFileName: ${e.message}")
            null
        }
    }

    // –ù–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –ø—Ä—è–º–æ–π –ø–µ—Ä–µ–¥–∞—á–∏ –∏–∑ URI –±–µ–∑ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
    fun pushUriToDevice(uri: Uri, remoteDir: String, remoteFileName: String, onProgress: (String) -> Unit = {}): String? {
        if (!ensureConnected(onProgress)) return null
        return try {
            synchronized(adbOperationLock) {
                val device = dadb ?: return null
                val safeDir = normalizeRemoteDir(remoteDir)
                val safeName = sanitizeRemoteFileName(remoteFileName)
                val remotePath = if (safeDir.endsWith("/")) safeDir + safeName else "$safeDir/$safeName"
                runCatching {
                    device.shell("mkdir -p ${shellQuote(safeDir)}")
                }
                
                // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ ContentResolver
                val totalSize = context.contentResolver.query(uri, null, null, null, null)?.use { cursor ->
                    val sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE)
                    if (cursor.moveToFirst() && sizeIndex != -1) {
                        cursor.getLong(sizeIndex)
                    } else null
                } ?: 0L
                
                val effectiveSize = totalSize.coerceAtLeast(1L)
                var sent = 0L
                var lastPercent = -PROGRESS_UPDATE_STEP
                var lastProgressTime = 0L
                
                context.contentResolver.openInputStream(uri)?.use { inputStream ->
                    val progressSource = object : Source {
                        private val buffer = ByteArray(TRANSFER_BUFFER_SIZE)
                        private var closed = false
                        
                        override fun read(sink: Buffer, byteCount: Long): Long {
                            if (closed) return -1
                            val bytesToRead = minOf(byteCount, buffer.size.toLong()).toInt()
                            val read = inputStream.read(buffer, 0, bytesToRead)
                            if (read == -1) {
                                closed = true
                                return -1
                            }
                            if (read > 0) {
                                sink.write(buffer, 0, read)
                                sent += read
                                val percent = if (totalSize > 0) {
                                    (sent * 100 / effectiveSize).toInt().coerceIn(0, 100)
                                } else {
                                    ((sent / 1024 / 1024) % 100).toInt() // –ü—Ä–∏–º–µ—Ä–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å –µ—Å–ª–∏ —Ä–∞–∑–º–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω
                                }
                                val now = System.currentTimeMillis()
                                // –¢—Ä–æ—Ç—Ç–ª–∏–Ω–≥ UI –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: –Ω–µ —á–∞—â–µ 3 —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
                                if (percent == 100 || (percent - lastPercent >= PROGRESS_UPDATE_STEP && now - lastProgressTime > 333)) {
                                    lastPercent = percent
                                    lastProgressTime = now
                                    onProgress("‚¨ÜÔ∏è $safeName ‚Üí $safeDir: $percent%")
                                }
                            }
                            return read.toLong()
                        }
                        
                        override fun timeout(): Timeout = Timeout.NONE
                        
                        override fun close() {
                            closed = true
                        }
                    }
                    
                    device.push(progressSource, remotePath, 0x1B4, System.currentTimeMillis())
                } ?: return null
                
                if (lastPercent < 100) {
                    onProgress("‚¨ÜÔ∏è $safeName ‚Üí $safeDir: 100%")
                }
                onProgress("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ: $safeName")
                remotePath
            }
        } catch (e: Exception) {
            onProgress("‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–¥–∞—á–∏ $remoteFileName: ${e.message}")
            null
        }
    }

    private fun cleanupRemoteFiles(paths: Collection<String>) {
        val device = dadb ?: return
        paths.forEach { path ->
            runCatching { device.shell("rm -f ${shellQuote(path)}") }
        }
    }

    fun ensureRemoteDirectory(remoteDir: String) {
        val device = dadb ?: return
        val safeDir = normalizeRemoteDir(remoteDir)
        runCatching {
            device.shell("mkdir -p ${shellQuote(safeDir)}")
        }
    }

    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ mkdir
    fun pushUriToDeviceOptimized(uri: Uri, remoteDir: String, remoteFileName: String, onProgress: (String) -> Unit = {}): String? {
        if (!ensureConnected(onProgress)) return null
        return try {
            synchronized(adbOperationLock) {
                val device = dadb ?: return null
                val safeDir = normalizeRemoteDir(remoteDir)
                val safeName = sanitizeRemoteFileName(remoteFileName)
                val remotePath = if (safeDir.endsWith("/")) safeDir + safeName else "$safeDir/$safeName"
                
                // –ù–µ —Å–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –∑–¥–µ—Å—å - –æ–Ω–∞ —É–∂–µ —Å–æ–∑–¥–∞–Ω–∞ –≤ ensureRemoteDirectory
                
                // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ ContentResolver
                val totalSize = context.contentResolver.query(uri, null, null, null, null)?.use { cursor ->
                    val sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE)
                    if (cursor.moveToFirst() && sizeIndex != -1) {
                        cursor.getLong(sizeIndex)
                    } else null
                } ?: 0L
                
                val effectiveSize = totalSize.coerceAtLeast(1L)
                var sent = 0L
                var lastPercent = -PROGRESS_UPDATE_STEP
                var lastProgressTime = 0L
                
                context.contentResolver.openInputStream(uri)?.use { inputStream ->
                    val progressSource = object : Source {
                        private val buffer = ByteArray(TRANSFER_BUFFER_SIZE)
                        private var closed = false
                        
                        override fun read(sink: Buffer, byteCount: Long): Long {
                            if (closed) return -1
                            val bytesToRead = minOf(byteCount, buffer.size.toLong()).toInt()
                            val read = inputStream.read(buffer, 0, bytesToRead)
                            if (read == -1) {
                                closed = true
                                return -1
                            }
                            if (read > 0) {
                                sink.write(buffer, 0, read)
                                sent += read
                                val percent = if (totalSize > 0) {
                                    (sent * 100 / effectiveSize).toInt().coerceIn(0, 100)
                                } else {
                                    ((sent / 1024 / 1024) % 100).toInt() // –ü—Ä–∏–º–µ—Ä–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å –µ—Å–ª–∏ —Ä–∞–∑–º–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω
                                }
                                val now = System.currentTimeMillis()
                                // –¢—Ä–æ—Ç—Ç–ª–∏–Ω–≥ UI –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: –Ω–µ —á–∞—â–µ 3 —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
                                if (percent == 100 || (percent - lastPercent >= PROGRESS_UPDATE_STEP && now - lastProgressTime > 333)) {
                                    lastPercent = percent
                                    lastProgressTime = now
                                    onProgress("‚¨ÜÔ∏è $safeName ‚Üí $safeDir: $percent%")
                                }
                            }
                            return read.toLong()
                        }
                        
                        override fun timeout(): Timeout = Timeout.NONE
                        
                        override fun close() {
                            closed = true
                        }
                    }
                    
                    device.push(progressSource, remotePath, 0x1B4, System.currentTimeMillis())
                } ?: return null
                
                if (lastPercent < 100) {
                    onProgress("‚¨ÜÔ∏è $safeName ‚Üí $safeDir: 100%")
                }
                onProgress("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ: $safeName")
                remotePath
            }
        } catch (e: Exception) {
            onProgress("‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–¥–∞—á–∏ $remoteFileName: ${e.message}")
            null
        }
    }

    // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ URL –Ω–∞–ø—Ä—è–º—É—é –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –±–µ–∑ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
    fun pushUrlToDeviceOptimized(url: String, remoteDir: String, remoteFileName: String, onProgress: (String) -> Unit = {}): String? {
        if (!ensureConnected(onProgress)) return null
        return try {
            synchronized(adbOperationLock) {
                val device = dadb ?: return null
                val safeDir = normalizeRemoteDir(remoteDir)
                val safeName = sanitizeRemoteFileName(remoteFileName)
                val remotePath = if (safeDir.endsWith("/")) safeDir + safeName else "$safeDir/$safeName"
                
                // –°–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
                runCatching {
                    device.shell("mkdir -p ${shellQuote(safeDir)}")
                }
                
                val connection = URL(url).openConnection() as HttpURLConnection
                connection.connectTimeout = 10000
                connection.readTimeout = 10000
                connection.requestMethod = "GET"
                // –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º HTTP —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                connection.setRequestProperty("Accept-Encoding", "identity") // –û—Ç–∫–ª—é—á–∞–µ–º —Å–∂–∞—Ç–∏–µ –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
                connection.setRequestProperty("Connection", "close") // –ù–µ –¥–µ—Ä–∂–∏–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                connection.setRequestProperty("User-Agent", "FastInstaller/1.0")
                connection.useCaches = false
                connection.doInput = true
                
                val totalSize = connection.contentLengthLong.takeIf { it > 0 } ?: 0L
                val effectiveSize = totalSize.coerceAtLeast(1L)
                var sent = 0L
                var lastPercent = -PROGRESS_UPDATE_STEP
                var lastProgressTime = 0L
                
                connection.inputStream.buffered(TRANSFER_BUFFER_SIZE).use { inputStream ->
                    val sourceFromStream = inputStream.source()
                    val progressSource = object : ForwardingSource(sourceFromStream) {
                        private val chunk = TRANSFER_BUFFER_SIZE.toLong()
                        override fun read(sink: Buffer, byteCount: Long): Long {
                            val read = super.read(sink, minOf(byteCount, chunk))
                            if (read > 0) {
                                sent += read
                                val percent = if (totalSize > 0) {
                                    (sent * 100 / effectiveSize).toInt().coerceIn(0, 100)
                                } else {
                                    ((sent / 1024 / 1024) % 100).toInt() // –ü—Ä–∏–º–µ—Ä–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å –µ—Å–ª–∏ —Ä–∞–∑–º–µ—Ä –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω
                                }
                                val now = System.currentTimeMillis()
                                // –¢—Ä–æ—Ç—Ç–ª–∏–Ω–≥ UI –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π: –Ω–µ —á–∞—â–µ 3 —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É
                                if (percent == 100 || (percent - lastPercent >= PROGRESS_UPDATE_STEP && now - lastProgressTime > 333)) {
                                    lastPercent = percent
                                    lastProgressTime = now
                                    onProgress("‚¨áÔ∏è‚¨ÜÔ∏è $safeName: $percent%")
                                }
                            }
                            return read
                        }
                    }
                    
                    progressSource.use {
                        device.push(it, remotePath, 0x1B4, System.currentTimeMillis())
                    }
                }
                
                if (lastPercent < 100) {
                    onProgress("‚¨áÔ∏è‚¨ÜÔ∏è $safeName: 100%")
                }
                onProgress("‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ: $safeName")
                remotePath
            }
        } catch (e: Exception) {
            onProgress("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ $remoteFileName: ${e.message}")
            null
        }
    }

    private fun isInstallSuccess(output: String): Boolean {
        if (output.isBlank()) return true
        return output
            .lineSequence()
            .any { it.contains("success", ignoreCase = true) }
    }

    private fun normalizeRemoteDir(dir: String): String {
        val trimmed = dir.trim().trimEnd('/')
        if (trimmed.isEmpty()) return "/sdcard/Download"
        return when {
            trimmed.startsWith("/") -> trimmed
            trimmed.startsWith("sdcard/", true) -> "/${trimmed.trimStart('/')}"
            trimmed.startsWith("storage/", true) -> "/${trimmed.trimStart('/')}"
            else -> "/sdcard/${trimmed}"
        }
    }

    private fun sanitizeRemoteFileName(name: String?): String {
        val base = name
            ?.substringAfterLast('/')
            ?.takeIf { it.isNotBlank() }
            ?.trim()
            ?: "file_${System.currentTimeMillis()}"

        val sanitized = buildString {
            base.forEach { ch ->
                when {
                    ch == '/' || ch == '\\' -> append('_')
                    ch == ':' || ch == '*' || ch == '?' || ch == '"' || ch == '<' || ch == '>' || ch == '|' -> append('_')
                    ch.code < 32 -> append('_')
                    ch == '\u2028' || ch == '\u2029' -> append('_')
                    else -> append(ch)
                }
            }
        }.trim().ifBlank { "file_${System.currentTimeMillis()}" }

        return sanitized.take(240)
    }

    private fun shellQuote(value: String): String {
        return "'" + value.replace("'", "'\"'\"'") + "'"
    }
}

class LocalDeviceDiscovery(
    context: Context,
    private val onIdentityDiscovered: (ip: String, friendlyName: String, source: String) -> Unit
) {
    private val appContext = context.applicationContext
    private val nsdManager = appContext.getSystemService(Context.NSD_SERVICE) as? NsdManager
    private val wifiManager = appContext.getSystemService(Context.WIFI_SERVICE) as? WifiManager
    private val multicastLock = wifiManager?.createMulticastLock("fi-mdns-lock")?.apply {
        setReferenceCounted(true)
    }
    private val running = AtomicBoolean(false)
    private val cache = ConcurrentHashMap<String, DeviceIdentity>()
    private val nsdListeners = mutableListOf<NsdManager.DiscoveryListener>()
    private val nsdServiceTypes = listOf(
        "_androidtvremote2._tcp.",
        "_googlecast._tcp.",
        "_adb-tls-connect._tcp.",
        "_adb-tls-pairing._tcp.",
        "_adb._tcp."
    )
    private val scheduler: ScheduledExecutorService = Executors.newSingleThreadScheduledExecutor { runnable ->
        Thread(runnable, "fi-ssdp").apply { isDaemon = true }
    }
    private var ssdpTask: ScheduledFuture<*>? = null
    private val ssdpRequestBytes = buildString {
        append("M-SEARCH * HTTP/1.1\r\n")
        append("HOST: 239.255.255.250:1900\r\n")
        append("MAN: \"ssdp:discover\"\r\n")
        append("MX: 2\r\n")
        append("ST: ssdp:all\r\n")
        append("\r\n")
    }.toByteArray(Charsets.UTF_8)
    private val locationCache = ConcurrentHashMap<String, String>()

    fun getFriendlyName(ip: String?): String? {
        val key = ip?.trim().orEmpty()
        if (key.isEmpty()) return null
        return cache[key]?.friendlyName
    }

    fun rememberFriendlyName(ip: String, name: String, source: String = "manual") {
        registerIdentity(ip, name, source, forceDispatch = true)
    }

    @SuppressLint("MissingPermission")
    fun start() {
        if (!running.compareAndSet(false, true)) return
        acquireMulticastLock()
        startNsdDiscovery()
        startSsdpLoop()
    }

    fun stop() {
        if (!running.compareAndSet(true, false)) return
        stopNsdDiscovery()
        stopSsdpLoop()
        releaseMulticastLock()
    }

    fun shutdown() {
        stop()
        scheduler.shutdownNow()
    }

    private fun acquireMulticastLock() {
        runCatching { multicastLock?.takeIf { !it.isHeld }?.acquire() }
    }

    private fun releaseMulticastLock() {
        runCatching { multicastLock?.takeIf { it.isHeld }?.release() }
    }

    private fun startNsdDiscovery() {
        val manager = nsdManager ?: return
        if (nsdListeners.isNotEmpty()) return
        nsdServiceTypes.forEach { type ->
            val listener = createDiscoveryListener()
            nsdListeners += listener
            runCatching {
                manager.discoverServices(type, NsdManager.PROTOCOL_DNS_SD, listener)
            }.onFailure { error ->
                Log.w(DEVICE_DISCOVERY_TAG, "NSD discover failed for $type", error)
            }
        }
    }

    private fun stopNsdDiscovery() {
        val manager = nsdManager ?: return
        nsdListeners.forEach { listener ->
            runCatching { manager.stopServiceDiscovery(listener) }
        }
        nsdListeners.clear()
    }

    private fun createDiscoveryListener(): NsdManager.DiscoveryListener {
        return object : NsdManager.DiscoveryListener {
            override fun onDiscoveryStarted(serviceType: String) {}

            override fun onDiscoveryStopped(serviceType: String) {}

            override fun onStartDiscoveryFailed(serviceType: String, errorCode: Int) {
                Log.w(DEVICE_DISCOVERY_TAG, "NSD start failed $serviceType ($errorCode)")
            }

            override fun onStopDiscoveryFailed(serviceType: String, errorCode: Int) {
                Log.w(DEVICE_DISCOVERY_TAG, "NSD stop failed $serviceType ($errorCode)")
            }

            override fun onServiceFound(serviceInfo: NsdServiceInfo) {
                handleServiceFound(serviceInfo)
            }

            override fun onServiceLost(serviceInfo: NsdServiceInfo) {}
        }
    }

    private fun handleServiceFound(serviceInfo: NsdServiceInfo) {
        val manager = nsdManager ?: return
        runCatching {
            manager.resolveService(serviceInfo, object : NsdManager.ResolveListener {
                override fun onResolveFailed(serviceInfo: NsdServiceInfo?, errorCode: Int) {
                    Log.w(DEVICE_DISCOVERY_TAG, "Resolve failed ($errorCode)")
                }

                override fun onServiceResolved(resolvedInfo: NsdServiceInfo) {
                    if (!running.get()) return
                    val ip = resolvedInfo.host?.hostAddress ?: return
                    val friendly = extractFriendlyName(resolvedInfo)
                    if (!friendly.isNullOrBlank()) {
                        registerIdentity(ip, friendly, "NSD")
                    }
                }
            })
        }.onFailure { error ->
            Log.w(DEVICE_DISCOVERY_TAG, "resolveService error", error)
        }
    }

    private fun extractFriendlyName(info: NsdServiceInfo): String? {
        val attrs = runCatching { info.attributes }.getOrNull()
        val fromAttributes = attrs?.let { map ->
            listOf("fn", "name", "md", "id").asSequence()
                .mapNotNull { key ->
                    map[key]?.let { bytes ->
                        runCatching { String(bytes, Charsets.UTF_8).trim() }.getOrNull()
                    }
                }
                .firstOrNull { it.isNotEmpty() }
        }
        if (!fromAttributes.isNullOrBlank()) return fromAttributes

        val serviceName = info.serviceName.orEmpty().trim()
        if (serviceName.isNotEmpty()) {
            val cleaned = serviceName
                .replace("._adb-tls-connect._tcp", "", ignoreCase = true)
                .replace("._adb-tls-pairing._tcp", "", ignoreCase = true)
                .replace("._androidtvremote2._tcp", "", ignoreCase = true)
                .replace("._googlecast._tcp", "", ignoreCase = true)
                .replace("._adb._tcp", "", ignoreCase = true)
                .trim('.')
                .replace('_', ' ')
                .trim()
            if (cleaned.isNotEmpty()) return cleaned
            return serviceName
        }
        return null
    }

    private fun startSsdpLoop() {
        if (ssdpTask != null || scheduler.isShutdown) return
        ssdpTask = scheduler.scheduleWithFixedDelay(
            { runSsdpPass() },
            0,
            20,
            TimeUnit.SECONDS
        )
    }

    private fun stopSsdpLoop() {
        ssdpTask?.cancel(true)
        ssdpTask = null
    }

    private fun runSsdpPass() {
        if (!running.get()) return
        try {
            DatagramSocket().use { socket ->
                socket.soTimeout = 2000
                val group = InetAddress.getByName("239.255.255.250")
                val packet = DatagramPacket(ssdpRequestBytes, ssdpRequestBytes.size, group, 1900)
                socket.send(packet)
                val buffer = ByteArray(4096)
                val started = SystemClock.elapsedRealtime()
                while (SystemClock.elapsedRealtime() - started < 3500 && running.get()) {
                    val response = DatagramPacket(buffer, buffer.size)
                    try {
                        socket.receive(response)
                    } catch (_: SocketTimeoutException) {
                        continue
                    } catch (io: IOException) {
                        Log.w(DEVICE_DISCOVERY_TAG, "SSDP receive error", io)
                        break
                    }
                    val ip = response.address?.hostAddress ?: continue
                    val payload = String(response.data, 0, response.length, Charsets.UTF_8)
                    val direct = extractSsdpHeader(payload, "friendlyname")
                        ?: extractSsdpHeader(payload, "fn")
                    val location = extractSsdpHeader(payload, "location")
                    val friendly = direct ?: location?.let { fetchFriendlyNameFromLocation(it) }
                    if (!friendly.isNullOrBlank()) {
                        registerIdentity(ip, friendly, "SSDP")
                    }
                }
            }
        } catch (e: Exception) {
            Log.w(DEVICE_DISCOVERY_TAG, "SSDP scan error", e)
        }
    }

    private fun extractSsdpHeader(payload: String, header: String): String? {
        val prefix = "$header:"
        return payload.lineSequence()
            .map { it.trim() }
            .firstOrNull { it.startsWith(prefix, ignoreCase = true) }
            ?.substringAfter(':')
            ?.trim()
            ?.takeIf { it.isNotEmpty() }
    }

    private fun fetchFriendlyNameFromLocation(location: String): String? {
        if (location.isBlank()) return null
        locationCache[location]?.let { cached ->
            if (cached.isNotBlank()) return cached
        }
        val name = runCatching {
            val url = URL(location)
            val connection = (url.openConnection() as? HttpURLConnection) ?: return@runCatching null
            try {
                connection.connectTimeout = 2000
                connection.readTimeout = 2000
                connection.requestMethod = "GET"
                connection.inputStream.use { stream ->
                    parseFriendlyName(stream)
                }
            } finally {
                connection.disconnect()
            }
        }.getOrNull()
        if (!name.isNullOrBlank()) {
            locationCache[location] = name
        }
        return name
    }

    private fun parseFriendlyName(stream: InputStream): String? {
        return runCatching {
            val factory = XmlPullParserFactory.newInstance()
            val parser = factory.newPullParser()
            parser.setInput(InputStreamReader(stream, Charsets.UTF_8))
            var event = parser.eventType
            var result: String? = null
            while (event != XmlPullParser.END_DOCUMENT) {
                if (event == XmlPullParser.START_TAG) {
                    val tag = parser.name ?: ""
                    if (tag.equals("friendlyName", true) || tag.equals("modelName", true)) {
                        result = parser.nextText()?.trim()
                        if (!result.isNullOrEmpty()) break
                    }
                }
                event = parser.next()
            }
            result
        }.getOrNull()
    }

    private fun registerIdentity(ip: String, name: String, source: String, forceDispatch: Boolean = false) {
        val normalizedIp = ip.trim()
        val normalizedName = name.trim()
        if (normalizedIp.isEmpty() || normalizedName.isEmpty()) return

        val previous = cache[normalizedIp]
        if (previous != null) {
            val prevName = previous.friendlyName
            if (!prevName.isNullOrBlank() && isGenericDeviceName(normalizedName) && !isGenericDeviceName(prevName)) {
                // Don't override good name with generic adb-XXXX fallback
                return
            }
        }

        val identity = DeviceIdentity(normalizedName, source, SystemClock.elapsedRealtime())
        val prev = cache.put(normalizedIp, identity)
        if (forceDispatch || prev?.friendlyName != identity.friendlyName) {
            onIdentityDiscovered(normalizedIp, normalizedName, source)
        }
    }

}

private fun isGenericDeviceName(name: String?): Boolean {
    if (name.isNullOrBlank()) return true
    val lower = name.lowercase(Locale.US)
    return lower.startsWith("adb-") ||
            lower.startsWith("adb ") ||
            lower == "unknown" ||
            lower == "device"
}

// –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —á–µ—Ä–µ–∑ PackageInstaller.Session (–∫–∞–∫ —É SAI)
class SessionApkInstaller(
    private val context: Context,
    private val onStatus: (String, String?) -> Unit,
    private val iconBase64: String? = null
) {
    /** –í—ã–∑—ã–≤–∞–µ–º –ø—Ä–∏ –ª—é–±–æ–º –∫–æ–Ω–µ—á–Ω–æ–º –∏—Å—Ö–æ–¥–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ (—É—Å–ø–µ—Ö/–æ—à–∏–±–∫–∞/–æ—Ç–º–µ–Ω–∞) */
    var onFinal: (() -> Unit)? = null
    companion object {
        fun ACTION_INSTALL_STATUS(ctx: Context) = ctx.packageName + ".INSTALL_STATUS"
    }

    private val ACTION = ACTION_INSTALL_STATUS(context)
    // –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ (label/–ø–∞–∫–µ—Ç) –ø–æ sessionId
    private val sessionMeta = ConcurrentHashMap<Int, InstallMeta>()

    private val receiver = object : BroadcastReceiver() {
        override fun onReceive(c: Context?, intent: Intent?) {
            if (intent?.action != ACTION) return

            // –ï—Å–ª–∏ —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–∏—Å–ª–∞–ª–∞ –ø—É—Å—Ç—É—é —à–∏—Ä–æ–∫–æ–≤–µ—â–∞–ª–∫—É ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
            if (!intent.hasExtra(PackageInstaller.EXTRA_STATUS)) {
                onStatus("‚ÑπÔ∏è –ò–≥–Ω–æ—Ä –ø—É—Å—Ç–æ–≥–æ INSTALL_STATUS (–Ω–µ—Ç EXTRA_STATUS)", null)
                return
            }

            val status = intent.getIntExtra(PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE)
            val msg    = intent.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE) ?: ""
            val pkg    = intent.getStringExtra(PackageInstaller.EXTRA_PACKAGE_NAME) ?: ""
            val other  = intent.getStringExtra(PackageInstaller.EXTRA_OTHER_PACKAGE_NAME) ?: ""
            val sessId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1)
            val legacy = intent.getIntExtra("android.content.pm.extra.LEGACY_STATUS", Int.MIN_VALUE)
            val full   = "status=$status, pkg=$pkg, other=$other, legacy=$legacy, sessionId=$sessId, message=$msg"
            val meta = sessionMeta[sessId]
            val name = meta?.label ?: pkg.ifBlank { "–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ" }

            // DEBUG: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—Ç–∞—Ç—É—Å–µ
           // onStatus("üîç DEBUG: $full", null) // –í—Ä–µ–º–µ–Ω–Ω–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏

            if (status == PackageInstaller.STATUS_PENDING_USER_ACTION) {
                val confirm = intent.getParcelableExtra<Intent>(Intent.EXTRA_INTENT)
                onStatus("", null)    /*üü° –¢—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ: $name */
                if (confirm != null) {
                    confirm.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    context.startActivity(confirm)
                } else {
                    onStatus("‚ö†Ô∏è –¢—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ, –Ω–æ —Å–∏—Å—Ç–µ–º–Ω–æ–µ –æ–∫–Ω–æ —Å–∫—Ä—ã—Ç–æ –ø—Ä–æ—à–∏–≤–∫–æ–π", null)
                }
                return
            }

            when (status) {
                PackageInstaller.STATUS_SUCCESS -> {
                    onStatus("–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: <span class='app-name'>${name.htmlEscape()}</span>", iconBase64)
                    onFinal?.invoke()
                }

                PackageInstaller.STATUS_FAILURE_CONFLICT -> {
                    onStatus("‚ö†Ô∏è –ö–æ–Ω—Ñ–ª–∏–∫—Ç –≤–µ—Ä—Å–∏–∏/–ø–æ–¥–ø–∏—Å–∏: <span class='app-name'>${name.htmlEscape()}</span>. –£–¥–∞–ª–∏—Ç–µ —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", iconBase64)
                    onFinal?.invoke()
                }

                PackageInstaller.STATUS_FAILURE_INVALID -> {
                    onStatus("‚ö†Ô∏è –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: –≤–æ–∑–º–æ–∂–Ω–æ –∫–æ–Ω—Ñ–ª–∏–∫—Ç –≤–µ—Ä—Å–∏–∏ –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω—ã–π APK", iconBase64)
                    onFinal?.invoke()
                }

                PackageInstaller.STATUS_FAILURE_INCOMPATIBLE -> {
                    onStatus("üö´ –ù–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ–º/–≤–µ—Ä—Å–∏–µ–π Android: <span class='app-name'>${name.htmlEscape()}</span>", iconBase64)
                    onFinal?.invoke()
                }

                PackageInstaller.STATUS_FAILURE_STORAGE -> {
                    onStatus("üíæ –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–µ—Å—Ç–∞ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏: <span class='app-name'>${name.htmlEscape()}</span>", iconBase64)
                    onFinal?.invoke()
                }

                PackageInstaller.STATUS_FAILURE_ABORTED -> {
                    onStatus("‚õî –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞: <span class='app-name'>${name.htmlEscape()}</span>", iconBase64)
                    onFinal?.invoke()
                }

                else -> {
                    onStatus("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: <span class='app-name'>${name.htmlEscape()}</span>", iconBase64)
                    onFinal?.invoke()
                }
            }

// —Ñ–∏–Ω–∞–ª ‚Äî —É–±–∏—Ä–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø–æ —Å–µ—Å—Å–∏–∏
            if (sessId != -1) sessionMeta.remove(sessId)

        }
    }

    fun register() {
        val filter = IntentFilter(ACTION)
        if (Build.VERSION.SDK_INT >= 33) {
            context.registerReceiver(receiver, filter, Context.RECEIVER_NOT_EXPORTED)
        } else {
            context.registerReceiver(receiver, filter)
        }
    }

    fun unregister() = runCatching { context.unregisterReceiver(receiver) }

    fun install(files: List<File>) {
        val pi = context.packageManager.packageInstaller      // ‚Üê —ç–∫–∑–µ–º–ø–ª—è—Ä —É—Å—Ç–∞–Ω–æ–≤—â–∏–∫–∞
        val totalBytes = files.sumOf { it.length() }

        val params = PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL).apply {
            setSize(totalBytes)

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                setInstallReason(PackageManager.INSTALL_REASON_USER)
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                setRequireUserAction(PackageInstaller.SessionParams.USER_ACTION_NOT_REQUIRED)
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
                setInstallerPackageName(context.packageName)
            }
            setOriginatingUid(Process.myUid())
        }

        val sessionId = pi.createSession(params)
        val session = pi.openSession(sessionId)
        // –í—ã–±–µ—Ä–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π apk –¥–ª—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö (base.apk, –µ—Å–ª–∏ –µ—Å—Ç—å; –∏–Ω–∞—á–µ –ø–µ—Ä–≤—ã–π)
        val primaryApk = files.firstOrNull { it.name.equals("base.apk", ignoreCase = true) } ?: files.first()
        val meta = extractApkMeta(context, primaryApk)


        try {
            if (files.size == 1) {
                val f = files[0]
                FileInputStream(f).use { input ->
                    session.openWrite("base.apk", 0, f.length()).use { out ->
                        input.copyTo(out)
                        session.fsync(out)
                    }
                }
            } else {
                files.forEach { f ->
                    FileInputStream(f).use { input ->
                        session.openWrite(f.name, 0, f.length()).use { out ->
                            input.copyTo(out)
                            session.fsync(out)
                        }
                    }
                }
            }

            // –ü—Ä—è–º–æ–π callback –Ω–∞ –Ω–∞—à ACTION ‚Äî —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–∏—à–ª—ë—Ç –≤—Å–µ PackageInstaller.EXTRA_*
            val callbackIntent = Intent(ACTION)               // ‚Üê —Ç–æ—Ç –∂–µ ACTION, —á—Ç–æ –≤—ã —Å–ª—É—à–∞–µ—Ç–µ –≤ register()
                .setPackage(context.packageName)              // —á—Ç–æ–±—ã –∏–Ω—Ç–µ–Ω—Ç –ø—Ä–∏—à—ë–ª —Ç–æ–ª—å–∫–æ –≤ –Ω–∞—à–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ

            val sender = PendingIntent.getBroadcast(
                context,
                sessionId,
                callbackIntent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE
            ).intentSender

            sessionMeta[sessionId] = meta
            session.commit(sender)


            // –§–æ–ª–ª–±–µ–∫ –Ω–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π UI, –µ—Å–ª–∏ –ø—Ä–æ—à–∏–≤–∫–∞ ¬´–º–æ–ª—á–∏—Ç¬ª
            /*
            Handler(Looper.getMainLooper()).postDelayed({
                onStatus("‚è± –ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç PackageInstaller ‚Äî –æ—Ç–∫—Ä—ã–≤–∞—é —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —É—Å—Ç–∞–Ω–æ–≤—â–∏–∫", null)
                runCatching {
                    val uri = FileProvider.getUriForFile(
                        context, "${context.packageName}.provider", files.first()
                    )
                    val view = Intent(Intent.ACTION_VIEW).apply {
                        setDataAndType(uri, "application/vnd.android.package-archive")
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION)
                    }
                    context.startActivity(view)
                }
            }, 8000)
*/

        } catch (e: Exception) {
            onStatus("‚ùå –°–±–æ–π —Å–µ—Å—Å–∏–∏: ${e.message}", null)
            runCatching { session.abandon() }
        }
    }
}

class BackupRegistry(context: Context) {
    private val registryFile = File(context.filesDir, "backup_registry_v1.json")
    private val lock = Any()

    fun addEntry(entry: BackupRecord) {
        synchronized(lock) {
            val entries = readEntries()
            entries.removeAll { it.path == entry.path && it.deviceId == entry.deviceId && it.isRemote == entry.isRemote }
            entries.add(entry)
            writeEntries(entries)
        }
    }

    fun entriesForDevice(deviceId: String): List<BackupRecord> {
        if (deviceId.isBlank()) return emptyList()
        synchronized(lock) {
            return readEntries().filter { it.deviceId == deviceId }
        }
    }

    fun removeEntriesById(ids: Set<String>) {
        if (ids.isEmpty()) return
        synchronized(lock) {
            val entries = readEntries()
            val filtered = entries.filterNot { ids.contains(it.id) }
            if (filtered.size != entries.size) {
                writeEntries(filtered.toMutableList())
            }
        }
    }

    private fun readEntries(): MutableList<BackupRecord> {
        if (!registryFile.exists()) return mutableListOf()
        return runCatching {
            val content = registryFile.readText()
            if (content.isBlank()) {
                mutableListOf()
            } else {
                val arr = JSONArray(content)
                val list = mutableListOf<BackupRecord>()
                for (i in 0 until arr.length()) {
                    val obj = arr.optJSONObject(i) ?: continue
                    toBackupRecord(obj)?.let { list += it }
                }
                list
            }
        }.getOrElse { mutableListOf() }
    }

    private fun writeEntries(entries: MutableList<BackupRecord>) {
        val arr = JSONArray()
        entries.forEach { record ->
            arr.put(
                JSONObject()
                    .put("id", record.id)
                    .put("deviceId", record.deviceId)
                    .put("sessionId", record.sessionId)
                    .put("path", record.path)
                    .put("isRemote", record.isRemote)
                    .put("timestamp", record.timestamp)
                )
        }
        registryFile.parentFile?.mkdirs()
        registryFile.writeText(arr.toString())
    }

    private fun toBackupRecord(obj: JSONObject): BackupRecord? {
        val deviceId = obj.optString("deviceId", "")
        val sessionId = obj.optString("sessionId", "")
        val path = obj.optString("path", "")
        if (deviceId.isBlank() || sessionId.isBlank() || path.isBlank()) return null
        return BackupRecord(
            id = obj.optString("id").takeIf { it.isNotBlank() } ?: UUID.randomUUID().toString(),
            deviceId = deviceId,
            sessionId = sessionId,
            path = path,
            isRemote = obj.optBoolean("isRemote", false),
            timestamp = obj.optLong("timestamp", System.currentTimeMillis())
        )
    }
}



    class MainActivity : AppCompatActivity() {

    private lateinit var webView: WebView
    private lateinit var webInterface: WebAppInterface
    @Volatile private var shouldRunAutoPermissions = false
    private lateinit var termsPrefs: SharedPreferences
    private val REQUEST_CODE_PICK_FILE = 1001
    private var filePickerCallback: ((String) -> Unit)? = null
    private var pendingApkPicker = false
    private var pendingAdbUploadPicker = false
    
    private var webViewSetupInProgress = false
    private var webViewPromptShown = false
    private var startupFlowLaunched = false
    private var pendingWebViewState: Bundle? = null

    private var isOfflineMode = false

    // ADB
    lateinit var adbManager: AdbConnectionManager
    private lateinit var deviceDiscovery: LocalDeviceDiscovery
    @Volatile var adbReady: Boolean = false
    private val adbProbeExecutor = Executors.newFixedThreadPool(32)
    private val adbScanController = Executors.newSingleThreadExecutor { runnable ->
        Thread(runnable, "fi-adb-scan-controller").apply { isDaemon = true }
    }
    private val adbScanWorkers = Executors.newFixedThreadPool(64) { runnable ->
        Thread(runnable, "fi-adb-scan-worker").apply { isDaemon = true }
    }
    private val adbFriendlyNameExecutor = Executors.newSingleThreadExecutor { runnable ->
        Thread(runnable, "fi-adb-name").apply { isDaemon = true }
    }
    private val adbScanRunning = AtomicBoolean(false)
    private val adbScanStopRequested = AtomicBoolean(false)
    private val adbScanResults = ConcurrentHashMap<String, AdbScanHost>()
    private val lastDiscoveryUpdate = AtomicLong(0L)
    private val backupRegistry by lazy { BackupRegistry(this) }
    private val backupSessionId: String = UUID.randomUUID().toString()
    private val storageUsageExecutor = Executors.newSingleThreadExecutor { runnable ->
        Thread(runnable, "fi-storage-usage").apply { isDaemon = true }
    }
    private val statusRefreshHandler = Handler(Looper.getMainLooper())
    private val delayedStatusRunnable = Runnable {
        refreshAdbStatusIndicator()
        pushStorageUsageToWeb()
    }
    @Volatile private var storageUsageUpdatesActive = false
    @Volatile private var lastStorageUsageLabel: String = ""

    private fun hasWebView(): Boolean = this::webView.isInitialized
    private fun triggerAutoPermissionsAfterInstall(): Boolean {
        if (!shouldRunAutoPermissions) return false
        shouldRunAutoPermissions = false
        if (!hasWebView()) return false
        webView.post {
            val script = "if (typeof runAllAutoPermissions === 'function') { try { runAllAutoPermissions(); } catch (e) { console.error(e); } }"
            try {
                webView.evaluateJavascript(script, null)
            } catch (_: Exception) {
                Log.w("MainActivity", "Failed to trigger auto permissions")
            }
        }
        return true
    }

    private fun hasWebInterface(): Boolean = this::webInterface.isInitialized
    private fun deviceDiscoveryOrNull(): LocalDeviceDiscovery? =
        if (this::deviceDiscovery.isInitialized) deviceDiscovery else null

    private fun refreshFriendlyNameFromAdb(host: String?) {
        val ip = host?.trim().orEmpty()
        if (ip.isEmpty()) return
        if (ip == "127.0.0.1" || ip == "localhost") return
        val discovery = deviceDiscoveryOrNull() ?: return
        adbFriendlyNameExecutor.execute {
            val name = adbManager.queryFriendlyDeviceName()?.trim()
            if (!name.isNullOrBlank() && !isGenericDeviceName(name)) {
                discovery.rememberFriendlyName(ip, name, "adb-shell")
                notifyAdbStatusChanged()
                val status = adbManager.getCurrentStatus()
                val port = if (status.host.isNullOrBlank() || status.host == ip) {
                    status.port
                } else {
                    status.port
                }
                saveLastAdbConnection(ip, if (port > 0) port else 5555, name)
            }
        }
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–µ—Ç–æ–¥–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏
    private val PREFS_NAME = "install_settings"
    private val KEY_INSTALL_METHOD = "install_method"
    private val INSTALL_METHOD_SAI = "sai"
    private val INSTALL_METHOD_STANDARD = "standard"
    private val INSTALL_METHOD_ADB = "adb"
    private val INSTALL_METHOD_AUTO_REASON_ADB = "auto-adb"
    private val KEY_LAST_ADB_HOST = "last_adb_host"
    private val KEY_LAST_ADB_PORT = "last_adb_port"
    private val KEY_LAST_ADB_LABEL = "last_adb_label"
    private val KEY_LAST_ADB_FRIENDLY = "last_adb_friendly"

    // –ï–¥–∏–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ —Å—Å—ã–ª–∫–∏ –Ω–∞ –∫–æ–Ω—Ñ–∏–≥
    private val CONFIG_URL = "https://tvboxsetup.ru/fastinstaller/UserFastLast/config.json"

    companion object {
        private const val TERMS_PREFS_NAME = "terms_of_use"
        private const val KEY_TERMS_ACCEPTED_VERSION = "accepted_version"
        private const val TERMS_VERSION = 1
        private const val REMOTE_DOWNLOAD_DIR = "/sdcard/Download"
    }

    data class DownloadCopyResult(
        val success: Boolean,
        val message: String,
        val copiedFiles: Int = 0,
        val targetDir: File? = null
    )

    fun getConfigUrlForWeb(): String {
        return CONFIG_URL
    }

    fun startDeviceIdentityDiscovery() {
        deviceDiscoveryOrNull()?.let { discovery ->
            runOnUiThread { discovery.start() }
        }
    }

    fun stopDeviceIdentityDiscovery() {
        deviceDiscoveryOrNull()?.let { discovery ->
            runOnUiThread { discovery.stop() }
        }
    }

    fun startNativeAdbScan() {
        adbScanController.submit { performNativeAdbScan() }
    }

    fun stopNativeAdbScan() {
        adbScanStopRequested.set(true)
        if (!adbScanRunning.get()) {
            deviceDiscovery.stop()
            sendAdbScanStatus("–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ", false)
        }
    }

    fun notifyAdbStatusChanged() {
        if (!hasWebView()) return
        webView.post {
            if (hasWebView()) {
                webView.evaluateJavascript(
                    "window.refreshAdbStatusIndicator && window.refreshAdbStatusIndicator();",
                    null
                )
            }
        }
    }

    private fun refreshAdbStatusIndicator() {
        notifyAdbStatusChanged()
    }

    private fun updateConnectionStatusIndicator(mode: String) {
        if (!hasWebView()) return
        val normalized = if (mode.equals("adb", true)) "adb" else "local"
        webView.post {
            try {
                webView.evaluateJavascript(
                    "window.setConnectionStatus && window.setConnectionStatus('$normalized');",
                    null
                )
                pushStorageUsageToWeb()
            } catch (e: Exception) {
                Log.w(ADB_LOG_TAG, "Failed to push connection status to WebView", e)
            }
        }
    }

    fun handleAdbConnectionAlive() {
        updateConnectionStatusIndicator("adb")
        notifyAdbStatusChanged()
        requestStorageUsageUpdate()
        scheduleDelayedStatusRefresh()
    }

    private fun whitelistSelfForDoze() {
        if (!this::adbManager.isInitialized) return
        Thread {
            runCatching {
                adbManager.runShellCommand("dumpsys deviceidle whitelist +$packageName") { }
            }.onFailure {
                Log.w(ADB_LOG_TAG, "Failed to whitelist for Doze", it)
            }
        }.start()
    }

    private fun grantUnknownSourcesForSelfAsync() {
        if (!this::adbManager.isInitialized) return
        Thread {
            runCatching {
                val cmds = listOf(
                    "appops set $packageName REQUEST_INSTALL_PACKAGES allow",
                    "appops set --uid $packageName REQUEST_INSTALL_PACKAGES allow"
                )
                cmds.any { adbManager.runShellCommand(it) { } }
            }.onFailure {
                Log.w(ADB_LOG_TAG, "Failed to grant unknown-sources for self", it)
            }
        }.start()
    }

    fun handleAdbConnectionLost() {
        if (this::adbManager.isInitialized) {
            adbManager.disconnect()
        }
        updateConnectionStatusIndicator("local")
        notifyAdbStatusChanged()
        requestStorageUsageUpdate()
        scheduleDelayedStatusRefresh()
    }

    fun syncAdbConnectionStatusAsync() {
        if (!this::adbManager.isInitialized) {
            updateConnectionStatusIndicator("local")
            return
        }
        Thread {
            val status = adbManager.getCurrentStatus()
            val alive = status.isConnected && adbManager.silentPing()
            Handler(Looper.getMainLooper()).post {
                if (alive) {
                    handleAdbConnectionAlive()
                } else {
                    handleAdbConnectionLost()
                }
            }
        }.start()
    }

    data class BackupCleanupSummary(
        val deletedLocal: Int,
        val deletedRemote: Int,
        val pendingRemote: Int,
        val hadEntries: Boolean
    )

    private fun currentBackupDeviceId(): String {
        if (this::adbManager.isInitialized) {
            val status = adbManager.getCurrentStatus()
            if (status.isConnected && status.host.isNotBlank()) {
                val hostLabel = status.host.ifBlank { "unknown" }
                val portLabel = if (status.port > 0) status.port else AdbConnectionManager.DEFAULT_PORT
                return "adb://$hostLabel:$portLabel"
            }
        }
        val manufacturer = Build.MANUFACTURER?.takeIf { it.isNotBlank() }.orEmpty()
        val model = Build.MODEL?.takeIf { it.isNotBlank() }.orEmpty()
        val label = listOf(manufacturer, model).filter { it.isNotEmpty() }.joinToString("_")
        return "local://${label.ifBlank { Build.DEVICE ?: "unknown" }}"
    }

    fun registerLocalBackup(file: File) {
        if (!file.exists()) return
        backupRegistry.addEntry(
            BackupRecord(
                deviceId = currentBackupDeviceId(),
                sessionId = backupSessionId,
                path = file.absolutePath,
                isRemote = false
            )
        )
    }

    fun registerRemoteBackup(remotePath: String) {
        if (remotePath.isBlank()) return
        backupRegistry.addEntry(
            BackupRecord(
                deviceId = currentBackupDeviceId(),
                sessionId = backupSessionId,
                path = remotePath,
                isRemote = true
            )
        )
    }

    fun copyRemoteDownloadsToLocal(onProgress: (String) -> Unit = {}): DownloadCopyResult {
        if (!this::adbManager.isInitialized) {
            return DownloadCopyResult(false, "ADB –º–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
        }
        val adb = adbManager
        val connected = adb.ensureConnected { onProgress(it) }
        if (!connected) {
            return DownloadCopyResult(false, "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ ADB")
        }

        val remoteFiles = fetchRemoteDownloadFiles(adb)
        if (remoteFiles == null) {
            return DownloadCopyResult(false, "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –≤ $REMOTE_DOWNLOAD_DIR")
        }
        if (remoteFiles.isEmpty()) {
            return DownloadCopyResult(true, "–ù–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –Ω–µ—Ç —Ñ–∞–π–ª–æ–≤ –≤ $REMOTE_DOWNLOAD_DIR")
        }

        val fallbackLabel = adb.getCurrentStatus().let { status ->
            buildString {
                if (status.host.isNotBlank()) append(status.host)
                if (status.port > 0) {
                    if (isNotEmpty()) append('_')
                    append(status.port)
                }
            }
        }.ifBlank {
            listOfNotNull(Build.MANUFACTURER, Build.MODEL, Build.DEVICE)
                .firstOrNull { !it.isNullOrBlank() }
                ?: "device"
        }

        val deviceLabel = sanitizeDeviceFolderName(
            adb.queryFriendlyDeviceName()?.takeIf { it.isNotBlank() } ?: fallbackLabel
        )

        val downloadsRoot = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
        val fastInstallerDir = File(downloadsRoot, "FastInstaller")
        val deviceDir = File(fastInstallerDir, deviceLabel)
        if (deviceDir.exists()) {
            deviceDir.deleteRecursively()
        }
        if (!deviceDir.mkdirs() && !deviceDir.exists()) {
            return DownloadCopyResult(false, "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–∞—Ç–∞–ª–æ–≥ ${deviceDir.absolutePath}")
        }

        var copied = 0
        var failed = 0
        remoteFiles.forEach { remotePath ->
            val relative = when {
                remotePath.startsWith("$REMOTE_DOWNLOAD_DIR/") -> remotePath.removePrefix("$REMOTE_DOWNLOAD_DIR/")
                remotePath == REMOTE_DOWNLOAD_DIR -> File(remotePath).name
                remotePath.startsWith("./") -> remotePath.removePrefix("./")
                remotePath.startsWith("/") -> remotePath.removePrefix("/")
                else -> remotePath
            }.ifBlank { File(remotePath).name }

            if (relative.isBlank()) return@forEach
            val localFile = File(deviceDir, relative)
            localFile.parentFile?.mkdirs()
            val ok = adb.pullFileFromDevice(remotePath, localFile) { onProgress(it) }
            if (ok) {
                copied++
            } else {
                failed++
            }
        }

        val success = failed == 0
        val message = if (success) {
            "–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ $copied —Ñ–∞–π–ª–æ–≤ –≤ ${deviceDir.absolutePath}"
        } else {
            "–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ $copied —Ñ–∞–π–ª–æ–≤, $failed —Å –æ—à–∏–±–∫–∞–º–∏. –ü–∞–ø–∫–∞: ${deviceDir.absolutePath}"
        }
        return DownloadCopyResult(success, message, copied, deviceDir)
    }

    private fun fetchRemoteDownloadFiles(adb: AdbConnectionManager): List<String>? {
        val commands = listOf(
            "toybox find $REMOTE_DOWNLOAD_DIR -type f -print",
            "busybox find $REMOTE_DOWNLOAD_DIR -type f -print",
            "find $REMOTE_DOWNLOAD_DIR -type f -print",
            "ls -1 $REMOTE_DOWNLOAD_DIR"
        )
        commands.forEach { command ->
            val output = adb.shellOutput(command) ?: return@forEach
            val cleaned = output.replace("\r", "").trim()
            if (cleaned.isEmpty()) {
                if (command.startsWith("ls")) {
                    return emptyList()
                }
                return@forEach
            }
            val hasError = cleaned.contains("No such file", ignoreCase = true) ||
                cleaned.contains("not found", ignoreCase = true) ||
                cleaned.contains("permission denied", ignoreCase = true)
            if (hasError) return@forEach

            val lines = cleaned
                .split('\n')
                .map { it.trim() }
                .filter { it.isNotEmpty() }
            if (lines.isEmpty()) {
                return@forEach
            }
            return if (command.startsWith("ls")) {
                lines.map { "$REMOTE_DOWNLOAD_DIR/$it" }
            } else {
                lines.map { path ->
                    when {
                        path.startsWith(REMOTE_DOWNLOAD_DIR) -> path
                        path.startsWith("./") -> "$REMOTE_DOWNLOAD_DIR/${path.removePrefix("./")}"
                        path.startsWith("/") -> path
                        else -> "$REMOTE_DOWNLOAD_DIR/${path.removePrefix("./")}"
                    }
                }
            }
        }
        return null
    }

    private fun sanitizeDeviceFolderName(raw: String?): String {
        val sanitized = raw
            ?.trim()
            ?.replace(Regex("[\\\\/:*?\"<>|]"), "_")
            ?.replace(Regex("\\s+"), "_")
            ?.trim('_')
            ?.takeIf { it.isNotBlank() }
        return sanitized ?: "device_${System.currentTimeMillis()}"
    }

    private fun isWallpaperProtectedPath(path: String?): Boolean {
        if (path.isNullOrBlank()) return false
        val normalized = path
            .replace('\\', '/')
            .lowercase(Locale.ROOT)
        return normalized.split('/')
            .any { it == "wallpaper" || it == "wallpapers" }
    }

    fun cleanupRegisteredBackups(): BackupCleanupSummary {
        val entries = backupRegistry.entriesForDevice(currentBackupDeviceId())
        if (entries.isEmpty()) {
            return BackupCleanupSummary(0, 0, 0, false)
        }
        val idsToRemove = mutableSetOf<String>()
        var deletedLocal = 0
        entries.filter { !it.isRemote }.forEach { entry ->
            val file = File(entry.path)
            if (isWallpaperProtectedPath(file.absolutePath)) {
                return@forEach
            }
            if (!file.exists() || file.delete()) {
                deletedLocal++
                idsToRemove += entry.id
            }
        }

        var deletedRemote = 0
        var pendingRemote = 0
        val remoteEntries = entries.filter { it.isRemote }
        if (remoteEntries.isNotEmpty()) {
            val adbConnected = this::adbManager.isInitialized && adbManager.getCurrentStatus().isConnected
            if (adbConnected) {
                remoteEntries.forEach { entry ->
                    if (isWallpaperProtectedPath(entry.path)) {
                        return@forEach
                    }
                    val ok = adbManager.runShellCommand("rm -f ${quoteForShell(entry.path)}") { }
                    if (ok) {
                        deletedRemote++
                        idsToRemove += entry.id
                    } else {
                        pendingRemote++
                    }
                }
            } else {
                pendingRemote = remoteEntries.size
            }
        }

        if (idsToRemove.isNotEmpty()) {
            backupRegistry.removeEntriesById(idsToRemove)
        }

        return BackupCleanupSummary(deletedLocal, deletedRemote, pendingRemote, true)
    }

    private fun quoteForShell(value: String): String {
        return "'" + value.replace("'", "'\"'\"'") + "'"
    }

    @SuppressLint("MissingPermission")
    private fun performNativeAdbScan() {
        if (isVpnBlockingLocalAccess()) {
            sendAdbScanStatus(
                "VPN –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç —Ç—Ä–∞—Ñ–∏–∫ –∏ –±–ª–æ–∫–∏—Ä—É–µ—Ç –ª–æ–∫–∞–ª—å–Ω—É—é —Å–µ—Ç—å. –û—Ç–∫–ª—é—á–∏—Ç–µ VPN –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ FastInstaller –≤ –∏—Å–∫–ª—é—á–µ–Ω–∏—è.",
                false
            )
            adbScanRunning.set(false)
            sendAdbScanResults()
            return
        }

        if (!adbScanRunning.compareAndSet(false, true)) {
            return
        }
        adbScanStopRequested.set(false)
        adbScanResults.clear()
        lastDiscoveryUpdate.set(SystemClock.elapsedRealtime())
        sendAdbScanResults()

        val subnet = resolveLocalSubnet()
        if (subnet.isNullOrBlank()) {
            sendAdbScanStatus("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å IP —ç—Ç–æ–π —Å–µ—Ç–∏", false)
            adbScanRunning.set(false)
            return
        }

        deviceDiscovery.start()
        sendAdbScanStatus("–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ—Ç–∏", true)

        var vpnInterferenceDetected = false
        val suspectedVpnMessage = "VPN –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç —Ç—Ä–∞—Ñ–∏–∫ –∏ –±–ª–æ–∫–∏—Ä—É–µ—Ç –ª–æ–∫–∞–ª—å–Ω—É—é —Å–µ—Ç—å. –û—Ç–∫–ª—é—á–∏—Ç–µ VPN –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ FastInstaller –≤ –∏—Å–∫–ª—é—á–µ–Ω–∏—è."

        try {
            val tasks = (1..254).map { host ->
                val ip = "$subnet.$host"
                adbScanWorkers.submit {
                    if (adbScanStopRequested.get()) return@submit
                    val latency = probeAdbPort(ip, 5555, 1800)
                    if (latency != null && !adbScanStopRequested.get()) {
                        val friendlyName = deviceDiscovery.getFriendlyName(ip)
                        adbScanResults[ip] = AdbScanHost(ip, 5555, latency, friendlyName)
                        sendAdbScanResults()
                        lastDiscoveryUpdate.set(SystemClock.elapsedRealtime())
                    }
                }
            }
            tasks.forEach { future ->
                runCatching { future.get() }
            }
            waitForDiscoveryQuietPeriod(2000L, 250L)

            if (adbScanResults.size >= 200) {
                vpnInterferenceDetected = true
                adbScanResults.clear()
                sendAdbScanResults()
                sendAdbScanStatus(suspectedVpnMessage, false)
                return
            }
        } finally {
            val finalMessage = if (adbScanStopRequested.get()) {
                "–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ"
            } else {
                "–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ"
            }
            deviceDiscovery.stop()
            if (!vpnInterferenceDetected) {
                sendAdbScanStatus(finalMessage, false)
            }
            adbScanRunning.set(false)
            adbScanStopRequested.set(false)
        }
    }

    fun getFriendlyNameForIp(ip: String?): String {
        if (ip.isNullOrBlank()) return ""
        return deviceDiscoveryOrNull()?.getFriendlyName(ip).orEmpty()
    }

    private fun isWebViewAvailable(): Boolean {
        return try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                android.webkit.WebView.getCurrentWebViewPackage() != null
            } else {
                val pm = packageManager
                listOf("com.google.android.webview","com.android.webview","com.huawei.webview")
                    .any { runCatching { pm.getPackageInfo(it, 0) }.isSuccess }
            }
        } catch (_: Exception) { false }
    }
    
    private fun promptInstallWebView() {
    promptInstallOrPermissions()
    }
    
    private fun installWebViewHeadless() {
        Thread {
            try {
                val meta = runCatching {
                    val j = JSONObject(URL("https://tvboxsetup.ru/fastinstaller/WebView/metadata.json").readText())
                    j
                }.getOrNull()
    
                val remoteVersion = meta?.optLong("versionCode", 0L) ?: 0L
                val apkUrl = meta?.optString("apkUrl")
                    ?: "https://tvboxsetup.ru/fastinstaller/WebView/WebView_upd.apk"
    
                val (_, installedBest) = getBestInstalledWebViewVersion()
                if (installedBest >= remoteVersion && installedBest != 0L) {
                    runOnUiThread {
                        Toast.makeText(this, "WebView —É–∂–µ –∞–∫—Ç—É–∞–ª–µ–Ω", Toast.LENGTH_SHORT).show()
                        if (isWebViewAvailable()) recreate() else waitForWebViewAndRecreate()
                    }
                    return@Thread
                }

                // –î–∏–∞–ª–æ–≥ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞: –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π ProgressBar + –ø—Ä–æ—Ü–µ–Ω—Ç—ã
                val bar = ProgressBar(this, null, android.R.attr.progressBarStyleHorizontal).apply {
                    max = 100
                    progress = 0
                    isIndeterminate = false
                }
                val percent = TextView(this).apply {
                    setTextColor(Color.WHITE)
                    textSize = 16f
                    text = "0%"
                    gravity = Gravity.CENTER
                }
                val icon = ImageView(this).apply {
                    setImageResource(R.drawable.ic_webview)
                    adjustViewBounds = true
                    val size = (48 * resources.displayMetrics.density).toInt()
                    layoutParams = LinearLayout.LayoutParams(size, size)
                }
                
                val title = TextView(this).apply {
                    setTextColor(Color.WHITE)
                    textSize = 16f
                    text = "–ó–∞–≥—Ä—É–∑–∫–∞ Android System WebView‚Ä¶"
                    gravity = Gravity.CENTER
                }
                
                val wrap = LinearLayout(this).apply {
                    orientation = LinearLayout.VERTICAL
                    setPadding(48, 36, 48, 24)
                    gravity = Gravity.CENTER_HORIZONTAL
                    addView(icon, LinearLayout.LayoutParams(icon.layoutParams))
                    addView(title, LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.WRAP_CONTENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply { topMargin = (12 * resources.displayMetrics.density).toInt() })
                    addView(bar, LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ))
                    addView(percent, LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.WRAP_CONTENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT
                    ).apply { topMargin = (8 * resources.displayMetrics.density).toInt() })
                }
                val dlg = runOnUiThread {
                    AlertDialog.Builder(this)
                        .setView(wrap)
                        .setCancelable(false)
                        .create().also { it.show() }
                }

                // –°–∫–∞—á–∏–≤–∞–Ω–∏–µ —Å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                val file = File(cacheDir, "webview_${System.currentTimeMillis()}.apk")
                val conn = (URL(apkUrl).openConnection() as HttpURLConnection).apply { connect() }
                val length = conn.contentLengthLong
                BufferedInputStream(conn.inputStream).use { input ->
                    FileOutputStream(file).use { output ->
                        val buf = ByteArray(8192)
                        var total = 0L
                        var last = -1
                        while (true) {
                            val n = input.read(buf)
                            if (n == -1) break
                            output.write(buf, 0, n)
                            total += n
                            if (length > 0) {
                                val p = ((total * 100) / length).toInt()
                                if (p != last) {
                                    last = p
                                    runOnUiThread {
                                        bar.progress = p
                                        percent.text = "$p%"
                                    }
                                }
                            }
                        }
                    }
                }

                runOnUiThread { try { (dlg as AlertDialog).dismiss() } catch (_: Throwable) {} }

                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–º —Å–∏—Å—Ç–µ–º–Ω—ã–º —É—Å—Ç–∞–Ω–æ–≤—â–∏–∫–æ–º (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É –º–µ—Ç–æ–¥–∞)
                val uri = FileProvider.getUriForFile(this, "${packageName}.provider", file)
                val intent = Intent(Intent.ACTION_VIEW).apply {
                    setDataAndType(uri, "application/vnd.android.package-archive")
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION)
                }
                startActivity(intent)

                // –ñ–¥—ë–º –ø–æ—è–≤–ª–µ–Ω–∏—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ WebView –∏ —Ç–æ–ª—å–∫–æ –ø–æ—Ç–æ–º –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º —ç–∫—Ä–∞–Ω
                waitForWebViewAndRecreate()
            } catch (e: Exception) {
                runOnUiThread { Toast.makeText(this, "–û—à–∏–±–∫–∞: ${e.message}", Toast.LENGTH_LONG).show() }
            }
        }.start()
    }
    
    private fun getBestInstalledWebViewVersion(): Pair<String, Long> {
        val candidates = listOf("com.google.android.webview", "com.android.webview", "com.huawei.webview")
        var best = 0L
        var bestPkg = ""
        for (p in candidates) {
            val v = getInstalledVersionPkg(p)
            if (v > best) { best = v; bestPkg = p }
        }
        return bestPkg to best
    }
    
    private fun getInstalledVersionPkg(pkg: String): Long {
        return try {
            val pm = packageManager
            val pi = if (Build.VERSION.SDK_INT >= 33)
                pm.getPackageInfo(pkg, PackageManager.PackageInfoFlags.of(0))
            else
                @Suppress("DEPRECATION") pm.getPackageInfo(pkg, 0)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) pi.longVersionCode
            else @Suppress("DEPRECATION") pi.versionCode.toLong()
        } catch (_: Exception) { 0L }
    }
    
    private fun downloadApkToCacheHeadless(urlStr: String, fileName: String): File? {
        return try {
            val file = File(cacheDir, fileName)
            val conn = (URL(urlStr).openConnection() as HttpURLConnection).apply { connect() }
            BufferedInputStream(conn.inputStream).use { input ->
                FileOutputStream(file).use { output -> input.copyTo(output) }
            }
            file
        } catch (_: Exception) { null }
    }

    private fun waitForWebViewAndRecreate(timeoutMs: Long = 30000) {
        val start = System.currentTimeMillis()
        val handler = Handler(Looper.getMainLooper())
        fun tick() {
            if (isWebViewAvailable()) {
                webViewSetupInProgress = false
                recreate()
            } else if (System.currentTimeMillis() - start < timeoutMs) {
                handler.postDelayed({ tick() }, 1000)
            } else {
                webViewSetupInProgress = false
                Toast.makeText(this, "WebView –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", Toast.LENGTH_LONG).show()
                promptInstallOrPermissions()
            }
        }
        tick()
    }

    private fun openUnknownSourcesForThisApp() {
        val pkg = packageName
        val startedViaAdb = tryOpenUnknownSourcesViaAdb(pkg) { executed ->
            val message = if (executed) {
                ""
            } else {
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ ADB –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ"
            }
            Toast.makeText(this, message, Toast.LENGTH_LONG).show()
        }
        if (startedViaAdb) return

        val intents = listOf(
            Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES).apply {
                data = "package:$pkg".toUri()
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            },
            Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                data = "package:$pkg".toUri()
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            },
            Intent(Settings.ACTION_SETTINGS).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        )
        intents.firstOrNull { runCatching { startActivity(it) }.isSuccess } ?: runCatching {
            startActivity(Intent(Settings.ACTION_SETTINGS).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
        }
    }

    private fun runAdbCommandsAsync(
        logPrefix: String,
        commands: List<String>,
        onResult: (Boolean) -> Unit
    ): Boolean {
        if (!this::adbManager.isInitialized || !adbManager.getCurrentStatus().isConnected) return false
        Thread {
            if (!adbManager.silentPing()) {
                handleAdbConnectionLost()
                runOnUiThread { onResult(false) }
                return@Thread
            } else {
                handleAdbConnectionAlive()
            }
            val executed = commands.any { cmd ->
                try {
                    val ok = adbManager.runShellCommand(cmd) { line ->
                        if (line.isNotBlank()) {
                            Log.d(ADB_LOG_TAG, "[$logPrefix] $line")
                        }
                    }
                    if (!ok) {
                        Log.w(ADB_LOG_TAG, "[$logPrefix] –ö–æ–º–∞–Ω–¥–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π: $cmd")
                    }
                    ok
                } catch (e: Exception) {
                    Log.w(ADB_LOG_TAG, "[$logPrefix] –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã: $cmd", e)
                    false
                }
            }
            runOnUiThread { onResult(executed) }
        }.start()
        return true
    }

    private fun adbCommandVariants(vararg bases: String): List<String> {
        val result = mutableListOf<String>()
        bases.map(String::trim).filter { it.isNotEmpty() }.forEach { base ->
            result += "am start --user 0 $base"
            result += "am start $base"
        }
        return result
    }

    private fun tryOpenUnknownSourcesViaAdb(
        targetPackage: String,
        onResult: (Boolean) -> Unit
    ): Boolean {
        val commands = mutableListOf<String>().apply {
            // –°–∞–º—ã–π –Ω–∞–¥—ë–∂–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç ‚Äî —è–≤–Ω—ã–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–ø–∏—Å–∫–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –Ω–∞ Android TV
            addAll(
                adbCommandVariants(
                    "-n com.android.tv.settings/com.android.tv.settings.device.apps.specialaccess.ExternalSourcesActivity"
                )
            )
            // –î–∞–ª–µ–µ ‚Äî –æ–±—â–∏–π –∏–Ω—Ç–µ–Ω—Ç ¬´–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏¬ª, –≤–¥—Ä—É–≥ –ø—Ä–æ—à–∏–≤–∫–∞ –∂–∏–≤—ë—Ç –±–µ–∑ TV-–Ω–∞—Å—Ç—Ä–æ–µ–∫
            addAll(adbCommandVariants("-a android.settings.MANAGE_UNKNOWN_APP_SOURCES"))
            addAll(
                adbCommandVariants(
                    "-n com.google.android.tv.settings/com.google.android.tv.settings.device.apps.specialaccess.ExternalSourcesActivity"
                )
            )
            // –ó–∞—Ç–µ–º –ø—Ä–æ–±—É–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –ø–∞–∫–µ—Ç—ã
            addAll(
                adbCommandVariants(
                    "-a android.settings.MANAGE_UNKNOWN_APP_SOURCES -d package:$targetPackage"
                )
            )
            addAll(
                adbCommandVariants(
                    "-a android.settings.APPLICATION_DETAILS_SETTINGS -d package:$targetPackage"
                )
            )
            addAll(adbCommandVariants("-a android.settings.SECURITY_SETTINGS"))
        }
        return runAdbCommandsAsync("UnknownSources", commands, onResult)
    }

    private fun tryOpenBatteryOptimizationViaAdb(onResult: (Boolean) -> Unit): Boolean {
        val commands = mutableListOf<String>().apply {
            addAll(
                adbCommandVariants(
                    "-a android.intent.action.MAIN -c android.intent.category.LEANBACK_SETTINGS"
                )
            )
            addAll(adbCommandVariants("-n com.android.tv.settings/com.android.tv.settings.MainSettings"))
            addAll(adbCommandVariants("-n com.android.tv.settings/com.android.tv.settings.SettingsActivity"))
            addAll(adbCommandVariants("-n com.android.tv.settings/com.android.tv.settings.TvSettingsActivity"))
            addAll(adbCommandVariants("-n com.google.android.tv.settings/com.google.android.tv.settings.MainSettingsActivity"))
            addAll(adbCommandVariants("-n com.google.android.tv.settings/com.google.android.tv.settings.MainSettings"))
            addAll(adbCommandVariants("-n com.google.android.tv.settings/com.google.android.tv.settings.SettingsActivity"))
            addAll(adbCommandVariants("-n com.google.android.tv.settings/com.google.android.tv.settings.homepage.TopLevelSettingsActivity"))
            addAll(adbCommandVariants("-n com.tcl.tv.settings/com.tcl.tv.settings.MainSettings"))
            addAll(adbCommandVariants("-n com.tcl.settings/com.tcl.settings.MainSettings"))
            addAll(adbCommandVariants("-n com.droidlogic.tv.settings/com.droidlogic.tv.settings.MainSettings"))
            addAll(adbCommandVariants("-n com.realtek.tvsettings/com.realtek.tvsettings.MainSettings"))
            addAll(adbCommandVariants("-a android.settings.IGNORE_BATTERY_OPTIMIZATION_SETTINGS"))
            addAll(adbCommandVariants("-a android.settings.SETTINGS"))
        }
        return runAdbCommandsAsync("BatteryOptimization", commands, onResult)
    }

    private fun tryOpenAppSettingsListViaAdb(onResult: (Boolean) -> Unit): Boolean {
        val commands = mutableListOf<String>().apply {
            addAll(adbCommandVariants("-n com.android.tv.settings/com.android.tv.settings.device.apps.AppsActivity"))
            addAll(adbCommandVariants("-n com.android.tv.settings/com.android.tv.settings.device.apps.AppManagementActivity"))
            addAll(adbCommandVariants("-n com.android.tv.settings/com.android.tv.settings.device.apps.AllAppsActivity"))
            addAll(adbCommandVariants("-n com.android.tv.settings/com.android.tv.settings.device.apps.AppsActivityBase"))
            addAll(adbCommandVariants("-n com.google.android.tv.settings/com.google.android.tv.settings.device.apps.AppsActivity"))
            addAll(adbCommandVariants("-n com.google.android.tv.settings/com.google.android.tv.settings.device.apps.AppManagementActivity"))
            addAll(adbCommandVariants("-n com.google.android.tv.settings/com.google.android.tv.settings.device.apps.AllAppsActivity"))
            addAll(adbCommandVariants("-a android.settings.MANAGE_ALL_APPLICATIONS_SETTINGS"))
            addAll(adbCommandVariants("-a android.settings.MANAGE_APPLICATIONS_SETTINGS"))
            addAll(adbCommandVariants("-a android.settings.APPLICATION_SETTINGS"))
            addAll(adbCommandVariants("-a android.settings.SETTINGS"))
        }
        return runAdbCommandsAsync("AppSettingsList", commands, onResult)
    }

    private fun tryOpenAccessibilitySettingsViaAdb(onResult: (Boolean) -> Unit): Boolean {
        val commands = mutableListOf<String>().apply {
            addAll(
                adbCommandVariants(
                    "-n com.android.tv.settings/com.android.tv.settings.accessibility.AccessibilityActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.android.tv.settings/com.android.tv.settings.AccessibilitySettingsActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.google.android.tv.settings/com.google.android.tv.settings.accessibility.AccessibilityActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.google.android.tv.settings/com.google.android.tv.settings.AccessibilitySettingsActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.droidlogic.tv.settings/com.droidlogic.tv.settings.accessibility.AccessibilityActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.droidlogic.tv.settings/com.droidlogic.tv.settings.AccessibilitySettingsActivity"
                )
            )
            addAll(adbCommandVariants("-a android.intent.action.MAIN -c android.intent.category.LEANBACK_SETTINGS"))
            addAll(adbCommandVariants("-a android.settings.ACCESSIBILITY_SETTINGS"))
            addAll(adbCommandVariants("-a android.settings.SETTINGS"))
        }
        return runAdbCommandsAsync("AccessibilitySettings", commands, onResult)
    }

    private fun tryOpenFilesPermissionSettingsViaAdb(
        targetPackage: String,
        onResult: (Boolean, Boolean) -> Unit
    ): Boolean {
        if (!this::adbManager.isInitialized || !adbManager.getCurrentStatus().isConnected) return false
        Thread {
            if (!adbManager.silentPing()) {
                handleAdbConnectionLost()
                runOnUiThread { onResult(false, true) }
                return@Thread
            } else {
                handleAdbConnectionAlive()
            }

            val packageExists = runCatching {
                val output = StringBuilder()
                val success = adbManager.runShellCommand("pm list packages $targetPackage") { chunk ->
                    output.append(chunk)
                }
                success && output.toString().contains(targetPackage)
            }.getOrDefault(false)

            if (!packageExists) {
                runOnUiThread {
                    onResult(false, false)
                }
                return@Thread
            }

            val commands = mutableListOf<String>().apply {
                addAll(
                    adbCommandVariants(
                        "-a android.settings.MANAGE_APP_ALL_FILES_ACCESS_PERMISSION -d package:$targetPackage"
                    )
                )
                addAll(
                    adbCommandVariants(
                        "-n com.android.tv.settings/com.android.tv.settings.device.apps.AppInfoActivity"
                    )
                )
                addAll(adbCommandVariants("-a android.settings.APPLICATION_DETAILS_SETTINGS -d package:$targetPackage"))
            }

            val executed = commands.any { cmd ->
                try {
                    val ok = adbManager.runShellCommand(cmd) { line ->
                        if (line.isNotBlank()) {
                            Log.d(ADB_LOG_TAG, "[FilesPermission] $line")
                        }
                    }
                    if (!ok) {
                        Log.w(ADB_LOG_TAG, "[FilesPermission] –ö–æ–º–∞–Ω–¥–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π: $cmd")
                    }
                    ok
                } catch (e: Exception) {
                    Log.w(ADB_LOG_TAG, "[FilesPermission] –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã: $cmd", e)
                    false
                }
            }

            runOnUiThread {
                onResult(executed, true)
            }
        }.start()
        return true
    }

    private fun tryOpenAnydeskViaAdb(onResult: (Boolean) -> Unit): Boolean {
        val commands = adbCommandVariants(
            "-n com.anydesk.anydeskandroid/com.anydesk.anydeskandroid.gui.activity.MainActivity"
        )
        return runAdbCommandsAsync("Anydesk", commands, onResult)
    }

    private fun tryOpenFileManagerPlusViaAdb(onResult: (Boolean) -> Unit): Boolean {
        val commands = adbCommandVariants(
            "-n com.alphainventor.filemanager/com.alphainventor.filemanager.activity.MainActivity"
        )
        return runAdbCommandsAsync("FileManagerPlus", commands, onResult)
    }

    private fun tryOpenPlayMarketViaAdb(onResult: (Boolean) -> Unit): Boolean {
        val commands = mutableListOf<String>().apply {
            addAll(
                adbCommandVariants(
                    "-n com.android.vending/com.google.android.finsky.activities.MainActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.android.vending/com.google.android.finsky.activities.LaunchUrlHandlerActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.android.vending/com.google.android.finsky.tvmainactivity.TvMainActivity"
                )
            )
            addAll(adbCommandVariants("-a android.intent.action.VIEW -d market://details?id=com.android.vending"))
            addAll(adbCommandVariants("-a android.intent.action.VIEW -d https://play.google.com/store"))
        }
        return runAdbCommandsAsync("PlayMarket", commands, onResult)
    }

    private fun tryOpenWirelessDebuggingViaAdb(onResult: (Boolean) -> Unit): Boolean {
        val commands = mutableListOf<String>().apply {
            addAll(
                adbCommandVariants(
                    "-n com.android.tv.settings/com.android.tv.settings.system.development.DevelopmentActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.android.tv.settings/com.android.tv.settings.system.development.DeveloperSettingsActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.google.android.tv.settings/com.google.android.tv.settings.system.development.DevelopmentActivity"
                )
            )
            addAll(
                adbCommandVariants(
                    "-n com.google.android.tv.settings/com.google.android.tv.settings.system.development.DeveloperSettingsActivity"
                )
            )
            addAll(adbCommandVariants("-a android.settings.APPLICATION_DEVELOPMENT_SETTINGS"))
            addAll(adbCommandVariants("-a android.settings.SETTINGS"))
        }
        return runAdbCommandsAsync("WirelessDebugging", commands, onResult)
    }

    private fun showInstallPrompt(
        title: String,
        message: String,
        installLabel: String,
        onInstall: () -> Unit,
        permissionsLabel: String? = null,
        onPermissions: (() -> Unit)? = null,
        laterLabel: String? = null,
        onLater: (() -> Unit)? = null,
        cancelable: Boolean = false
    ) {
        runOnUiThread {
            val dialogView = LayoutInflater.from(this).inflate(R.layout.dialog_install_prompt, null)
            val dialog = AlertDialog.Builder(this, R.style.CustomDialogTheme)
                .setView(dialogView)
                .setCancelable(cancelable)
                .create()

            dialog.setCanceledOnTouchOutside(cancelable)

            dialogView.findViewById<TextView>(R.id.dialogTitle).text = title
            dialogView.findViewById<TextView>(R.id.dialogMessage).text = message

            dialogView.findViewById<Button>(R.id.btnInstall).apply {
                text = installLabel
                setOnClickListener {
                    dialog.dismiss()
                    onInstall()
                }
            }

            val permissionsContainer = dialogView.findViewById<LinearLayout>(R.id.permissionsContainer)
            val permissionsButton = dialogView.findViewById<Button>(R.id.btnPermissions)
            val laterButton = dialogView.findViewById<Button>(R.id.btnLater)

            val buttonRow = dialogView.findViewById<LinearLayout>(R.id.buttonRow)

            permissionsButton.apply {
                val shouldShow = onPermissions != null && !permissionsLabel.isNullOrBlank()
                visibility = if (shouldShow) View.VISIBLE else View.GONE
                permissionsContainer.visibility = if (shouldShow) View.VISIBLE else View.GONE
                val permLp = permissionsContainer.layoutParams as LinearLayout.LayoutParams
                permLp.width = if (shouldShow) 0 else LinearLayout.LayoutParams.WRAP_CONTENT
                permLp.weight = if (shouldShow) 1f else 0f
                permissionsContainer.layoutParams = permLp
                buttonRow.gravity = Gravity.CENTER_VERTICAL or Gravity.END
                if (shouldShow) {
                    text = permissionsLabel
                    setOnClickListener {
                        dialog.dismiss()
                        onPermissions?.invoke()
                    }
                }
            }

            laterButton.apply {
                val shouldShow = onLater != null && !laterLabel.isNullOrBlank()
                visibility = if (shouldShow) View.VISIBLE else View.GONE
                if (shouldShow) {
                    text = laterLabel
                    setOnClickListener {
                        dialog.dismiss()
                        onLater?.invoke()
                    }
                }
            }

            dialog.show()
        }
    }

    private fun promptInstallOrPermissions() {
        webViewPromptShown = true
        showInstallPrompt(
            title = "WebView –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
            message = "–î–ª—è —Ä–∞–±–æ—Ç—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Ç—Ä–µ–±—É–µ—Ç—Å—è Android System WebView.",
            installLabel = "–£–°–¢–ê–ù–û–í–ò–¢–¨",
            onInstall = {
                webViewSetupInProgress = true
                Toast.makeText(this, "–°–∫–∞—á–∏–≤–∞–Ω–∏–µ WebView –Ω–∞—á–∞–ª–æ—Å—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ –ø–æ–¥–æ–∂–¥–∏—Ç–µ‚Ä¶", Toast.LENGTH_LONG).show()
                installWebViewHeadless()
            },
            permissionsLabel = "–†–∞–∑—Ä–µ—à–µ–Ω–∏—è",
            onPermissions = { openUnknownSourcesForThisApp() },
            laterLabel = "–í–´–•–û–î",
            onLater = { finish() },
            cancelable = false
        )
    }






    @SuppressLint("SetJavaScriptEnabled")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        pendingWebViewState = savedInstanceState?.getBundle("webview_state")
        val prefs = getSharedPreferences("autostart", Context.MODE_PRIVATE)
        if (!prefs.contains("autostart_package")) {
            prefs.edit { putString("autostart_package", "") }
        }

        termsPrefs = getSharedPreferences(TERMS_PREFS_NAME, Context.MODE_PRIVATE)
        val acceptedVersion = termsPrefs.getInt(KEY_TERMS_ACCEPTED_VERSION, -1)

        if (acceptedVersion == TERMS_VERSION) {
            startMainFlow()
        } else {
            showTermsOfUseDialog()
        }
    }

    private fun showTermsOfUseDialog() {
        showInstallPrompt(
            title = "–£—Å–ª–æ–≤–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è",
            message = "–ü–†–û–î–û–õ–ñ–ê–Ø, –í–´ –ü–û–î–¢–í–ï–†–ñ–î–ê–ï–¢–ï, –ß–¢–û –£–°–¢–ê–ù–û–í–ö–ê –ò –ó–ê–ü–£–°–ö –°–¢–û–†–û–ù–ù–ò–• –ü–†–ò–õ–û–ñ–ï–ù–ò–ô, –ò–ú–ü–û–†–¢ –ù–ê–°–¢–†–û–ï–ö –ò –ë–≠–ö–ê–ü–û–í –û–°–£–©–ï–°–¢–í–õ–Ø–Æ–¢–°–Ø –í–ê–ú–ò –ü–û –°–û–ë–°–¢–í–ï–ù–ù–û–ú–£ –£–°–ú–û–¢–†–ï–ù–ò–Æ –ò –ù–ê –í–ê–® –†–ò–°–ö, –° –°–û–ë–õ–Æ–î–ï–ù–ò–ï–ú –¢–†–ï–ë–û–í–ê–ù–ò–ô –ó–ê–ö–û–ù–û–î–ê–¢–ï–õ–¨–°–¢–í–ê –ò –£–°–õ–û–í–ò–ô –°–û–û–¢–í–ï–¢–°–¢–í–£–Æ–©–ò–• –õ–ò–¶–ï–ù–ó–ò–ô.\n\n–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ-—É—Å—Ç–∞–Ω–æ–≤—â–∏–∫ –ª–∏—à—å –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä—É–µ—Ç –¥–µ–π—Å—Ç–≤–∏—è, –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –∏ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–∞–≤–æ–≤–æ–π —Å—Ç–∞—Ç—É—Å, –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å, —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö APK/—Ñ–∞–π–ª–æ–≤; –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –∑–∞ –∏—Ö –≤—ã–±–æ—Ä, –∏—Å—Ç–æ—á–Ω–∏–∫, —É—Å—Ç–∞–Ω–æ–≤–∫—É –∏ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –Ω–µ—Å—ë—Ç–µ –≤—ã.\n\n–í–´ –°–û–ì–õ–ê–°–ù–´ –ü–†–ò–ù–Ø–¢–¨ –£–°–õ–û–í–ò–Ø –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø?",
            installLabel = "–°–û–ì–õ–ê–°–ï–ù",
            onInstall = {
                termsPrefs.edit { putInt(KEY_TERMS_ACCEPTED_VERSION, TERMS_VERSION) }
                startMainFlow()
            },
            laterLabel = "–ù–ï–¢",
            onLater = { finish() },
            cancelable = false
        )
    }

    private fun startMainFlow() {
        if (startupFlowLaunched) return
        startupFlowLaunched = true

        checkStoragePermissions()

        cacheDir.listFiles()?.forEach {
            if (it.name.endsWith(".apk")) it.delete()
        }

        checkStoragePermissions()

        // –ï—Å–ª–∏ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –Ω–µ—Ç –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ WebView ‚Äî –ø—Ä–µ–¥–ª–æ–∂–∏–º —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏ –Ω–µ —Å–æ–∑–¥–∞—ë–º WebView
        if (!isWebViewAvailable()) {
            promptInstallWebView()
            return
        }

        cacheDir.listFiles()?.forEach {
            if (it.name.endsWith(".apk")) it.delete()
        }

        webView = WebView(this)
        webView.id = android.R.id.content
        webView.isVerticalScrollBarEnabled = false
        webView.isHorizontalScrollBarEnabled = false
        webView.overScrollMode = View.OVER_SCROLL_NEVER
        setContentView(webView)

        webView.settings.javaScriptEnabled = true
        webView.settings.cacheMode = WebSettings.LOAD_DEFAULT
        webView.settings.allowFileAccess = true
        webView.settings.allowContentAccess = true
        webView.settings.allowFileAccessFromFileURLs = true
        webView.settings.allowUniversalAccessFromFileURLs = true
        webView.settings.domStorageEnabled = true
        webView.settings.mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
        webView.settings.loadsImagesAutomatically = true
        webView.settings.blockNetworkImage = false
        webView.settings.blockNetworkLoads = false
        
        // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è —à—Ä–∏—Ñ—Ç–æ–≤
        webView.settings.textZoom = 100  // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞ 100%
        webView.settings.minimumFontSize = 1  // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä —à—Ä–∏—Ñ—Ç–∞
        webView.settings.minimumLogicalFontSize = 1
        webView.settings.defaultFontSize = 16
        webView.settings.defaultFixedFontSize = 13
        

        val assetLoader = WebViewAssetLoader.Builder()
            .addPathHandler("/assets/", WebViewAssetLoader.AssetsPathHandler(this))
            .addPathHandler("/res/", WebViewAssetLoader.ResourcesPathHandler(this))
            .build()

        webView.webViewClient = object : WebViewClient() {
            override fun shouldInterceptRequest(
                view: WebView?,
                request: WebResourceRequest
            ): WebResourceResponse? {
                val uri = request.url
                return assetLoader.shouldInterceptRequest(uri) ?: super.shouldInterceptRequest(view, request)
            }

            @Suppress("DEPRECATION")
            override fun shouldInterceptRequest(view: WebView?, url: String): WebResourceResponse? {
                val uri = Uri.parse(url)
                return assetLoader.shouldInterceptRequest(uri) ?: super.shouldInterceptRequest(view, url)
            }

            @Suppress("DEPRECATION")
            override fun onReceivedError(
                view: WebView,
                errorCode: Int,
                description: String?,
                failingUrl: String?
            ) {
                if (!isLocalUrl(failingUrl)) {
                    showOffline(view)
                }
            }

            override fun onReceivedError(
                view: WebView,
                request: WebResourceRequest,
                error: WebResourceError
            ) {
                if (request.isForMainFrame && !isLocalUrl(request.url)) {
                    showOffline(view)
                }
            }

            override fun onReceivedHttpError(
                view: WebView,
                request: WebResourceRequest,
                errorResponse: WebResourceResponse
            ) {
                if (request.isForMainFrame && !isLocalUrl(request.url)) {
                    showOffline(view)
                }
            }

            override fun onReceivedSslError(
                view: WebView,
                handler: SslErrorHandler,
                error: SslError
            ) {
                handler.cancel()
                showOffline(view)
            }

            override fun onPageFinished(view: WebView, url: String?) {
                super.onPageFinished(view, url)
                refreshAdbStatusIndicator()
                pushStorageUsageToWeb()
            }
        }
        webInterface = WebAppInterface(this, webView)
        webView.addJavascriptInterface(webInterface, "AndroidInterface")
        val restored = pendingWebViewState?.let { state ->
            try {
                webView.restoreState(state)
                true
            } catch (e: Exception) {
                Log.w(ADB_LOG_TAG, "restoreState failed, fallback to reload", e)
                false
            }
        } ?: false
        if (!restored) {
            loadStartUrl()
        }
        pendingWebViewState = null

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º ADB –º–µ–Ω–µ–¥–∂–µ—Ä
        adbManager = AdbConnectionManager(this)
        deviceDiscovery = LocalDeviceDiscovery(this) { ip, friendlyName, _ ->
            val trimmed = friendlyName.trim()
            if (trimmed.isEmpty()) return@LocalDeviceDiscovery
            val existing = adbScanResults[ip]
            if (existing != null) {
                val current = existing.friendlyName
                if (!current.isNullOrBlank() && isGenericDeviceName(trimmed) && !isGenericDeviceName(current)) {
                    return@LocalDeviceDiscovery
                }
                if (current != trimmed) {
                    adbScanResults[ip] = existing.copy(friendlyName = trimmed)
                    sendAdbScanResults()
                }
            }
        }
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        setIntent(intent)
        // –ù–∏—á–µ–≥–æ –Ω–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º: WebView –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞, –ø—Ä–æ—Å—Ç–æ –æ—Å—Ç–∞–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∂–∏–≤–æ–π.
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        if (hasWebView()) {
            val webState = Bundle()
            runCatching { webView.saveState(webState) }
            outState.putBundle("webview_state", webState)
        }
    }

    private fun loadStartUrl(forceRefresh: Boolean = false) {
        if (!hasWebView()) return

        if (!isNetworkAvailable()) {
            showOffline(webView)
            return
        }

        val separator = if (START_URL.contains("?")) "&" else "?"
        val url = "$START_URL${separator}t=${System.currentTimeMillis()}"
        isOfflineMode = false
        webView.loadUrl(url)
    }

    private fun showOffline(view: WebView) {
        if (view.url == OFFLINE_PAGE_URL) return
        view.stopLoading()
        view.loadUrl("about:blank")
        view.post {
            isOfflineMode = true
            view.loadUrl(OFFLINE_PAGE_URL)
        }
        if (hasWebInterface()) {
            webInterface.sendMessageToWebView("‚õî –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ç–∏")
        }
    }

    private fun isLocalUrl(url: Uri): Boolean {
        val scheme = url.scheme?.lowercase(Locale.US)
        return scheme == "file" || scheme == "content" || scheme == "data"
    }

    private fun isLocalUrl(url: String?): Boolean {
        if (url.isNullOrEmpty()) return false
        return try {
            isLocalUrl(Uri.parse(url))
        } catch (_: Exception) {
            false
        }
    }

    @Suppress("DEPRECATION")
    private fun isNetworkAvailable(): Boolean {
        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as? ConnectivityManager
            ?: return false
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false

        val hasTransport = capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||
                capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) ||
                capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)

        if (!hasTransport) return false

        val hasInternetCapability = capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)

        val isValidated = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_VALIDATED)
        } else {
            connectivityManager.activeNetworkInfo?.isConnected == true
        }

        return hasTransport && hasInternetCapability && isValidated
    }

    private fun getWifiIpv4Address(): String? {
        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as? ConnectivityManager
            ?: return null
        val wifiNetwork = getWifiNetwork(connectivityManager) ?: return null
        val linkProps = connectivityManager.getLinkProperties(wifiNetwork) ?: return null
        return linkProps.linkAddresses
            .mapNotNull { it.address }
            .filterIsInstance<Inet4Address>()
            .firstOrNull { !it.isLoopbackAddress }
            ?.hostAddress
    }

    private fun getLocalIpv4Address(): String? {
        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as? ConnectivityManager
        val activeNetwork = connectivityManager?.activeNetwork
        if (activeNetwork != null) {
            val linkProps = connectivityManager.getLinkProperties(activeNetwork)
            val fromLink = linkProps?.linkAddresses
                ?.mapNotNull { it.address }
                ?.firstOrNull { it is Inet4Address && !it.isLoopbackAddress }
                ?.hostAddress
            if (!fromLink.isNullOrBlank()) return fromLink
        }

        return runCatching {
            val interfaces = NetworkInterface.getNetworkInterfaces() ?: return null
            Collections.list(interfaces).forEach { nif ->
                if (!nif.isUp || nif.isLoopback) return@forEach
                Collections.list(nif.inetAddresses).forEach { inet ->
                    if (inet is Inet4Address && !inet.isLoopbackAddress) {
                        return inet.hostAddress
                    }
                }
            }
            null
        }.getOrNull()
    }

    private fun getWifiNetwork(existingManager: ConnectivityManager? = null): Network? {
        val connectivityManager = existingManager
            ?: (getSystemService(Context.CONNECTIVITY_SERVICE) as? ConnectivityManager ?: return null)
        connectivityManager.allNetworks?.forEach { network ->
            val caps = connectivityManager.getNetworkCapabilities(network)
            if (caps?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) == true &&
                caps.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            ) {
                return network
            }
        }
        @Suppress("DEPRECATION")
        val info = connectivityManager.activeNetworkInfo
        @Suppress("DEPRECATION")
        return if (info?.type == ConnectivityManager.TYPE_WIFI && info.isConnected) {
            connectivityManager.activeNetwork
        } else {
            null
        }
    }

    private fun isVpnBlockingLocalAccess(): Boolean {
        val connectivityManager = getSystemService(Context.CONNECTIVITY_SERVICE) as? ConnectivityManager
            ?: return false

        val hasWifi = getWifiNetwork(connectivityManager) != null
        val vpnActive = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            val activeCaps = connectivityManager.getNetworkCapabilities(connectivityManager.activeNetwork)
            val activeVpn = activeCaps?.hasTransport(NetworkCapabilities.TRANSPORT_VPN) == true
            val otherVpn = connectivityManager.allNetworks?.any { network ->
                connectivityManager.getNetworkCapabilities(network)?.hasTransport(NetworkCapabilities.TRANSPORT_VPN) == true
            } ?: false
            activeVpn || otherVpn
        } else {
            @Suppress("DEPRECATION")
            val vpnInfo = connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_VPN)
            @Suppress("DEPRECATION")
            vpnInfo?.isConnected == true
        }

        return vpnActive && !hasWifi
    }

    private fun resolveLocalSubnet(): String? {
        val localIp = getWifiIpv4Address() ?: getLocalIpv4Address() ?: return null
        val octets = localIp.split('.')
        if (octets.size != 4) return null
        return "${octets[0]}.${octets[1]}.${octets[2]}"
    }

    private fun probeAdbPort(host: String, port: Int, timeoutMs: Int): Int? {
        return try {
            Socket().use { socket ->
                val start = SystemClock.elapsedRealtime()
                socket.connect(InetSocketAddress(host, port), timeoutMs)
                (SystemClock.elapsedRealtime() - start).toInt()
            }
        } catch (_: Exception) {
            null
        }
    }

    private fun sendAdbScanResults() {
        if (!hasWebView()) return
        val snapshot = adbScanResults.values
            .map { it }
            .sortedBy { it.ip }
        val array = JSONArray()
        snapshot.forEach { host ->
            val obj = JSONObject()
            obj.put("ip", host.ip)
            obj.put("port", host.port)
            obj.put("friendlyName", host.friendlyName ?: JSONObject.NULL)
            array.put(obj)
        }
        val payload = array.toString()
        runOnUiThread {
            if (hasWebView()) {
                webView.evaluateJavascript(
                    "window.__applyAdbScanResults && window.__applyAdbScanResults($payload);",
                    null
                )
            }
            lastDiscoveryUpdate.set(SystemClock.elapsedRealtime())
        }
    }

    private fun sendAdbScanStatus(message: String, running: Boolean) {
        if (!hasWebView()) return
        val js = """
            window.__handleAdbScanStatus &&
            window.__handleAdbScanStatus(
                ${JSONObject.quote(message)},
                ${if (running) "true" else "false"},
                ${adbScanResults.size}
            );
        """.trimIndent()
        runOnUiThread {
            if (hasWebView()) {
                webView.evaluateJavascript(js, null)
            }
            lastDiscoveryUpdate.set(SystemClock.elapsedRealtime())
        }
    }

    private fun waitForDiscoveryQuietPeriod(timeoutMs: Long, pollMs: Long) {
        val deadline = SystemClock.elapsedRealtime() + timeoutMs
        while (!adbScanStopRequested.get()) {
            val sinceLastUpdate = SystemClock.elapsedRealtime() - lastDiscoveryUpdate.get()
            if (sinceLastUpdate >= timeoutMs) break
            if (SystemClock.elapsedRealtime() >= deadline) break
            try {
                Thread.sleep(pollMs)
            } catch (_: InterruptedException) {
                break
            }
        }
    }

    private fun scheduleAdbProbe(host: String, port: Int, timeoutMs: Int, requestId: String) {
        val timeout = timeoutMs.coerceIn(200, 2000)
        adbProbeExecutor.execute {
            val latency = try {
                Socket().use { socket ->
                    val start = SystemClock.elapsedRealtime()
                    socket.connect(InetSocketAddress(host, port), timeout)
                    
                    // –ï—Å–ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ - —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –ø–æ—Ä—Ç 5555 –æ—Ç–∫—Ä—ã—Ç
                    // –≠—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –¥–ª—è ADB —Å–∫–∞–Ω–µ—Ä–æ–≤
                    SystemClock.elapsedRealtime() - start
                }
            } catch (e: java.net.ConnectException) {
                // –ü–æ—Ä—Ç –∑–∞–∫—Ä—ã—Ç –∏–ª–∏ —Ö–æ—Å—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                null
            } catch (e: java.net.SocketTimeoutException) {
                // –¢–∞–π–º–∞—É—Ç - –ø–æ—Ä—Ç –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç–∫—Ä—ã—Ç, –Ω–æ –º–µ–¥–ª–µ–Ω–Ω–æ –æ—Ç–≤–µ—á–∞–µ—Ç
                null
            } catch (e: java.net.NoRouteToHostException) {
                // –•–æ—Å—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                null
            } catch (_: Exception) {
                // –î—Ä—É–≥–∏–µ —Å–µ—Ç–µ–≤—ã–µ –æ—à–∏–±–∫–∏
                null
            }
            val latencyStr = latency?.toString() ?: "null"
            val js = "window.__handleAdbProbeResult && window.__handleAdbProbeResult(${JSONObject.quote(requestId)}, $latencyStr);"
            runOnUiThread {
                if (hasWebView()) webView.evaluateJavascript(js, null)
            }
        }
    }

        override fun dispatchKeyEvent(event: KeyEvent): Boolean {
            // 1) –ì–ª—É—à–∏–º –ª—é–±—ã–µ –ø–æ–≤—Ç–æ—Ä—ã —É–¥–µ—Ä–∂–∞–Ω–∏—è OK/Enter (DOWN —Å repeatCount > 0)
            if (event.action == KeyEvent.ACTION_DOWN &&
                event.repeatCount > 0 &&
                isOkKey(event.keyCode)
            ) {
                return true // —Å—ä–µ–ª–∏ –ø–æ–≤—Ç–æ—Ä
            }

            // 2) –ù–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –ø—Ä–æ—à–∏–≤–∫–∞—Ö –ø—Ä–∏–ª–µ—Ç–∞–µ—Ç ACTION_MULTIPLE ‚Äî —Ç–æ–∂–µ –≥–ª—É—à–∏–º
            if (event.action == KeyEvent.ACTION_MULTIPLE && isOkKey(event.keyCode)) {
                return true
            }

            return super.dispatchKeyEvent(event)
        }

        private fun isOkKey(code: Int): Boolean {
            return when (code) {
                KeyEvent.KEYCODE_DPAD_CENTER,
                KeyEvent.KEYCODE_ENTER,
                KeyEvent.KEYCODE_NUMPAD_ENTER,
                KeyEvent.KEYCODE_BUTTON_A -> true  // –Ω–∞ —Ä—è–¥–µ –ø—É–ª—å—Ç–æ–≤ ¬´–û–ö¬ª –º–∞–ø–∏—Ç—Å—è —Å—é–¥–∞
                else -> false
            }
        }

        // (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Ç–∫–ª—é—á–∏—Ç—å ¬´–¥–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ¬ª –≥–ª–æ–±–∞–ª—å–Ω–æ
        override fun onKeyLongPress(keyCode: Int, event: KeyEvent): Boolean {
            if (isOkKey(keyCode)) return true // —Å—ä–µ–ª–∏ long-press —Ü–µ–ª–∏–∫–æ–º
            return super.onKeyLongPress(keyCode, event)
        }
    

      

    fun openFilePicker(callback: (String) -> Unit) {
        
        filePickerCallback = callback
        val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
            addCategory(Intent.CATEGORY_OPENABLE)
            type = "*/*"
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION)
        }
        startActivityForResult(intent, REQUEST_CODE_PICK_FILE)
    }

    fun openApkFilePicker() {
        pendingApkPicker = true
        val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
            addCategory(Intent.CATEGORY_OPENABLE)
            // –°—Ç–∞–≤–∏–º */* –∏ —É–±–∏—Ä–∞–µ–º EXTRA_MIME_TYPES.
            // –≠—Ç–æ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–ø–æ—Å–æ–± –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å, —á—Ç–æ .apks –±—É–¥—É—Ç –∞–∫—Ç–∏–≤–Ω—ã,
            // –µ—Å–ª–∏ —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –∑–Ω–∞–µ—Ç –∏—Ö MIME-—Ç–∏–ø. –õ–∏—à–Ω–µ–µ –æ—Ç—Å–µ—á–µ—Ç –Ω–∞—à —Ñ–∏–ª—å—Ç—Ä –ø—Ä–∏ –≤—ã–±–æ—Ä–µ.
            type = "*/*"
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION)
            putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)
        }
        startActivityForResult(intent, REQUEST_CODE_PICK_FILE)
    }
    
    fun openAdbUploadPicker() {
        val connected = adbManager.getCurrentStatus().isConnected
        if (!connected) {
            if (hasWebInterface()) {
                webInterface.sendMessageToWebView("‚ùå ADB –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω")
            }
            return
        }
        pendingAdbUploadPicker = true
        val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
            addCategory(Intent.CATEGORY_OPENABLE)
            type = "*/*"
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION)
            putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)
        }
        startActivityForResult(intent, REQUEST_CODE_PICK_FILE)
    }
    
    // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –º–µ—Ç–æ–¥–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏
    private fun getInstallMethod(): String {
        val prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        return prefs.getString(KEY_INSTALL_METHOD, INSTALL_METHOD_SAI) ?: INSTALL_METHOD_SAI
    }
    
    private fun setInstallMethod(method: String) {
        val prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        prefs.edit { putString(KEY_INSTALL_METHOD, method) }
    }
    
    fun getInstallMethodForWeb(): String {
        return getInstallMethod()
    }
    
    fun setInstallMethodFromWeb(
        method: String,
        silent: Boolean = false,
        autoReason: String? = null
    ) {
        val normalized = method.lowercase(Locale.ROOT)
        val previous = getInstallMethod()
        val changed = !previous.equals(normalized, ignoreCase = true)

        setInstallMethod(normalized)

        if (!normalized.equals(INSTALL_METHOD_ADB, ignoreCase = true)) {
            adbManager.disconnect(resetPreferredTarget = true)
            notifyAdbStatusChanged()
        }

        val humanReadable = when (normalized) {
            INSTALL_METHOD_SAI -> "–ë—ã—Å—Ç—Ä–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞"
            INSTALL_METHOD_STANDARD -> "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞"
            INSTALL_METHOD_ADB -> "–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —á–µ—Ä–µ–∑ ADB"
            else -> method
        }

        when {
            !silent -> webInterface.sendMessageToWebView("‚úÖ –ú–µ—Ç–æ–¥ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∏–∑–º–µ–Ω–µ–Ω –Ω–∞: $humanReadable")
            autoReason == INSTALL_METHOD_AUTO_REASON_ADB && changed -> webInterface.sendMessageToWebView(
                "‚ÑπÔ∏è –ú–µ—Ç–æ–¥ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á—ë–Ω –Ω–∞: $humanReadable"
            )
            silent && autoReason != null && changed -> webInterface.sendMessageToWebView(
                "‚ÑπÔ∏è –ú–µ—Ç–æ–¥ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á—ë–Ω –Ω–∞: $humanReadable"
            )
        }
    }

    data class LastAdbConnection(
        val host: String,
        val port: Int,
        val label: String,
        val friendly: String?
    )

    private fun sanitizeFriendlyName(host: String, port: Int, friendly: String?): String {
        if (friendly.isNullOrBlank()) return ""
        var result = friendly.trim()
        val hostPort = if (port > 0) "$host:$port" else null
        if (!hostPort.isNullOrBlank()) {
            result = result.replace(hostPort, "", ignoreCase = true)
        }
        result = result.replace(host, "", ignoreCase = true)
        result = result.replace(Regex("\\s+"), " ").trim()
        result = result.trim('-', ',', ':', ';')
        return result.trim()
    }

    private fun saveLastAdbConnection(host: String?, port: Int, friendlyLabel: String?) {
        val safeHost = host?.trim().orEmpty()
        if (safeHost.isEmpty()) return
        val friendly = sanitizeFriendlyName(safeHost, port, friendlyLabel)
        val label = buildAdbConnectionLabel(safeHost, friendly.takeIf { it.isNotBlank() })
        val prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        prefs.edit {
            putString(KEY_LAST_ADB_HOST, safeHost)
            putInt(KEY_LAST_ADB_PORT, port)
            putString(KEY_LAST_ADB_LABEL, label)
            putString(KEY_LAST_ADB_FRIENDLY, friendly)
        }
        notifyLastAdbConnectionChanged()
    }

    private fun getLastAdbConnection(): LastAdbConnection? {
        val prefs = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val host = prefs.getString(KEY_LAST_ADB_HOST, "").orEmpty()
        if (host.isBlank()) return null
        val port = prefs.getInt(KEY_LAST_ADB_PORT, 5555)
        val label = prefs.getString(KEY_LAST_ADB_LABEL, "").orEmpty()
        val friendlyRaw = prefs.getString(KEY_LAST_ADB_FRIENDLY, "").orEmpty()
        val friendly = sanitizeFriendlyName(host, port, friendlyRaw)
        return LastAdbConnection(
            host,
            port,
            if (label.isNotBlank()) label else host,
            friendly.takeIf { it.isNotBlank() }
        )
    }

    fun notifyLastAdbConnectionChanged() {
        if (!hasWebView()) return
        webView.post {
            if (hasWebView()) {
                webView.evaluateJavascript("window.refreshLastAdbConnection && window.refreshLastAdbConnection();", null)
            }
        }
    }

    private fun buildAdbConnectionLabel(hostRaw: String?, friendly: String?): String {
        val host = hostRaw?.trim().orEmpty().ifBlank { "127.0.0.1" }
        if (host.equals("127.0.0.1", true) || host.equals("localhost", true)) {
            return "–õ–æ–∫–∞–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"
        }
        val friendlyTrimmed = friendly?.trim().orEmpty()
        return if (friendlyTrimmed.isNotBlank()) "$friendlyTrimmed $host" else host
    }

    private fun installApkFromUri(uri: Uri, onComplete: (() -> Unit)? = null) {
        val mainHandler = Handler(Looper.getMainLooper())
        val completion = AtomicBoolean(false)
        fun finish() {
            if (onComplete != null && completion.compareAndSet(false, true)) {
                mainHandler.post { onComplete.invoke() }
            }
        }

        Thread {
            try {
                val displayName = getDisplayName(uri) ?: "temp_${System.currentTimeMillis()}"
                val ext = displayName.substringAfterLast('.', "").lowercase()
                val isApks = ext == "apks"

                val tempFile = File(cacheDir, "picked_${System.currentTimeMillis()}.${if (isApks) "apks" else "apk"}")
                contentResolver.openInputStream(uri)?.use { input ->
                    FileOutputStream(tempFile).use { output ->
                        input.copyTo(output)
                    }
                }

                if (isApks || tempFile.extension.equals("apks", true)) {
                    webInterface.sendMessageToWebView("üì¶ –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ –ø–∞–∫–µ—Ç–∞‚Ä¶")
                    val splits = webInterface.unzipApksContainer(tempFile)
                    if (splits.isEmpty()) {
                        webInterface.sendMessageToWebView("‚ùå –í –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ .apks –Ω–µ –Ω–∞–π–¥–µ–Ω–æ APK-—Ñ–∞–π–ª–æ–≤")
                        tempFile.delete()
                        finish()
                        return@Thread
                    }
                    val primary = splits.firstOrNull { it.name.equals("base.apk", true) } ?: splits.first()
                    val meta = extractApkMeta(this, primary)
                    val cleanupSplits = {
                        runCatching {
                            splits.forEach { it.delete() }
                            splits.firstOrNull()?.parentFile?.delete()
                            tempFile.delete()
                        }
                    }
                    val method = getInstallMethod()
                    if (method.equals(INSTALL_METHOD_ADB, ignoreCase = true)) {
                        val appName = meta.label.ifBlank { primary.nameWithoutExtension }
                        mainHandler.post {
                            webInterface.sendMessageToWebView("üîå –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ ADB‚Ä¶")
                        }
                        val ok = try {
                            adbManager.installSplitApks(splits, meta.label) { progress ->
                                mainHandler.post { webInterface.sendMessageToWebView(progress) }
                            }
                        } catch (_: Exception) {
                            false
                        }
                        mainHandler.post {
                            if (ok) {
                                webInterface.sendMessageToWebView("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: $appName", meta.iconBase64)
                            } else {
                                webInterface.sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ ADB —É—Å—Ç–∞–Ω–æ–≤–∫–∏: $appName")
                            }
                            cleanupSplits()
                            finish()
                        }
                    } else {
                        mainHandler.post {
                            webInterface.totalApks = 1
                            webInterface.currentApkIndex = 0
                            val sai = SessionApkInstaller(this@MainActivity, { msg, icon ->
                                webInterface.sendMessageToWebView(msg, icon)
                            }, meta.iconBase64)
                            sai.onFinal = {
                                sai.unregister()
                                cleanupSplits()
                                finish()
                            }
                            sai.register()
                            sai.install(splits)
                        }
                    }
                } else {
                    val meta = extractApkMeta(this, tempFile)
                    val method = getInstallMethod()
                    mainHandler.post {
                        when (method) {
                            INSTALL_METHOD_ADB -> {
                                webInterface.sendMessageToWebView("üîå –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ ADB‚Ä¶")
                                Thread {
                                    val ok = try {
                                        adbManager.installApk(tempFile) { progress ->
                                            mainHandler.post { webInterface.sendMessageToWebView(progress) }
                                        }
                                    } catch (_: Exception) {
                                        false
                                    }
                                    mainHandler.post {
                                        val appName = meta.label.ifBlank { tempFile.nameWithoutExtension }
                                        if (ok) {
                                            webInterface.sendMessageToWebView("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: $appName", meta.iconBase64)
                                        } else {
                                            webInterface.sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ ADB —É—Å—Ç–∞–Ω–æ–≤–∫–∏: $appName")
                                        }
                                        tempFile.delete()
                                        finish()
                                    }
                                }.start()
                            }
                            else -> {
                                webInterface.totalApks = 1
                                webInterface.currentApkIndex = 0
                                webInterface.sendMessageToWebView("üì± –£—Å—Ç–∞–Ω–æ–≤–∫–∞ APK: ${meta.label}")
                                val sai = SessionApkInstaller(this@MainActivity, { msg, icon ->
                                    webInterface.sendMessageToWebView(msg, icon)
                                }, meta.iconBase64)
                                sai.register()
                                sai.install(listOf(tempFile))
                                sai.onFinal = {
                                    sai.unregister()
                                    tempFile.delete()
                                    finish()
                                }
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                mainHandler.post {
                    webInterface.sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: ${e.message}")
                    finish()
                }
            }
        }.start()
    }

    private fun getDisplayName(uri: Uri): String? {
        return try {
            contentResolver.query(uri, arrayOf(OpenableColumns.DISPLAY_NAME), null, null, null)?.use { c ->
                if (c.moveToFirst()) c.getString(0) else null
            }
        } catch (_: Exception) { null }
    }

    private fun isAllowedApkUri(uri: Uri): Boolean {
        val name = (getDisplayName(uri) ?: uri.lastPathSegment ?: "").lowercase()
        return name.endsWith(".apk") || name.endsWith(".apks")
    }

    // –°—á—ë—Ç—á–∏–∫–∏ –∏ —Ñ–ª–∞–≥ –æ—Ç–º–µ–Ω—ã –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π —É—Å—Ç–∞–Ω–æ–≤–∫–∏ (APK+)
    private var totalApksLocal = 0
    private var currentApkIndexLocal = 0
    private var isInstallingCancelledLocal = false
    
    // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
    private var totalUploadFiles = 0
    private var currentUploadIndex = 0
    private var isUploadCancelledLocal = false

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)

        if (requestCode == REQUEST_CODE_PICK_FILE && resultCode == RESULT_OK) {
            isInstallingCancelledLocal = false
            val clipData = data?.clipData
            if (pendingApkPicker) {
                val selected = mutableListOf<Uri>()
                if (clipData != null) {
                    for (i in 0 until clipData.itemCount) {
                        clipData.getItemAt(i)?.uri?.let { uri ->
                            runCatching {
                                contentResolver.takePersistableUriPermission(uri, Intent.FLAG_GRANT_READ_URI_PERMISSION)
                            }
                            selected += uri
                        }
                    }
                } else {
                    data?.data?.let { single ->
                        runCatching {
                            contentResolver.takePersistableUriPermission(single, Intent.FLAG_GRANT_READ_URI_PERMISSION)
                        }
                        selected += single
                    }
                }
                pendingApkPicker = false
                if (selected.isEmpty()) {
                    if (this::webInterface.isInitialized) {
                        webInterface.sendMessageToWebView("‚ùó–§–∞–π–ª—ã –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –Ω–µ –≤—ã–±—Ä–∞–Ω—ã")
                    }
                    return
                }

                // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ apk/apks
                val allowed = selected.filter { isAllowedApkUri(it) }
                if (allowed.isEmpty()) {
                    Handler(Looper.getMainLooper()).post {
                        Toast.makeText(this, "‚ùó–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–ª—å–∫–æ APK/APKS", Toast.LENGTH_SHORT).show()
                        if (hasWebInterface()) {
                            webInterface.sendMessageToWebView("‚ùó–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–ª—å–∫–æ APK/APKS")
                        }
                    }
                    return
                }

                // –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å —Å—á–µ—Ç—á–∏–∫ –∏ –ø–æ–∫–∞–∑–∞—Ç—å –±–ª–æ–∫–∏—Ä—É—é—â–∏–π –¥–∏–∞–ª–æ–≥
                if (hasWebInterface()) {
                    webInterface.showInstallBlocking(allowed.size, 0)
                }
                totalApksLocal = allowed.size
                currentApkIndexLocal = 0
                installSelectedUrisSequential(allowed)
                return
            }

            if (pendingAdbUploadPicker) {
                val selected = mutableListOf<Uri>()
                if (clipData != null) {
                    for (i in 0 until clipData.itemCount) {
                        clipData.getItemAt(i)?.uri?.let { uri ->
                            runCatching {
                                contentResolver.takePersistableUriPermission(uri, Intent.FLAG_GRANT_READ_URI_PERMISSION)
                            }
                            selected += uri
                        }
                    }
                } else {
                    data?.data?.let { single ->
                        runCatching {
                            contentResolver.takePersistableUriPermission(single, Intent.FLAG_GRANT_READ_URI_PERMISSION)
                        }
                        selected += single
                    }
                }
                pendingAdbUploadPicker = false
                if (selected.isEmpty()) {
                    if (hasWebInterface()) {
                        webInterface.sendMessageToWebView("‚ùó–§–∞–π–ª—ã –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–µ –≤—ã–±—Ä–∞–Ω—ã")
                    }
                    return
                }
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –±–ª–æ–∫–∏—Ä—É—é—â–∏–π –¥–∏–∞–ª–æ–≥ —Å–æ —Å—á—ë—Ç—á–∏–∫–æ–º
                if (hasWebInterface()) {
                    totalUploadFiles = selected.size
                    currentUploadIndex = 0
                    isUploadCancelledLocal = false
                    webInterface.showUploadBlocking(totalUploadFiles, 0)
                }
                uploadUrisToRemoteDownload(selected)
                return
            }

            if (clipData != null) {
                for (i in 0 until clipData.itemCount) {
                    val itemUri = clipData.getItemAt(i)?.uri ?: continue
                    runCatching { contentResolver.takePersistableUriPermission(itemUri, Intent.FLAG_GRANT_READ_URI_PERMISSION) }
                    filePickerCallback?.invoke(itemUri.toString())
                }
                filePickerCallback = null
                return
            }

            val uri = data?.data
            uri?.let {
                contentResolver.takePersistableUriPermission(it, Intent.FLAG_GRANT_READ_URI_PERMISSION)
                filePickerCallback?.invoke(it.toString())
                filePickerCallback = null
            }
        }
    }

    private fun installSelectedUrisSequential(uris: List<Uri>, index: Int = 0) {
        if (isInstallingCancelledLocal) return
        if (index >= uris.size) {
            Handler(Looper.getMainLooper()).post {
                if (hasWebInterface()) {
                    webInterface.sendMessageToWebView("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
                    webInterface.totalApks = 0
                    webInterface.currentApkIndex = 0
                    webInterface.hideInstallBlocking()
                }
                if (hasWebView()) {
                    webView.evaluateJavascript("hideProgress()", null)
                }
            }
            return
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è –¥–∏–∞–ª–æ–≥–∞/–≤–µ–±
        currentApkIndexLocal = index
        if (hasWebInterface()) {
            webInterface.totalApks = uris.size
            webInterface.currentApkIndex = index
            webInterface.setInstallBlockingProgress(index)
        }

        val uri = uris[index]
        val displayName = getDisplayName(uri) ?: "–§–∞–π–ª ${index + 1}"
        Handler(Looper.getMainLooper()).post {
            if (hasWebInterface()) {
                webInterface.sendMessageToWebView("üì• –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ñ–∞–π–ª–∞ ${(index + 1)} –∏–∑ ${uris.size}: $displayName")
            }
            if (hasWebView()) {
                val safeName = displayName.jsEscape()
                webView.evaluateJavascript("showProgress(${index + 1}, ${uris.size}, 0, '$safeName')", null)
            }
        }

        installApkFromUri(uri) {
            Handler(Looper.getMainLooper()).post {
                if (hasWebView()) {
                    webView.evaluateJavascript("updateProgress(${index + 1}, ${uris.size}, 100)", null)
                }
                // –ü—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ç–µ–∫—É—â–µ–≥–æ APK —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á—ë—Ç—á–∏–∫ –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –¥–∏–∞–ª–æ–≥
                currentApkIndexLocal = index + 1
                if (hasWebInterface()) {
                    webInterface.setInstallBlockingProgress(index + 1)
                }
            }
            installSelectedUrisSequential(uris, index + 1)
        }
    }

    private fun uploadUrisToRemoteDownload(uris: List<Uri>, index: Int = 0) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–º–µ–Ω—É
        if (isUploadCancelledLocal) {
            Handler(Looper.getMainLooper()).post {
                if (hasWebInterface()) {
                    webInterface.hideBlockingDialog()
                }
            }
            return
        }
        
        if (uris.isEmpty()) {
            Handler(Looper.getMainLooper()).post {
                if (hasWebInterface()) {
                    webInterface.sendMessageToWebView("‚ùó–§–∞–π–ª—ã –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–µ –≤—ã–±—Ä–∞–Ω—ã")
                    webInterface.hideBlockingDialog()
                }
            }
            return
        }
        if (index >= uris.size) {
            Handler(Looper.getMainLooper()).post {
                if (hasWebInterface()) {
                    webInterface.sendMessageToWebView("‚úÖ –ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
                    webInterface.hideBlockingDialog()
                }
            }
            return
        }

        // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑ –¥–ª—è –≤—Å–µ–π —Å–µ—Ä–∏–∏
        if (index == 0) {
            adbManager.ensureRemoteDirectory(REMOTE_DOWNLOAD_DIR)
        }

        val uri = uris[index]
        Thread {
            val handler = Handler(Looper.getMainLooper())
            val displayName = (getDisplayName(uri)
                ?: uri.lastPathSegment
                ?: "–§–∞–π–ª ${index + 1}").ifBlank { "–§–∞–π–ª ${index + 1}" }

            handler.post {
                if (hasWebInterface()) {
                    webInterface.sendMessageToWebView("‚¨ÜÔ∏è –ó–∞–≥—Ä—É–∂–∞—é $displayName –≤ –ó–∞–≥—Ä—É–∑–∫–∏‚Ä¶")
                }
            }

            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –±–µ–∑ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –∏ –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ mkdir
            val remotePath = adbManager.pushUriToDeviceOptimized(uri, REMOTE_DOWNLOAD_DIR, displayName) { progress ->
                handler.post {
                    if (hasWebInterface()) {
                        webInterface.sendMessageToWebView(progress)
                    }
                }
            }
            
            if (remotePath != null) {
                registerRemoteBackup(remotePath)
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á—ë—Ç—á–∏–∫ –∑–∞–≥—Ä—É–∑–∫–∏
                currentUploadIndex = index + 1
                if (hasWebInterface()) {
                    webInterface.updateBlockingUploadProgress()
                }
            }

            handler.post {
                if (hasWebInterface()) {
                    if (remotePath != null) {
                        webInterface.sendMessageToWebView("‚úÖ $displayName –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ –ó–∞–≥—Ä—É–∑–∫–∏ —É–¥–∞–ª—ë–Ω–Ω–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞")
                    } else {
                        webInterface.sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ $displayName")
                    }
                }
            }

            uploadUrisToRemoteDownload(uris, index + 1)
        }.start()
    }

    private fun copyUriToTempFile(uri: Uri, displayName: String?): File? {
        return try {
            val safeExt = displayName
                ?.substringAfterLast('.', "")
                ?.takeIf { it.isNotBlank() }
                ?.replace(Regex("[^A-Za-z0-9]"), "")
                ?.take(8)
            val suffix = safeExt?.let { ".$it" }
            val temp = if (suffix.isNullOrBlank()) {
                File.createTempFile("adb_upload_", null, cacheDir)
            } else {
                File.createTempFile("adb_upload_", suffix, cacheDir)
            }
            contentResolver.openInputStream(uri)?.use { input ->
                FileOutputStream(temp).use { output ->
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—Ä—É–ø–Ω—ã–π –±—É—Ñ–µ—Ä, —á—Ç–æ–±—ã –±—ã—Å—Ç—Ä–µ–µ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å APK –≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                    val bufferSize = 512 * 1024
                    input.copyTo(output, bufferSize)
                }
            } ?: return null
            temp
        } catch (_: Exception) {
            null
        }
    }


    override fun onBackPressed() {
        if (!hasWebView()) { super.onBackPressed(); return }

        if (handleOfflineBack()) return

        if (hasWebView() && webView.canGoBack()) {
            webView.goBack()
            return
        }

        webView.evaluateJavascript(
            """
        (function() {
            var modal = document.getElementById('modal');
            if (modal && modal.style.display === 'flex') {
                modal.style.display = 'none';
                return true;
            }
            return false;
        })();
        """.trimIndent()
        ) { result ->
            if (result != "true") {
                super.onBackPressed()
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        stopStorageUsageUpdates()
        storageUsageExecutor.shutdownNow()
        statusRefreshHandler.removeCallbacks(delayedStatusRunnable)
        deviceDiscoveryOrNull()?.shutdown()
    }

    private fun handleOfflineBack(): Boolean {
        if (!isOfflineMode) return false
        isOfflineMode = false
        moveTaskToBack(true)
        return true
    }

    private fun startStorageUsageUpdates() {
        if (storageUsageUpdatesActive) return
        storageUsageUpdatesActive = true
        requestStorageUsageUpdate()
    }

    private fun stopStorageUsageUpdates() {
        storageUsageUpdatesActive = false
    }

    fun requestStorageUsageUpdate() {
        try {
            storageUsageExecutor.execute { sendStorageUsageToWeb() }
        } catch (_: RejectedExecutionException) {
        }
    }

    private fun sendStorageUsageToWeb() {
        val usage = runCatching { fetchStorageUsage() }.getOrNull()
        val label = usage?.let { formatStorageUsage(it) } ?: ""
        lastStorageUsageLabel = label
        pushStorageUsageToWeb()
    }

    private fun pushStorageUsageToWeb() {
        if (!hasWebView()) return
        val jsArg = JSONObject.quote(lastStorageUsageLabel)
        webView.post {
            if (hasWebView()) {
                webView.evaluateJavascript("window.updateStorageUsage($jsArg)", null)
            }
        }
    }

    private fun scheduleDelayedStatusRefresh(delayMs: Long = 800L) {
        statusRefreshHandler.removeCallbacks(delayedStatusRunnable)
        statusRefreshHandler.postDelayed(delayedStatusRunnable, delayMs)
    }

    private fun fetchStorageUsage(): StorageUsage? {
        val remoteUsage = if (this::adbManager.isInitialized) {
            val status = adbManager.getCurrentStatus()
            if (status.isConnected) queryRemoteStorageUsage(adbManager) else null
        } else null
        return remoteUsage ?: queryLocalStorageUsage()
    }

    @Suppress("DEPRECATION")
    private fun queryLocalStorageUsage(): StorageUsage? {
        val candidatePaths = listOfNotNull(
            getExternalFilesDir(null)?.parentFile?.parentFile?.absolutePath,
            Environment.getExternalStorageDirectory()?.absolutePath,
            Environment.getDataDirectory()?.absolutePath,
            "/storage/emulated/0"
        ).distinct()
        candidatePaths.forEach { path ->
            val usage = runCatching {
                val stat = StatFs(path)
                val total = stat.blockCountLong * stat.blockSizeLong
                val available = stat.availableBlocksLong * stat.blockSizeLong
                if (total > 0) StorageUsage(total - available, total) else null
            }.getOrNull()
            if (usage != null && usage.totalBytes > 0) {
                return usage
            }
        }
        return null
    }

    private fun queryRemoteStorageUsage(adb: AdbConnectionManager): StorageUsage? {
        val commands = listOf(
            "df -k /storage/emulated/0",
            "toybox df -k /storage/emulated/0",
            "busybox df -k /storage/emulated/0"
        )
        commands.forEach { cmd ->
            val output = adb.shellOutput(cmd) ?: return@forEach
            val usage = parseRemoteStorageUsage(output)
            if (usage != null) return usage
        }
        return null
    }

    private fun parseRemoteStorageUsage(raw: String): StorageUsage? {
        val targetPaths = listOf("/storage/emulated/0", "/sdcard", "/storage/self/primary")
        val lines = raw
            .lineSequence()
            .map { it.trim() }
            .filter { it.isNotEmpty() && !it.lowercase(Locale.US).startsWith("filesystem") }
        val line = lines.firstOrNull { current ->
            targetPaths.any { path -> current.endsWith(path) || current.contains(" $path") }
        } ?: lines.firstOrNull() ?: return null
        val tokens = line.split(Regex("\\s+"))
        if (tokens.size < 4) return null
        val totalKb = tokens.getOrNull(1)?.toLongOrNull() ?: return null
        if (totalKb <= 0) return null
        val usedKb = tokens.getOrNull(2)?.toLongOrNull()
        val availableKb = tokens.getOrNull(3)?.toLongOrNull()
        val used = usedKb ?: (if (availableKb != null) totalKb - availableKb else return null)
        val totalBytes = totalKb * 1024L
        val usedBytes = used * 1024L
        return StorageUsage(usedBytes, totalBytes)
    }

    private fun formatStorageUsage(usage: StorageUsage): String {
        val usedGb = usage.usedBytes.coerceAtLeast(0L).toDouble() / (1024.0 * 1024 * 1024)
        val totalGb = usage.totalBytes.coerceAtLeast(1L).toDouble() / (1024.0 * 1024 * 1024)
        return String.format(Locale.US, "%.1f/%.1fGB", usedGb, totalGb)
    }

    private var permissionsChecked = false
    private var askedInstall = false


    override fun onResume() {
        super.onResume()

        if (!startupFlowLaunched) {
            return
        }

        if (!isWebViewAvailable()) {
            if (!webViewSetupInProgress) {
                promptInstallOrPermissions()
            }
            return
        }

        if (hasWebView()) {
            webView.evaluateJavascript("hideProgress()", null)
        }

        if (!permissionsChecked && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val canInstall = packageManager.canRequestPackageInstalls()
            val canOverlay = Settings.canDrawOverlays(this)

            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–µ–¥–ª–æ–∂–∏–º INSTALL, –µ—Å–ª–∏ –µ—â—ë –Ω–µ —Å–ø—Ä–∞—à–∏–≤–∞–ª–∏
            if (!canInstall && !askedInstall) {
                askedInstall = true
                showInstallPrompt(
                    title = "–¢—Ä–µ–±—É–µ—Ç—Å—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ",
                    message = "–î–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–∞–∑—Ä–µ—à–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É –∏–∑ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤.\n\n–ù–∞–∂–º–∏—Ç–µ –†–ê–ó–†–ï–®–ò–¢–¨, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.",
                    installLabel = "–†–ê–ó–†–ï–®–ò–¢–¨",
                    onInstall = {
                        val intent = Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES).apply {
                            data = "package:$packageName".toUri()
                        }
                        startActivity(intent)
                    },
                    laterLabel = "–ü–û–ó–ñ–ï",
                    onLater = {},
                    cancelable = true
                )
                return
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ overlay –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞ –≤ testAutostart()

            permissionsChecked = true
        }

        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—á–µ—Ä–µ–¥—å —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        if (hasWebInterface()) {
            webInterface.resumeInstallationIfNeeded()
        }

        syncAdbConnectionStatusAsync()
        startStorageUsageUpdates()
    }

    override fun onPause() {
        super.onPause()
        stopStorageUsageUpdates()
    }

    private var lastBackPressedTime = 0L
    private val backPressInterval = 2000 // 2 —Å–µ–∫—É–Ω–¥—ã

    override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            if (handleOfflineBack()) return true
            if (hasWebView()) {
                if (webView.canGoBack()) {
                    webView.goBack()
                    return true
                }
                webView.evaluateJavascript("handleBackButton()", null)
                return true
            }
        }
        return super.onKeyDown(keyCode, event)
    }



    private fun checkStoragePermissions() {
        val permissions = arrayOf(
            Manifest.permission.READ_EXTERNAL_STORAGE,
            Manifest.permission.WRITE_EXTERNAL_STORAGE
        )

        val missingPermissions = permissions.filter {
            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
        }

        if (missingPermissions.isNotEmpty()) {
            ActivityCompat.requestPermissions(this, missingPermissions.toTypedArray(), 100)
        }
    }


    private fun showPasswordDialog(current: String?) {
        runOnUiThread {
            val dialogView = LayoutInflater.from(this).inflate(R.layout.dialog_install_prompt, null)
            val root = dialogView.findViewById<LinearLayout>(R.id.dialogRoot)
            val title = dialogView.findViewById<TextView>(R.id.dialogTitle)
            val message = dialogView.findViewById<TextView>(R.id.dialogMessage)
            val permissionsContainer = dialogView.findViewById<LinearLayout>(R.id.permissionsContainer)
            val buttonRow = dialogView.findViewById<LinearLayout>(R.id.buttonRow)
            val btnPositive = dialogView.findViewById<Button>(R.id.btnInstall)
            val btnNegative = dialogView.findViewById<Button>(R.id.btnLater)

            title.text = "–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å"
            title.textAlignment = View.TEXT_ALIGNMENT_CENTER
            message.visibility = View.GONE
            permissionsContainer.visibility = View.GONE

            val inputWrapper = LinearLayout(this).apply {
                orientation = LinearLayout.VERTICAL
                val lp = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT
                )
                lp.topMargin = (12 * resources.displayMetrics.density).toInt()
                layoutParams = lp
            }

            val density = resources.displayMetrics.density
            val et = EditText(this).apply {
                inputType = InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD
                setText(current ?: "")
                setSelection(text?.length ?: 0)
                val pad = (4 * density).toInt()
                setPadding(paddingLeft, pad, paddingRight, pad)
                setTextColor(Color.WHITE)
                setHintTextColor(0x66FFFFFF)
                background = null
            }

            inputWrapper.addView(et)
            val underline = View(this).apply {
                val underlineLp = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    (1 * density).toInt().coerceAtLeast(1)
                )
                underlineLp.topMargin = (1 * density).toInt()
                layoutParams = underlineLp
                setBackgroundColor(0xCCFFFFFF.toInt())
            }
            inputWrapper.addView(underline)
            root.addView(inputWrapper, root.indexOfChild(buttonRow))

            buttonRow.gravity = Gravity.END or Gravity.CENTER_VERTICAL
            btnPositive.text = "OK"
            btnNegative.text = "–û—Ç–º–µ–Ω–∞"

            val dialog = AlertDialog.Builder(this, R.style.CustomDialogTheme)
                .setView(dialogView)
                .setCancelable(true)
                .create()

            btnPositive.setOnClickListener {
                val pwd = et.text?.toString() ?: ""
                webView.evaluateJavascript(
                    "setPasswordFromAndroid(${JSONObject.quote(pwd)})",
                    null
                )
                dialog.dismiss()
            }

            btnNegative.setOnClickListener {
                dialog.dismiss()
            }

            dialog.show()
        }
    }

    inner class WebAppInterface(
        private val context: Context,
        private val webView: WebView,

    ) {

        val installQueue = mutableListOf<QueueItem>()

        private val launcherPackages = listOf(
            "com.google.android.tvlauncher",
            "com.android.tvlauncher",
            "com.google.android.apps.tv.launcherx",
            "com.google.android.tvlauncherx",
            "com.android.launcher",
            "com.android.launcher3",
            "com.tcl.browser",
            "com.tcl.tvlauncher",
            "com.sony.dtv.tvx",
            "com.google.android.apps.atvwidgets",
            "com.amazon.tv.launcher",
            "com.amazon.tv.launcherx",
            "com.xiaomi.mitv.tvlauncher",
            "com.hisense.vidaav",
            "com.hisense.hismart",
            "ru.iptvlauncher.tv",
            "com.realtek.tvlauncher",
            "com.droidlogic.launcher"
        )

        private val protectedCorePackages = setOf(
            "com.android.settings",
            "com.android.tv.settings",
            "com.google.android.tv.settings",
            "com.android.systemui",
            "com.google.android.gms",
            "com.google.android.gsf",
            "com.android.vending",
            "com.google.android.youtube.tv",
            "com.google.android.tvrecommendations",
            "com.google.android.inputmethod.latin",
            "com.android.inputmethod.latin",
            "com.google.android.katniss",
            "com.android.remotecontrolservice",
            "com.android.providers.downloads",
            "com.android.providers.media",
            "com.android.shell",
            "com.android.bluetooth",
            "com.android.tv.remote.service",
            "com.android.carrierconfig",
            "com.android.traceur"
        )

        private val baseWipeExclusions: Set<String> = buildSet {
            addAll(launcherPackages)
            addAll(protectedCorePackages)
            addAll(
                listOf(
                    "com.alphainventor.filemanager",
                    "com.anydesk.anydeskandroid",
                    "com.topjohnwu.magisk",
                    "com.google.android.webview",
                    "com.android.webview"
                )
            )
        }

        private val systemFlagMarkers = setOf(
            "SYSTEM",
            "PERSISTENT",
            "PRIVILEGED",
            "CORE",
            "REQUIRED_FOR_SYSTEM_USER",
            "UPDATED_SYSTEM_APP"
        )

        private val systemPathPrefixes = listOf(
            "/system/",
            "/system_ext/",
            "/product/",
            "/product_services/",
            "/vendor/",
            "/oem/",
            "/odm/",
            "/mi_ext/",
            "/cust/"
        )

        private val userAppPathMarkers = listOf(
            "/data/app/",
            "/data/app-private/",
            "/mnt/expand/"
        )

        private val microphonePermissionPackages = listOf(
            "com.google.android.youtube.tv",
            "org.liskovsoft.androidtv.rukeyboard"
        )

        private val microphonePermission: String = "android.permission.RECORD_AUDIO"

        private val autoPermissionExcludedPackages = setOf(
            "com.anydesk.anydeskandroid"
        )

        private fun runCommand(args: List<String>): Pair<Boolean, String> {
            return try {
                val process = ProcessBuilder(args)
                    .redirectErrorStream(true)
                    .start()
                val output = process.inputStream.bufferedReader().use { it.readText() }.trim()
                val code = process.waitFor()
                (code == 0) to output
            } catch (e: Exception) {
                false to (e.message ?: "unknown error")
            }
        }

        private fun runSuCommand(command: String): Pair<Boolean, String> =
            runCommand(listOf("su", "-c", command))

        private fun runShCommand(command: String): Pair<Boolean, String> =
            runCommand(listOf("sh", "-c", command))

        private fun readCpuTemp(): String {
            fun readThermalZones(): String? {
                return try {
                    val dir = java.io.File("/sys/class/thermal")
                    val zones = dir.listFiles { f -> f.isDirectory && f.name.startsWith("thermal_zone") }
                        ?.sortedBy { it.name }
                        ?: return null

                    fun readTemp(zone: java.io.File): Double? {
                        val tempFile = java.io.File(zone, "temp")
                        if (!tempFile.canRead()) return null
                        val raw = tempFile.readText().trim()
                        val value = raw.toDoubleOrNull() ?: return null
                        return if (value > 200) value / 1000.0 else value
                    }

                    fun readType(zone: java.io.File): String? {
                        val typeFile = java.io.File(zone, "type")
                        return if (typeFile.canRead()) typeFile.readText().trim().lowercase() else null
                    }

                    // –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –ø–æ —Ç–∏–ø–∞–º cpu/soc, –ø–æ—Ç–æ–º –±–µ—Ä—ë–º –ø–µ—Ä–≤–æ–µ –¥–æ—Å—Ç—É–ø–Ω–æ–µ
                    val preferred = zones.firstNotNullOfOrNull { zone ->
                        val t = readType(zone)
                        val temp = readTemp(zone)
                        if (temp != null && t != null && (t.contains("cpu") || t.contains("soc"))) temp else null
                    }
                    val any = preferred ?: zones.firstNotNullOfOrNull { readTemp(it) }
                    any?.let { String.format("%.1f", it) }
                } catch (_: Exception) {
                    null
                }
            }

            fun parseHw(dump: String): String? =
                Regex("CPU temperatures:\\s*\\[([^\\]]+)]", RegexOption.IGNORE_CASE)
                    .find(dump)
                    ?.groupValues
                    ?.getOrNull(1)
                    ?.split(",")
                    ?.firstOrNull()
                    ?.trim()

            fun parseThermal(dump: String): String? =
                Regex("mValue=([0-9.+-]+)", RegexOption.IGNORE_CASE)
                    .find(dump)
                    ?.groupValues
                    ?.getOrNull(1)

            readThermalZones()?.let { return it }

            val hwDumpRoot = runSuCommand("dumpsys hardware_properties").second
            parseHw(hwDumpRoot)?.let { return it }

            val thermalRoot = runSuCommand("dumpsys thermalservice").second
            parseThermal(thermalRoot)?.let { return it }

            val hwDump = runShCommand("dumpsys hardware_properties").second
            parseHw(hwDump)?.let { return it }

            val thermalDump = runShCommand("dumpsys thermalservice").second
            parseThermal(thermalDump)?.let { return it }

            return "n/a"
        }

        private fun readMemAvailable(): String {
            val memInfo = try {
                java.io.File("/proc/meminfo").readText()
            } catch (_: Exception) {
                ""
            }
            val kb = Regex("MemAvailable:\\s*(\\d+)", RegexOption.IGNORE_CASE)
                .find(memInfo)
                ?.groupValues
                ?.getOrNull(1)
                ?.toLongOrNull()
            if (kb != null) return "${kb / 1024}MB"

            val dump = runShCommand("dumpsys meminfo").second
            val alt = Regex("Free RAM:\\s*(\\S+)", RegexOption.IGNORE_CASE)
                .find(dump)
                ?.groupValues
                ?.getOrNull(1)
            return alt ?: "n/a"
        }

        private fun hasRootAccessInternal(): Boolean {
            val (ok, out) = runSuCommand("id")
            return ok && out.contains("uid=0")
        }
        @JavascriptInterface
        fun reloadStartUrl() {
            (context as? Activity)?.runOnUiThread {
                (context as? MainActivity)?.loadStartUrl(forceRefresh = true)
            }
        }

        @JavascriptInterface
        fun openNetworkSettings() {
            val activity = context as? MainActivity
            val adb = obtainConnectedAdb(silent = true)
            if (adb != null) {
                Thread {
                    val commands = listOf(
                        "am start --user 0 -a android.settings.WIFI_SETTINGS",
                        "am start --user 0 -a android.settings.WIRELESS_SETTINGS",
                        "am start -a android.settings.WIFI_SETTINGS",
                        "am start -a android.settings.WIRELESS_SETTINGS"
                    )
                    val executed = commands.any { cmd ->
                        try {
                            adb.runShellCommand(cmd) { } == true
                        } catch (_: Exception) {
                            false
                        }
                    }
                    Handler(Looper.getMainLooper()).post {
                        if (!executed) {
                            sendMessageToWebView("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–µ—Ç–∏ —á–µ—Ä–µ–∑ ADB")
                        }
                    }
                }.start()
                return
            }

            val settingsIntent = Intent(Settings.ACTION_WIFI_SETTINGS)
            val intent = if (settingsIntent.resolveActivity(context.packageManager) != null) {
                settingsIntent
            } else {
                Intent(Settings.ACTION_WIRELESS_SETTINGS)
            }

            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)

            try {
                context.startActivity(intent)
            } catch (_: ActivityNotFoundException) {
            }
        }

        @JavascriptInterface
        fun openRunAdbCommandsModal() {
            Handler(Looper.getMainLooper()).post {
                try {
                    webView.evaluateJavascript("openAdbCommandsModal()", null)
                } catch (e: Exception) {
                    Log.w(ADB_LOG_TAG, "Failed to open ADB commands modal via JS", e)
                }
            }
        }

        @JavascriptInterface
        fun openInternalLink(url: String?) {
            if (url.isNullOrBlank()) return
            val activity = context as? Activity ?: return

            val intent = Intent(activity, FlexWebActivity::class.java).apply {
                putExtra(FlexWebActivity.EXTRA_URL, url)
            }

            activity.startActivity(intent)
        }

        @JavascriptInterface
        fun openFilesPermissionSettings() {
            val activity = context as? MainActivity
            val startedViaAdb = activity?.tryOpenFilesPermissionSettingsViaAdb(context.packageName) { executed, packageExists ->
                if (!packageExists) {
                    showToast("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ ${context.packageName} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "error")
                } else if (!executed) {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª–∞–º –ø–æ ADB", "warning")
                }
            } ?: false
            if (startedViaAdb) return

            Handler(Looper.getMainLooper()).post {
                try {
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                        val intent = Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION).apply {
                            data = Uri.parse("package:${context.packageName}")
                            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        }

                        if (intent.resolveActivity(context.packageManager) != null) {
                            context.startActivity(intent)
                        } else {
                            openAppSettings(context.packageName)
                        }
                    } else {
                        openAppSettings(context.packageName)
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏: ${e.message}", "warning")
                }
            }
        }

        @JavascriptInterface
        fun openFilesPermissionSettingsForPackage(packageName: String) {
            val activity = context as? MainActivity
            val startedViaAdb = activity?.tryOpenFilesPermissionSettingsViaAdb(packageName) { executed, packageExists ->
                if (!packageExists) {
                    showToast("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ $packageName –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "error")
                } else if (!executed) {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª–∞–º –¥–ª—è $packageName –ø–æ ADB", "warning")
                }
            } ?: false
            if (startedViaAdb) return

            Handler(Looper.getMainLooper()).post {
                try {
                    if (!isPackageInstalled(packageName)) {
                        showToast("‚ùå –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ $packageName –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ", "error")
                        return@post
                    }

                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                        val intent = Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION).apply {
                            data = Uri.parse("package:$packageName")
                            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        }

                        if (intent.resolveActivity(context.packageManager) != null) {
                            context.startActivity(intent)
                        } else {
                            openAppSettings(packageName)
                        }
                    } else {
                        openAppSettings(packageName)
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è $packageName: ${e.message}", "warning")
                }
            }
        }

        var totalApks = 0
        var currentApkIndex = 0
        private var isInstallingCancelled = false

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å –æ–ø–µ—Ä–µ–∂–∞—é—â–∏–º —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ–º
        private val readyToInstall = mutableListOf<QueueItem>()
        private val downloadUrls = mutableListOf<DownloadUrlItem>()
        private var currentDownloadIndex = 0
        private var currentInstallIndex = 0
        private var activeInstalls = 0
        private var isDownloading = false
        private var isInstalling = false

        // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–µ—Å—Å–∏–π
        private val MAX_PREPARE_PARALLEL = 3
        private val preparing = mutableSetOf<Thread>()
        private val prepared = ArrayDeque<PreparedSession>()
        private var committing = false
        private val apksSplits = mutableMapOf<File, List<File>>()

        // –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –æ—á–µ—Ä–µ–¥–∏
        private var pendingStandardInstall: QueueItem? = null
        private var isWaitingForStandardInstall = false

        private fun isAdbConnected(): Boolean {
            val activity = context as? MainActivity ?: return false
            return activity.adbManager.getCurrentStatus().isConnected
        }


        @JavascriptInterface
        fun startInstallation(groupName: String) {
            showInstallPrompt(
                title = "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å—ë?",
                message = "–ë—É–¥—É—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≥—Ä—É–ø–ø—ã: $groupName",
                installLabel = "–î–ê",
                onInstall = {
                    webView.evaluateJavascript("installAllSend()", null)
                    startInstallationInternal(groupName)
                },
                laterLabel = "–ù–ï–¢",
                onLater = {},
                cancelable = true
            )
        }

        @JavascriptInterface
        fun startInstallationInternal(groupName: String) {
            // –ü–æ–∫–∞–∑–∞—Ç—å –±–ª–æ–∫–∏—Ä—É—é—â–∏–π –¥–∏–∞–ª–æ–≥ –¥–ª—è –≤—Å–µ—Ö –º–µ—Ç–æ–¥–æ–≤ —É—Å—Ç–∞–Ω–æ–≤–∫–∏
            showBlockingDialog(formatInstallProgressMessage(), "–û—Ç–º–µ–Ω–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É") {
                showCancelConfirmation()
            }
        shouldRunAutoPermissions = getInstallMethod().equals(INSTALL_METHOD_ADB, ignoreCase = true)
            isInstallingCancelled = false
            
            Thread {
                try {
                    val configUrl = (context as? MainActivity)?.getConfigUrlForWeb() ?: ""
                    val configText = URL(configUrl).readText()
                    val config = JSONObject(configText)

                    val group = config.getJSONObject("groups").getJSONObject(groupName)
                    val tags = group.getJSONArray("tags")

                    // –û—á–∏—â–∞–µ–º –æ—á–µ—Ä–µ–¥–∏
                    installQueue.clear()
                    readyToInstall.clear()
                    downloadUrls.clear()
                    currentDownloadIndex = 0
                    currentInstallIndex = 0
                    activeInstalls = 0
                    isDownloading = true
                    isInstalling = false

                    // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ URL –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è (–ù–ï —Å–∫–∞—á–∏–≤–∞–µ–º —Å—Ä–∞–∑—É!)
                    val installMethod = (context as? MainActivity)?.getInstallMethodForWeb() ?: "sai"
                    if (installMethod == "adb" && !isAdbConnected()) {
                        Handler(Looper.getMainLooper()).post {
                            sendMessageToWebView("‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ADB. –ü–æ–¥–∫–ª—é—á–∏—Ç–µ—Å—å —á–µ—Ä–µ–∑ ¬´–ö –¥—Ä—É–≥–æ–º—É (RSA)¬ª –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
                            hideBlockingDialog()
                        }
                        return@Thread
                    }
                    val apps = config.getJSONArray("apps")
                    for (i in 0 until apps.length()) {
                        val app = apps.getJSONObject(i)
                        if (tagsMatch(tags, app.getJSONArray("tags"))) {
                            val url = app.getString("url")
                            val fileName = app.optString("file", "–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ")
                            val viaSession = (installMethod == "sai")
                            downloadUrls.add(DownloadUrlItem(url, fileName, viaSession))
                        }
                    }

                    val useAdbCopy = shouldUseAdbForCopies()
                    val adbBackupEntries = mutableListOf<AdbCopyEntry>()
                    val backups = config.getJSONArray("backups")
                    for (i in 0 until backups.length()) {
                        val backup = backups.getJSONObject(i)
                        if (!tagsMatch(tags, backup.getJSONArray("tags"))) continue

                        if (backup.has("files")) {
                            val filesArr = backup.getJSONArray("files")
                            for (j in 0 until filesArr.length()) {
                                val f = filesArr.getJSONObject(j)
                                val url = f.optString("url").takeIf { it.isNotBlank() } ?: continue
                                val folder = f.optString("target_folder", backup.optString("target_folder", "Download"))
                                if (useAdbCopy) {
                                    val remoteName = sanitizeFileNameForAdb(f.optString("file", null) ?: url.toUri().lastPathSegment)
                                    adbBackupEntries += AdbCopyEntry(url, folder, remoteName)
                                } else {
                                    downloadFile(url, folder)
                                }
                            }
                        } else if (backup.has("urls")) {
                            val urlsArray = backup.getJSONArray("urls")
                            val folder = backup.optString("target_folder", "Download")
                            for (j in 0 until urlsArray.length()) {
                                val url = urlsArray.optString(j).takeIf { it.isNotBlank() } ?: continue
                                if (useAdbCopy) {
                                    val remoteName = sanitizeFileNameForAdb(url.toUri().lastPathSegment)
                                    adbBackupEntries += AdbCopyEntry(url, folder, remoteName)
                                } else {
                                    downloadFile(url, folder)
                                }
                            }
                        } else if (backup.has("url")) {
                            val url = backup.optString("url").takeIf { it.isNotBlank() }
                            if (url != null) {
                                val folder = backup.optString("target_folder", "Download")
                                if (useAdbCopy) {
                                    val remoteName = sanitizeFileNameForAdb(url.toUri().lastPathSegment)
                                    adbBackupEntries += AdbCopyEntry(url, folder, remoteName)
                                } else {
                                    downloadFile(url, folder)
                                }
                            }
                        }
                    }
                    if (useAdbCopy && adbBackupEntries.isNotEmpty()) {
                        copyEntriesViaAdb(
                            adbBackupEntries,
                            notifyOnComplete = false,
                            successMessage = "‚úÖ –ë—ç–∫–∞–ø—ã –≥—Ä—É–ø–ø—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –ø–æ ADB",
                            errorMessage = "‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –±—ç–∫–∞–ø–æ–≤ –ø–æ ADB",
                            blocking = true
                        )
                    }

                    totalApks = downloadUrls.size
                    currentApkIndex = 0
                    updateBlockingInstallProgress()

                    if (downloadUrls.isEmpty()) {
                        Handler(Looper.getMainLooper()).post {
                            webView.evaluateJavascript("hideProgress()", null)
                            sendMessageToWebView("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ù–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π.")
                            // –°–∫—Ä—ã—Ç—å –±–ª–æ–∫–∏—Ä—É—é—â–∏–π –¥–∏–∞–ª–æ–≥, –µ—Å–ª–∏ –Ω–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏
                            val autoPermissionsStarted = triggerAutoPermissionsAfterInstall()
                            if (!autoPermissionsStarted) {
                                hideBlockingDialog()
                                requestStorageUsageUpdate()
                            }
                        }
                        return@Thread
                    }

                    // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–ø–µ—Ä–µ–∂–∞—é—â–µ–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—É—é —É—Å—Ç–∞–Ω–æ–≤–∫—É
                    startSequentialDownloadAndInstall()

                } catch (e: Exception) {
                    e.printStackTrace()
                    sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: ${e.message}")
                    // –°–∫—Ä—ã—Ç—å –±–ª–æ–∫–∏—Ä—É—é—â–∏–π –¥–∏–∞–ª–æ–≥ –ø—Ä–∏ –æ—à–∏–±–∫–µ
                    hideBlockingDialog()
                }
            }.start()
        }

        @JavascriptInterface
        fun onAutoPermissionsFinished() {
            Handler(Looper.getMainLooper()).post {
                sendMessageToWebView("‚úÖ –†–∞–∑—Ä–µ—à–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω—ã!<br>‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
                hideBlockingDialog()
                requestStorageUsageUpdate()
            }
        }

        // –û–ø–µ—Ä–µ–∂–∞—é—â–µ–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞
        private fun startSequentialDownloadAndInstall() {
            (context as? MainActivity)?.syncAdbConnectionStatusAsync()
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—á–µ—Ç—á–∏–∫–∏
            currentApkIndex = 0
            currentDownloadIndex = 0
            currentInstallIndex = 0
            activeInstalls = 0
            isDownloading = true
            isInstalling = false
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ (–º–æ–∂–µ—Ç –æ–ø–µ—Ä–µ–∂–∞—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É)
            downloadNextApk()
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —É—Å—Ç–∞–Ω–æ–≤–∫—É (—Å—Ç—Ä–æ–≥–æ –ø–æ –æ—á–µ—Ä–µ–¥–∏)
            startSequentialInstallation()
        }

        // –°–∫–∞—á–∏–≤–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π APK
        private fun downloadNextApk() {
            if (currentDownloadIndex >= downloadUrls.size) {
                isDownloading = false
                return
            }

            val item = downloadUrls[currentDownloadIndex++]
            
            Thread {
                try {
                    val isApks = shouldTreatAsApks(item.url)
                    val file = downloadToCacheWithExt(item.url, item.fileName, if (isApks) "apks" else "apk")
                    if (file != null) {
                        if (isApks || file.extension.equals("apks", true)) {
                            // –†–∞—Å–ø–∞–∫–æ–≤—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä .apks
                            sendMessageToWebView("üì¶ –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ –ø–∞–∫–µ—Ç–∞‚Ä¶")
                            val splits = unzipApksContainer(file)
                            runCatching { file.delete() }
                            if (splits.isEmpty()) {
                                sendMessageToWebView("‚ùå –í –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ .apks –Ω–µ –Ω–∞–π–¥–µ–Ω–æ APK-—Ñ–∞–π–ª–æ–≤")
                            } else {
                                val primary = splits.firstOrNull { it.name.equals("base.apk", true) } ?: splits.first()
                                val meta = extractApkMeta(context, primary)
                                val installMethod = (context as? MainActivity)?.getInstallMethodForWeb() ?: "sai"
                                val viaSession = installMethod == "sai"
                                val queueItem = QueueItem(primary, viaSession)
                                apksSplits[primary] = splits
                                readyToInstall.add(queueItem)
                                showToast(" –ó–∞–≥—Ä—É–∂–µ–Ω –ø–∞–∫–µ—Ç: ${meta.label}", "success", "data:image/png;base64,${meta.iconBase64}")
                                tryInstallNext()
                            }
                            // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ APK
                            downloadNextApk()
                        } else {
                            // –û–±—ã—á–Ω—ã–π APK
                            val meta = extractApkMeta(context, file)
                            if (meta.label.contains("install_") && meta.packageName.contains("install_")) {
                                showToast("‚ùå –ë–∏—Ç–∞—è —Å—Å—ã–ª–∫–∞: ${item.fileName}", "error")
                                file.delete()
                            } else {
                                val queueItem = QueueItem(file, item.viaSession)
                                readyToInstall.add(queueItem)
                                showToast(" –ó–∞–≥—Ä—É–∂–µ–Ω–æ –ø—Ä–∏–ª–æ–ª–∂–µ–Ω–∏–µ: ${meta.label}", "success", "data:image/png;base64,${meta.iconBase64}")
                                tryInstallNext()
                            }
                            downloadNextApk()
                        }
                    } else {
                        sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è: ${item.fileName}")
                        downloadNextApk()
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                    sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è: ${item.fileName}")
                    downloadNextApk()
                }
            }.start()
        }

        // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—É—é —É—Å—Ç–∞–Ω–æ–≤–∫—É
        private fun startSequentialInstallation() {
            // –°—Ä–∞–∑—É –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞—á–∞—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É –ø–µ—Ä–≤–æ–≥–æ APK
            tryInstallNext()
        }

        // –ü—ã—Ç–∞–µ–º—Å—è —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–ª–µ–¥—É—é—â–∏–π APK
        private fun tryInstallNext() {
            Handler(Looper.getMainLooper()).post {
                // –í—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—É—é –ø–æ–¥–≥–æ—Ç–æ–≤–∫—É –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
                if (readyToInstall.isNotEmpty() && activeInstalls == 0 && !isInstalling) {
                    val item = readyToInstall.removeAt(0)
                    isInstalling = true
                    activeInstalls = 1
                    
                    Thread {
                        installApkItem(item)
                    }.start()
                } else if (readyToInstall.isEmpty() && !isDownloading && activeInstalls == 0) {
                    // –í—Å–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ
                    webView.evaluateJavascript("hideProgress()", null)
                    sendMessageToWebView("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
                    // –°–∫—Ä—ã—Ç—å –±–ª–æ–∫–∏—Ä—É—é—â–∏–π –¥–∏–∞–ª–æ–≥ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –≤—Å–µ—Ö —É—Å—Ç–∞–Ω–æ–≤–æ–∫
                    val autoPermissionsStarted = triggerAutoPermissionsAfterInstall()
                    if (!autoPermissionsStarted) {
                        hideBlockingDialog()
                        requestStorageUsageUpdate()
                    }
                }
                
                // TODO: –í–∫–ª—é—á–∏—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—É—é –ø–æ–¥–≥–æ—Ç–æ–≤–∫—É –ø–æ—Å–ª–µ –æ—Ç–ª–∞–¥–∫–∏
                // prepareNextSessions()
                // tryCommitNext()
            }
        }

        // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–ª–µ–¥—É—é—â–∏—Ö —Å–µ—Å—Å–∏–π –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
        private fun prepareNextSessions() {
            while (preparing.size < MAX_PREPARE_PARALLEL && readyToInstall.isNotEmpty()) {
                val item = readyToInstall.removeAt(0)
                
                if (item.viaSession) {
                    val t = Thread {
                        try {
                            val pi = context.packageManager.packageInstaller
                            val params = PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL)
                            params.setSize(item.file.length())
                            
                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                                params.setInstallLocation(0) // INSTALL_LOCATION_AUTO
                            }
                            
                            // –ò–∑–≤–ª–µ–∫–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –î–û —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞
                            val meta = extractApkMeta(context, item.file)
                            
                            val sessionId = pi.createSession(params)
                            val session = pi.openSession(sessionId)
                            
                            // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º APK –≤ —Å–µ—Å—Å–∏—é
                            FileInputStream(item.file).use { input ->
                                session.openWrite("base.apk", 0, item.file.length()).use { output ->
                                    input.copyTo(output)
                                    session.fsync(output)
                                }
                            }
                            
                            synchronized(prepared) { 
                                prepared.add(PreparedSession(sessionId, session, meta))
                            }
                            
                            // –£–¥–∞–ª—è–µ–º APK –ø–æ—Å–ª–µ –∑–∞–ø–∏—Å–∏ (–æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º I/O)
                            item.file.delete()
                            
                        } catch (e: Exception) {
                            e.printStackTrace()
                            sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ —Å–µ—Å—Å–∏–∏: ${item.file.name} - ${e.message}")
                            
                            // –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å –æ–±—ã—á–Ω–æ–π —É—Å—Ç–∞–Ω–æ–≤–∫–æ–π
                            Handler(Looper.getMainLooper()).post {
                                Thread {
                                    installApkItem(item)
                                }.start()
                            }
                        } finally {
                            synchronized(preparing) {
                                preparing.remove(Thread.currentThread())
                            }
                        }
                    }
                    
                    synchronized(preparing) {
                        preparing.add(t)
                    }
                    t.start()
                    
                } else {
                    // –î–ª—è –æ–±—ã—á–Ω–æ–π —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–∞—Ä—É—é –ª–æ–≥–∏–∫—É
                    Thread {
                        installApkItem(item)
                    }.start()
                }
            }
        }

        // –ö–æ–º–º–∏—Ç —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω–æ–π —Å–µ—Å—Å–∏–∏
        private fun tryCommitNext() {
            if (committing) return
            
            val next = synchronized(prepared) { 
                prepared.removeFirstOrNull() 
            } ?: return
            
            try {
                committing = true
                isInstalling = true
                activeInstalls = 1
                
                // –°—á—ë—Ç—á–∏–∫ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤ installApkItem, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥–≤–æ–π–Ω–æ–≥–æ –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞
                sendProgressToWebView(currentApkIndex, totalApks, 0)
                updateBlockingInstallProgress()
                sendMessageToWebView("üì± –£—Å—Ç–∞–Ω–æ–≤–∫–∞: ${next.meta.label}")
                
                val sai = SessionApkInstaller(context, { msg, icon ->
                    sendMessageToWebView(msg, icon)
                }, next.meta.iconBase64)
                
                var finished = false
                val handler = Handler(Looper.getMainLooper())

                val timeout = Runnable {
                    if (!finished) {
                        finished = true
                        sendMessageToWebView("‚è± –ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç PackageInstaller ‚Äî –ø—Ä–æ–¥–æ–ª–∂–∞—é –æ—á–µ—Ä–µ–¥—å")
                        sai.unregister()
                        onInstallationComplete()
                    }
                }

                sai.onFinal = {
                    if (!finished) {
                        finished = true
                        handler.removeCallbacks(timeout)
                        sai.unregister()
                        onInstallationComplete()
                    }
                }

                sai.register()
                
                val callback = PendingIntent.getBroadcast(
                    context, 
                    next.sessionId,
                    Intent(SessionApkInstaller.ACTION_INSTALL_STATUS(context)).setPackage(context.packageName),
                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE
                ).intentSender
                
                next.session.commit(callback)
                handler.postDelayed(timeout, 25_000) // —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞
                
            } catch (e: Exception) {
                e.printStackTrace()
                sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –∫–æ–º–º–∏—Ç–∞ —Å–µ—Å—Å–∏–∏: ${next.meta.label} - ${e.message}")
                onInstallationComplete()
            }
        }

        // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ APK (–¥–ª—è –æ–±—ã—á–Ω–æ–π/ADB/SAI —É—Å—Ç–∞–Ω–æ–≤–∫–∏)
        private fun installApkItem(item: QueueItem) {
            try {
                // –ù–µ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω–¥–µ–∫—Å –∑–¥–µ—Å—å, —á—Ç–æ–±—ã –ø–µ—Ä–≤–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –æ—Å—Ç–∞–≤–∞–ª–æ—Å—å 1/total –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏
                val displayIndex = (currentApkIndex + 1).coerceAtMost(totalApks)
                sendProgressToWebView(displayIndex, totalApks, 0)
                updateBlockingInstallProgress()
                
                // –ò–∑–≤–ª–µ–∫–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ APK –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —á–∏—Ç–∞–µ–º–æ–≥–æ –∏–º–µ–Ω–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
                val meta = extractApkMeta(context, item.file)
                //sendMessageToWebView("üì• –£—Å—Ç–∞–Ω–æ–≤–∫–∞: <span style='color: #00cfff; font-weight: bold;'>${meta.label}</span>")

                val method = (context as? MainActivity)?.getInstallMethodForWeb() ?: "sai"
                
                if (item.viaSession) {
                    val sai = SessionApkInstaller(context, { msg, icon ->
                        sendMessageToWebView(msg, icon)
                    }, meta.iconBase64)
                    var finished = false
                    val handler = Handler(Looper.getMainLooper())

                    val timeout = Runnable {
                        if (!finished) {
                            finished = true
                            sendMessageToWebView("‚è± –ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç PackageInstaller ‚Äî –ø—Ä–æ–¥–æ–ª–∂–∞—é –æ—á–µ—Ä–µ–¥—å")
                            sai.unregister()
                            onInstallationComplete(item.file)
                        }
                    }

                    sai.onFinal = {
                        if (!finished) {
                            finished = true
                            handler.removeCallbacks(timeout)
                            sai.unregister()
                            apksSplits.remove(item.file)?.let { splits ->
                                runCatching {
                                    splits.forEach { it.delete() }
                                    splits.firstOrNull()?.parentFile?.delete()
                                }
                            }
                            onInstallationComplete(item.file)
                        }
                    }

                    sai.register()
                    val splits = apksSplits[item.file]
                    if (splits != null && splits.isNotEmpty()) {
                        sai.install(splits)
                    } else {
                        sai.install(listOf(item.file))
                    }
                    handler.postDelayed(timeout, 25_000)

                } else if (method == "adb") {
                    Thread {
                        val adb = obtainConnectedAdb(silent = true)
                        if (adb == null) {
                            Handler(Looper.getMainLooper()).post {
                                sendMessageToWebView("‚ùå ADB –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ")
                            }
                            onInstallationComplete(item.file)
                            return@Thread
                        }
                        val splits = apksSplits[item.file]
                        val ok = try {
                            if (splits != null && splits.isNotEmpty()) {
                                adb.installSplitApks(splits, meta.label) { progress ->
                                    Handler(Looper.getMainLooper()).post { sendMessageToWebView(progress) }
                                }
                            } else {
                                adb.installApk(item.file) { p ->
                                    Handler(Looper.getMainLooper()).post { sendMessageToWebView(p) }
                                }
                            }
                        } catch (e: Exception) {
                            false
                        }
                        Handler(Looper.getMainLooper()).post {
                            val appName = meta.label.ifBlank { item.file.nameWithoutExtension }
                            if (ok) sendMessageToWebView("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: $appName", meta.iconBase64) else sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ ADB —É—Å—Ç–∞–Ω–æ–≤–∫–∏: $appName")
                            apksSplits.remove(item.file)?.forEach { split ->
                                runCatching { split.delete() }
                                runCatching { split.parentFile?.delete() }
                            }
                            onInstallationComplete(item.file)
                        }
                    }.start()

                } else {
                    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ - —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
                    pendingStandardInstall = item
                    isWaitingForStandardInstall = true
                    
                    val meta = extractApkMeta(context, item.file)
                    try {
                        val installFile = File(context.filesDir, "install_${System.currentTimeMillis()}.apk")
                        item.file.copyTo(installFile, overwrite = true)
                        
                        val uri = FileProvider.getUriForFile(context, "${context.packageName}.provider", installFile)
                        val intent = Intent(Intent.ACTION_VIEW).apply {
                            setDataAndType(uri, "application/vnd.android.package-archive")
                            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION)
                        }
                        context.startActivity(intent)
                        sendMessageToWebView("üì± –û—Ç–∫—Ä—ã—Ç–æ —Å–∏—Å—Ç–µ–º–Ω–æ–µ –æ–∫–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: ${meta.label}")
                        showToast("‚è≥ –î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –∏ –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ FastInstaller", "warning")
                        
                        // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥
                        Handler(Looper.getMainLooper()).postDelayed({
                            runCatching { installFile.delete() }
                        }, 10000)

                        // –ù–ï –≤—ã–∑—ã–≤–∞–µ–º onInstallationComplete —Å—Ä–∞–∑—É - –∂–¥—ë–º –≤–æ–∑–≤—Ä–∞—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    } catch (e: Exception) {
                        e.printStackTrace()
                        sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏: ${e.message}")
                        pendingStandardInstall = null
                        isWaitingForStandardInstall = false
                        onInstallationComplete(item.file)
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: ${item.file.name}")
                onInstallationComplete(item.file)
            }
        }

        // –û–∂–∏–¥–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–∞–∫–µ—Ç–∞ —á–µ—Ä–µ–∑ ACTION_PACKAGE_ADDED
        private fun waitPackageAddedOnce(
            context: Context,
            expectedPkg: String,
            timeoutMs: Long = 25_000,
            onDone: () -> Unit
        ) {
            val filter = IntentFilter(Intent.ACTION_PACKAGE_ADDED).apply { addDataScheme("package") }
            val receiver = object : BroadcastReceiver() {
                override fun onReceive(c: Context?, i: Intent?) {
                    val added = i?.data?.schemeSpecificPart ?: return
                    if (added == expectedPkg) {
                        runCatching { context.unregisterReceiver(this) }
                        onDone()
                    }
                }
            }
            if (Build.VERSION.SDK_INT >= 33)
                context.registerReceiver(receiver, filter, Context.RECEIVER_NOT_EXPORTED)
            else
                context.registerReceiver(receiver, filter)

            Handler(Looper.getMainLooper()).postDelayed({
                runCatching { context.unregisterReceiver(receiver) }
                onDone()
            }, timeoutMs)
        }

        // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏
        private fun onInstallationComplete(file: File? = null) {
            activeInstalls--
            isInstalling = false
            committing = false

            // –§–∏–∫—Å —Å—á—ë—Ç—á–∏–∫–∞: —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏, —á—Ç–æ–±—ã —Å–ª–µ–¥—É—é—â–µ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –Ω–∞—á–∏–Ω–∞–ª–æ —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –Ω–æ–º–µ—Ä–∞
            if (totalApks > 0) {
                currentApkIndex = (currentApkIndex + 1).coerceAtMost(totalApks)
                updateBlockingInstallProgress()
            }
            
            // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            try {
                file?.delete()
            } catch (e: Exception) {
                e.printStackTrace()
            }
            
            // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–æ–¥–≥–æ—Ç–æ–≤–∫—É –∏ –∫–æ–º–º–∏—Ç
            tryInstallNext()
        }

        @JavascriptInterface
        fun notifyCopyComplete() {
            Handler(Looper.getMainLooper()).post {
                webView.evaluateJavascript("onBackupCopied()", null)
            }
        }

        @JavascriptInterface
        fun copyFilesWithTargets(filesJson: String) {
            if (shouldUseAdbForCopies()) {
                copyFilesWithTargetsViaAdb(filesJson)
                return
            }
            Thread {
                try {
                    val arr = JSONArray(filesJson)
                    for (i in 0 until arr.length()) {
                        val obj = arr.getJSONObject(i)
                        val url = obj.getString("url")
                        val folder = obj.optString("target_folder", "Download")
                        downloadFile(url, folder)
                    }
                    sendMessageToWebView("‚úÖ –í—Å–µ –±—ç–∫–∞–ø—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã.")
                    notifyCopyComplete()
                } catch (e: Exception) {
                    sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: ${e.message}")
                    notifyCopyComplete()
                }
            }.start()
        }

        @JavascriptInterface
        fun openUnknownSources() {
            val activity = context as? MainActivity
            val pkg = context.packageName
            val startedViaAdb = activity?.tryOpenUnknownSourcesViaAdb(pkg) { executed ->
                if (!executed) {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å ¬´–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏¬ª –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ", "warning")
                }
            } ?: false
            if (startedViaAdb) return

            openUnknownSourcesLocally(context.applicationContext, pkg)
        }

        private fun openUnknownSourcesLocally(ctx: Context, pkg: String) {
            fun tryStart(intent: Intent): Boolean = try {
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                ctx.startActivity(intent)
                true
            } catch (_: Exception) {
                false
            }

            val pm = ctx.packageManager
            val isTv = try {
                val ui = ctx.getSystemService(Context.UI_MODE_SERVICE) as android.app.UiModeManager
                ui.currentModeType == android.content.res.Configuration.UI_MODE_TYPE_TELEVISION ||
                        pm.hasSystemFeature("android.software.leanback") ||
                        pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)
            } catch (_: Exception) {
                false
            }

            val intents = mutableListOf<Intent>()

            if (isTv) {
                intents += Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES).apply {
                    setClassName(
                        "com.android.tv.settings",
                        "com.android.tv.settings.device.apps.specialaccess.ExternalSourcesActivity"
                    )
                    data = "package:$pkg".toUri()
                }
                intents += Intent().apply {
                    setClassName(
                        "com.android.tv.settings",
                        "com.android.tv.settings.device.apps.specialaccess.ExternalSourcesActivity"
                    )
                    data = "package:$pkg".toUri()
                }
                intents += Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES).apply {
                    setClassName(
                        "com.google.android.tv.settings",
                        "com.google.android.tv.settings.device.apps.specialaccess.ExternalSourcesActivity"
                    )
                    data = "package:$pkg".toUri()
                }
                intents += Intent().apply {
                    setClassName(
                        "com.google.android.tv.settings",
                        "com.google.android.tv.settings.device.apps.specialaccess.ExternalSourcesActivity"
                    )
                    data = "package:$pkg".toUri()
                }
            }

            intents += Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES).apply {
                data = "package:$pkg".toUri()
            }
            intents += Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                data = "package:$pkg".toUri()
            }
            intents += Intent(Settings.ACTION_SETTINGS)

            if (intents.any { tryStart(it) }) return

            showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å ¬´–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏¬ª –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.", "warning")
        }


        @JavascriptInterface
        fun openBatteryOptimization() {
            val activity = context as? MainActivity
            val startedViaAdb = activity?.tryOpenBatteryOptimizationViaAdb { executed ->
                val message = if (executed) {
                    ""
                } else {
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —ç–Ω–µ—Ä–≥–æ—Å–±–µ—Ä–µ–∂–µ–Ω–∏—è –ø–æ ADB"
                }
                sendMessageToWebView(message)
            } ?: false
            if (startedViaAdb) return

            val ctx = context.applicationContext

            fun tryStart(i: Intent): Boolean = try {
                i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                ctx.startActivity(i)
                true
            } catch (_: Exception) { false }

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –¢–í –ª–∏ —ç—Ç–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
            val pm = ctx.packageManager
            val isTv = try {
                val ui = ctx.getSystemService(Context.UI_MODE_SERVICE) as android.app.UiModeManager
                ui.currentModeType == android.content.res.Configuration.UI_MODE_TYPE_TELEVISION ||
                        pm.hasSystemFeature("android.software.leanback") ||
                        pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)
            } catch (_: Exception) { false }

            if (isTv) {
                // 1) Leanback Settings
                if (tryStart(Intent(Intent.ACTION_MAIN).addCategory("android.intent.category.LEANBACK_SETTINGS"))) return

                // 2) –Ø–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã TV-–Ω–∞—Å—Ç—Ä–æ–µ–∫ (AOSP/Google TV/OEM)
                val tvIntents = listOf(
                    // AOSP TV
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.MainSettings"),
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.SettingsActivity"),
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.TvSettingsActivity"),
                    // Google TV (—Ä–∞–∑–Ω—ã–µ —Ä–µ–≤–∏–∑–∏–∏)
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.MainSettingsActivity"),
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.MainSettings"),
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.SettingsActivity"),
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.homepage.TopLevelSettingsActivity"),
                    // OEM
                    Intent().setClassName("com.tcl.tv.settings", "com.tcl.tv.settings.MainSettings"),
                    Intent().setClassName("com.tcl.settings", "com.tcl.settings.MainSettings"),
                    Intent().setClassName("com.droidlogic.tv.settings", "com.droidlogic.tv.settings.MainSettings"),
                    Intent().setClassName("com.realtek.tvsettings", "com.realtek.tvsettings.MainSettings")
                )
                for (i in tvIntents) if (tryStart(i)) return

                // 3) –§–æ–ª–ª–±–µ–∫ –Ω–∞ –æ–±—ã—á–Ω—ã–µ —Å–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                if (tryStart(Intent(Settings.ACTION_SETTINGS))) return

                // (–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–Ω—Å ‚Äî –∫–∞—Ä—Ç–æ—á–∫–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
                // if (tryStart(Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                //         .setData(Uri.parse("package:${ctx.packageName}")))) return
            } else {
                // –¢–µ–ª–µ—Ñ–æ–Ω/–ø–ª–∞–Ω—à–µ—Ç: —Å—Ä–∞–∑—É –æ–±—ã—á–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                if (tryStart(Intent(Settings.ACTION_SETTINGS))) return
                // (–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π ‚Äî –æ–±—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π
                // if (tryStart(Intent(android.provider.Settings.ACTION_APPLICATION_SETTINGS))) return
            }

            showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.", "warning")
        }

        @JavascriptInterface
        fun openAllApps() {
            val ctx = context.applicationContext
            fun tryStart(i: Intent): Boolean = try {
                i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); ctx.startActivity(i); true
            } catch (_: Exception) { false }

            val pm = ctx.packageManager
            val isTv = try {
                val ui = ctx.getSystemService(Context.UI_MODE_SERVICE) as android.app.UiModeManager
                ui.currentModeType == android.content.res.Configuration.UI_MODE_TYPE_TELEVISION ||
                        pm.hasSystemFeature("android.software.leanback") ||
                        pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)
            } catch (_: Exception) { false }

            if (isTv) {
                if (tryStart(Intent().setClassName(
                        "com.google.android.apps.tv.launcherx",
                        "com.google.android.apps.tv.launcherx.guide.home.moreapps.ui.FullscreenAppsActivity"
                    ))) return
                // —Ñ–æ–ª–ª–±–µ–∫: –ø—Ä–æ—Å—Ç–æ —Å–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¢–í
                if (tryStart(Intent(Intent.ACTION_MAIN).addCategory("android.intent.category.LEANBACK_SETTINGS"))) return
            } else {
                // —Ç–µ–ª–µ—Ñ–æ–Ω/–ø–ª–∞–Ω—à–µ—Ç: –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö
                if (tryStart(Intent(Settings.ACTION_APPLICATION_SETTINGS))) return
            }

            showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.", "warning")
        }


        @JavascriptInterface
        fun copyMultipleBackups(urlsJson: String, targetFolder: String) {
            if (shouldUseAdbForCopies()) {
                copyMultipleBackupsViaAdb(urlsJson, targetFolder)
                return
            }
            Thread {
                try {
                    val urlArray = JSONArray(urlsJson)
                    for (i in 0 until urlArray.length()) {
                        val url = urlArray.getString(i)
                        downloadFile(url, targetFolder)
                    }
                    sendMessageToWebView("‚úÖ –í—Å–µ –±—ç–∫–∞–ø—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã.")
                } catch (e: Exception) {
                    e.printStackTrace()
                    sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: ${e.message}")
                }
            }.start()
        }

        private fun shouldUseAdbForCopies(): Boolean {
            val activity = context as? MainActivity ?: return false
            return activity.getInstallMethodForWeb().equals(INSTALL_METHOD_ADB, true)
        }

        private fun copyFilesWithTargetsViaAdb(filesJson: String) {
            val entries = mutableListOf<AdbCopyEntry>()
            try {
                val arr = JSONArray(filesJson)
                for (i in 0 until arr.length()) {
                    val obj = arr.getJSONObject(i)
                    val url = obj.optString("url").takeIf { it.isNotBlank() } ?: continue
                    val folder = obj.optString("target_folder", "Download")
                    val fileHint = obj.optString("file", null)
                    val remoteName = sanitizeFileNameForAdb(fileHint ?: url.toUri().lastPathSegment)
                    entries += AdbCopyEntry(url, folder, remoteName)
                }
            } catch (_: Exception) { }
            if (entries.isEmpty()) {
                Handler(Looper.getMainLooper()).post {
                    sendMessageToWebView("‚ùå –ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è")
                    notifyCopyComplete()
                }
                return
            }
            copyEntriesViaAdb(
                entries,
                notifyOnComplete = true,
                successMessage = "‚úÖ –§–∞–π–ª—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –ø–æ ADB",
                errorMessage = "‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–æ–≤ –ø–æ ADB"
            )
        }

        private fun copyMultipleBackupsViaAdb(urlsJson: String, targetFolder: String) {
            val entries = mutableListOf<AdbCopyEntry>()
            try {
                val arr = JSONArray(urlsJson)
                for (i in 0 until arr.length()) {
                    val url = arr.optString(i).takeIf { it.isNotBlank() } ?: continue
                    val remoteName = sanitizeFileNameForAdb(url.toUri().lastPathSegment)
                    entries += AdbCopyEntry(url, targetFolder, remoteName)
                }
            } catch (_: Exception) { }
            if (entries.isEmpty()) {
                Handler(Looper.getMainLooper()).post {
                    sendMessageToWebView("‚ùå –ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è")
                }
                return
            }
            copyEntriesViaAdb(
                entries,
                notifyOnComplete = false,
                successMessage = "‚úÖ –í—Å–µ –±—ç–∫–∞–ø—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –ø–æ ADB –≤ $targetFolder",
                errorMessage = "‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –±—ç–∫–∞–ø–æ–≤ –ø–æ ADB"
            )
        }

        private fun copyEntriesViaAdb(
            entries: List<AdbCopyEntry>,
            notifyOnComplete: Boolean,
            successMessage: String,
            errorMessage: String,
            blocking: Boolean = false
        ) {
            val work = Runnable {
                val activity = context as? MainActivity
                val adb = obtainConnectedAdb(silent = false)
                if (activity == null || adb == null) {
                    Handler(Looper.getMainLooper()).post {
                        if (activity == null) {
                            sendMessageToWebView("‚ùå –ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
                        } else {
                            sendMessageToWebView("‚ùå ADB –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
                        }
                        if (notifyOnComplete) notifyCopyComplete()
                    }
                    return@Runnable
                }
                var allOk = true
                entries.forEach { entry ->
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –±–µ–∑ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
                    val remotePath = adb.pushUrlToDeviceOptimized(entry.url, entry.targetFolder, entry.remoteName) { msg ->
                        Handler(Looper.getMainLooper()).post { sendMessageToWebView(msg) }
                    }
                    if (remotePath != null) {
                        activity.registerRemoteBackup(remotePath)
                    } else {
                        allOk = false
                    }
                }
                Handler(Looper.getMainLooper()).post {
                    sendMessageToWebView(if (allOk) successMessage else errorMessage)
                    if (notifyOnComplete) notifyCopyComplete()
                }
            }
            if (blocking) {
                work.run()
            } else {
                Thread(work).start()
            }
        }

        private fun sanitizeFileNameForAdb(raw: String?): String {
            val base = raw?.substringAfterLast('/')?.takeIf { it.isNotBlank() } ?: "file_${System.currentTimeMillis()}"
            // –†–∞–∑—Ä–µ—à–∞–µ–º –∫–∏—Ä–∏–ª–ª–∏—Ü—É, –ø—Ä–æ–±–µ–ª—ã –∏ –¥–µ—Ñ–∏—Å—ã, –æ—Å—Ç–∞–ª—å–Ω–æ–µ –∑–∞–º–µ–Ω—è–µ–º
            return base.replace(Regex("[^A-Za-z0-9–ê-–Ø–∞-—è–Å—ë._ -]"), "_")
        }

        private fun downloadTempFileForAdb(urlStr: String, remoteName: String): File? {
            return try {
                val ext = remoteName.substringAfterLast('.', "")
                val suffix = if (ext.isNotEmpty()) ".$ext" else ""
                val tempFile = File.createTempFile("adb_copy_", suffix, context.cacheDir)
                val connection = (URL(urlStr).openConnection() as HttpURLConnection)
                connection.connect()
                connection.inputStream.use { input ->
                    FileOutputStream(tempFile).use { output ->
                        input.copyTo(output)
                    }
                }
                tempFile
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }

        @JavascriptInterface
        fun installNextApkManually(): String {
            return if (installQueue.isEmpty()) {
                sendMessageToWebView("‚úÖ –û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞, —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
                // –°–∫—Ä—ã—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å
                Handler(Looper.getMainLooper()).post {
                    webView.evaluateJavascript("hideProgress()", null)
                }
                "empty"
            } else {
                installNextApk()
                "ok"
            }
        }

        fun resumeInstallationIfNeeded() {
            if (isWaitingForStandardInstall && pendingStandardInstall != null) {
                // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ—á–µ—Ä–µ–¥—å –ø–æ—Å–ª–µ –≤–æ–∑–≤—Ä–∞—Ç–∞
                Handler(Looper.getMainLooper()).postDelayed({
                    val pending = pendingStandardInstall
                    pendingStandardInstall = null
                    isWaitingForStandardInstall = false
                    
                    sendMessageToWebView("üîÑ –ü—Ä–æ–¥–æ–ª–∂–∞—é –æ—á–µ—Ä–µ–¥—å —É—Å—Ç–∞–Ω–æ–≤–∫–∏‚Ä¶")
                    pending?.let { onInstallationComplete(it.file) }
                }, 1000) // –ó–∞–¥–µ—Ä–∂–∫–∞ 1 —Å–µ–∫ –¥–ª—è —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏
            } else if (readyToInstall.isNotEmpty() && activeInstalls == 0 && !isInstalling) {
                // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–±—ã—á–Ω—É—é –æ—á–µ—Ä–µ–¥—å
                tryInstallNext()
            }
        }


        private fun cancelInstallationQueue() {
            pendingStandardInstall = null
            isWaitingForStandardInstall = false
            readyToInstall.clear()
            downloadUrls.clear()
            isDownloading = false
            isInstalling = false
            activeInstalls = 0
            
            sendMessageToWebView("‚ùå –û—á–µ—Ä–µ–¥—å —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –æ—Ç–º–µ–Ω–µ–Ω–∞")
            Handler(Looper.getMainLooper()).post {
                webView.evaluateJavascript("hideProgress()", null)
                hideBlockingDialog()
            }
        }

        @JavascriptInterface
        fun installSingle(url: String, displayName: String) {
            // –ú–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –º–∞—Ä–∫–µ—Ä –≤—Ö–æ–¥–∞
            sendMessageToWebView("‚ñ∂Ô∏è installSingle: $displayName")
            totalApks = 1
            currentApkIndex = 0
            Handler(Looper.getMainLooper()).post {
                val safeName = jsQuote(displayName)
                webView.evaluateJavascript(
                    "showProgress(${currentApkIndex + 1}, $totalApks, 0, '$safeName')",
                    null
                )
            }
            sendMessageToWebView("–°–∫–∞—á–∏–≤–∞—é: $displayName‚Ä¶")

            Thread {
                try {
                    val method = (context as? MainActivity)?.getInstallMethodForWeb() ?: "sai"
                    if (method == "adb" && !isAdbConnected()) {
                        Handler(Looper.getMainLooper()).post {
                            showToast("‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ADB. –ü–æ–¥–∫–ª—é—á–∏—Ç–µ—Å—å —á–µ—Ä–µ–∑ ¬´–ö –¥—Ä—É–≥–æ–º—É (RSA)¬ª", "error")
                            webView.evaluateJavascript("hideProgress()", null)
                        }
                        return@Thread
                    }
                    val isApks = shouldTreatAsApks(url)
                    val file = downloadToCacheWithExt(url, displayName, if (isApks) "apks" else "apk")
                    if (file != null) {
                        if (isApks || file.extension.equals("apks", true)) {
                            // –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ .apks –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö —Å–ø–ª–∏—Ç–æ–≤
                            sendMessageToWebView("üì¶ –†–∞—Å–ø–∞–∫–æ–≤–∫–∞ –ø–∞–∫–µ—Ç–∞‚Ä¶")
                            val splits = unzipApksContainer(file)
                            if (splits.isEmpty()) {
                                sendMessageToWebView("‚ùå –í –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ .apks –Ω–µ –Ω–∞–π–¥–µ–Ω–æ APK-—Ñ–∞–π–ª–æ–≤")
                                return@Thread
                            }
                            val primary = splits.firstOrNull { it.name.equals("base.apk", true) } ?: splits.first()
                            val meta = extractApkMeta(context, primary)
                            Handler(Looper.getMainLooper()).post {
                                totalApks = 1
                                currentApkIndex = 0
                                if (method == "adb") {
                                    sendMessageToWebView("üîå –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ ADB‚Ä¶")
                                    Thread {
                                        val ok = try {
                                            (context as MainActivity).adbManager.installSplitApks(splits, meta.label) { p ->
                                                Handler(Looper.getMainLooper()).post { sendMessageToWebView(p) }
                                            }
                                        } catch (e: Exception) {
                                            false
                                        }
                                        Handler(Looper.getMainLooper()).post {
                                            val appName = meta.label.ifBlank { primary.nameWithoutExtension }
                                            if (ok) sendMessageToWebView("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: $appName", meta.iconBase64)
                                            else sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ ADB —É—Å—Ç–∞–Ω–æ–≤–∫–∏: $appName")
                                            runCatching {
                                                splits.forEach { it.delete() }
                                                primary.parentFile?.delete()
                                                file.delete()
                                            }
                                            webView.evaluateJavascript("hideProgress()", null)
                                        }
                                    }.start()
                                } else {
                                    val sai = SessionApkInstaller(this@MainActivity, { msg, icon -> sendMessageToWebView(msg, icon) }, meta.iconBase64)
                                    sai.onFinal = {
                                        sai.unregister()
                                        // –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                                        runCatching {
                                            splits.forEach { it.delete() }
                                            primary.parentFile?.delete()
                                            file.delete()
                                        }
                                        Handler(Looper.getMainLooper()).post { webView.evaluateJavascript("hideProgress()", null) }
                                    }
                                    sai.register()
                                    sai.install(splits)
                                }
                            }
                        } else {
                            // –û–±—ã—á–Ω—ã–π –æ–¥–∏–Ω–æ—á–Ω—ã–π APK
                            totalApks = 1
                            currentApkIndex = 0

                            val meta = extractApkMeta(context, file)
                            val method = (context as? MainActivity)?.getInstallMethodForWeb() ?: "sai"

                            Handler(Looper.getMainLooper()).post {
                                when (method) {
                                    "sai" -> {
                                        val sai = SessionApkInstaller(context, { msg, icon -> sendMessageToWebView(msg, icon) }, meta.iconBase64)
                                        sai.onFinal = {
                                            sai.unregister()
                                            Handler(Looper.getMainLooper()).post { webView.evaluateJavascript("hideProgress()", null) }
                                        }
                                        sai.register()
                                        sai.install(listOf(file))
                                    }
                                    "standard" -> {
                                        installApkDirectly(file)
                                        webView.evaluateJavascript("hideProgress()", null)
                                    }
                                    "adb" -> {
                                       // sendMessageToWebView("üîå –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ ADB‚Ä¶")
                                        Thread {
                                            val ok = try {
                                                (context as MainActivity).adbManager.installApk(file) { p ->
                                                    Handler(Looper.getMainLooper()).post { sendMessageToWebView(p) }
                                                }
                                            } catch (e: Exception) {
                                                false
                                            }
                                            Handler(Looper.getMainLooper()).post {
                                                val appName = meta.label.ifBlank { file.nameWithoutExtension }
                                                if (ok) sendMessageToWebView("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: $appName", meta.iconBase64) else sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ ADB —É—Å—Ç–∞–Ω–æ–≤–∫–∏: $appName")
                                                onInstallationComplete(file)
                                                webView.evaluateJavascript("hideProgress()", null)
                                            }
                                        }.start()
                                    }
                                }
                            }
                        }
                    } else {
                        sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞.")
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                    sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏: ${e.message}")
                }
            }.start()
        }


        @JavascriptInterface
        fun copyBackup(url: String, targetFolder: String) {
            Thread {
                try {
                    downloadFile(url, targetFolder)
                    sendMessageToWebView("‚úÖ –ë—ç–∫–∞–ø —É—Å–ø–µ—à–Ω–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω.")
                    notifyCopyComplete()
                } catch (e: Exception) {
                    e.printStackTrace()
                    sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –±—ç–∫–∞–ø–∞: ${e.message}")
                    notifyCopyComplete()
                }
            }.start()
        }

        @JavascriptInterface
        fun openAnyFileManager() {
            val intent = Intent(Intent.ACTION_GET_CONTENT).apply {
                type = "*/*"
                addCategory(Intent.CATEGORY_OPENABLE)
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
            }
            context.startActivity(intent)
        }

        @JavascriptInterface
        fun openFilePicker() {
            (context as? MainActivity)?.openFilePicker { uri ->
                sendMessageToWebView("üìÑ –í—ã–±—Ä–∞–Ω —Ñ–∞–π–ª: $uri")
            }
        }

        @JavascriptInterface
        fun openApkFilePicker() {
            (context as? MainActivity)?.openApkFilePicker()
        }
        
        @JavascriptInterface
        fun openApkFilePickerDownload() {
            val activity = context as? MainActivity ?: return
            val adbConnected = activity.adbManager.getCurrentStatus().isConnected
            if (!adbConnected) {
                showToast("‚ùå ADB —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ", "error")
                return
            }
            activity.openAdbUploadPicker()
        }

        @JavascriptInterface
        fun installSelfApkViaAdb() {
            val activity = context as? MainActivity ?: return
            if (!activity::adbManager.isInitialized) {
                showToast("‚ùå ADB –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "error")
                return
            }
            val status = activity.adbManager.getCurrentStatus()
            if (!status.isConnected) {
                showToast("‚ùå –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–∫–ª—é—á–∏—Ç–µ ADB", "error")
                return
            }
            Thread {
                val appInfo = context.packageManager.getApplicationInfo(context.packageName, 0)
                val source = appInfo.publicSourceDir ?: appInfo.sourceDir
                val srcFile = java.io.File(source)
                if (!srcFile.exists() || !srcFile.canRead()) {
                    Handler(Looper.getMainLooper()).post {
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å APK –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è", "error")
                    }
                    return@Thread
                }

                val tmpName = "fastinstaller-self.apk"
                val tmpFile = java.io.File(context.cacheDir, tmpName)
                srcFile.copyTo(tmpFile, overwrite = true)

                var lastProgress = 0
                val remotePath = activity.adbManager.pushFileToDevice(
                    localFile = tmpFile,
                    remoteDir = "/data/local/tmp",
                    remoteFileName = tmpName
                ) { msg: String ->
                    // msg —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–æ—Ü–µ–Ω—Ç –≤ –∫–æ–Ω—Ü–µ: "... 37%"
                    val percent = msg.substringAfterLast(' ').removeSuffix("%").toIntOrNull() ?: return@pushFileToDevice
                    if (percent == 100 || percent - lastProgress >= 5) {
                        lastProgress = percent
                        sendMessageToWebView(
                            "<img src=\"https://appassets.androidplatform.net/assets/webview/icons/title/ic_launcher_round.png\" " +
                                "style='height:18px;width:18px;vertical-align:middle;margin-right:6px;'>–ö–æ–ø–∏—Ä—É—é APK: $percent%"
                        )
                    }
                } ?: run {
                    Handler(Looper.getMainLooper()).post {
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å APK –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ", "error")
                    }
                    return@Thread
                }

                val (ok, output) = runAdbCommand(activity.adbManager, "pm install -r \"$remotePath\"")
                Handler(Looper.getMainLooper()).post {
                    if (ok) {
                        showToast("‚úÖ –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ", "success")
                    } else {
                        val msg = if (output.isNotBlank()) output else "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"
                        showToast("‚ùå –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å: $msg", "error")
                    }
                }
            }.start()
        }

        @JavascriptInterface
        fun openDownloadToDevice() {
            val activity = context as? MainActivity
            if (activity == null || !activity::adbManager.isInitialized) {
                showToast("‚ùå ADB –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "error")
                return
            }
            if (!activity.adbManager.getCurrentStatus().isConnected) {
                showToast("‚ùå –°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–∫–ª—é—á–∏—Ç–µ ADB", "error")
                return
            }
            showToast("‚è≥ –ö–æ–ø–∏—Ä—É—é /sdcard/Download‚Ä¶", "info")
            Thread {
                val result = activity.copyRemoteDownloadsToLocal { progress ->
                    showToast(progress, "info")
                }
                Handler(Looper.getMainLooper()).post {
                    val type = if (result.success) "success" else "error"
                    showToast(result.message, type)
                }
            }.start()
        }
        
        @JavascriptInterface
        fun getInstallMethod(): String {
            return (context as? MainActivity)?.getInstallMethodForWeb() ?: "sai"
        }
        
        @JavascriptInterface
        fun setInstallMethod(method: String) {
            (context as? MainActivity)?.setInstallMethodFromWeb(method)
        }

        @JavascriptInterface
        fun getLocalIpv4(): String {
            return (context as? MainActivity)?.getLocalIpv4Address().orEmpty()
        }

        @JavascriptInterface
        fun startDeviceNameDiscovery() {
            (context as? MainActivity)?.startDeviceIdentityDiscovery()
        }

        @JavascriptInterface
        fun stopDeviceNameDiscovery() {
            (context as? MainActivity)?.stopDeviceIdentityDiscovery()
        }

        @JavascriptInterface
        fun resolveDeviceFriendlyName(ip: String?): String {
            return (context as? MainActivity)?.getFriendlyNameForIp(ip).orEmpty()
        }

        @JavascriptInterface
        fun startNativeAdbScan() {
            (context as? MainActivity)?.startNativeAdbScan()
        }

        @JavascriptInterface
        fun stopNativeAdbScan() {
            (context as? MainActivity)?.stopNativeAdbScan()
        }

        @JavascriptInterface
        fun disconnectAdb() {
            val activity = context as? MainActivity ?: return
            activity.adbManager.disconnect(resetPreferredTarget = true)
            activity.notifyAdbStatusChanged()
        }

        // –ö–Ω–æ–ø–∫–∞ ¬´–ü–æ–¥–∫–ª—é—á–∏—Ç—å ADB (RSA)¬ª
        @JavascriptInterface
        fun connectAdb() {
            Thread {
                val activity = context as? MainActivity
                if (activity == null) {
                    Handler(Looper.getMainLooper()).post { sendMessageToWebView("‚ùå –ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω") }
                    return@Thread
                }
                activity.adbManager.disconnect(resetPreferredTarget = true)
                activity.adbManager.preferLocalTarget()
                activity.notifyAdbStatusChanged()
                val ok = activity.adbManager.ensureConnected { msg ->
                    Handler(Looper.getMainLooper()).post { sendMessageToWebView(msg) }
                }
                if (!ok) {
                    Handler(Looper.getMainLooper()).post { sendMessageToWebView("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ ADB") }
                    return@Thread
                }
                showAdbConnectionDialog(
                    title = "–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ ADB",
                    message = "–û–∂–∏–¥–∞—é"
                ) {
                    activity.adbManager.disconnect(resetPreferredTarget = true)
                    activity.notifyAdbStatusChanged()
                    Handler(Looper.getMainLooper()).post {
                        sendMessageToWebView("‚õî –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
                    }
                }
                if (adbConnectionCancelled) {
                    hideAdbConnectionDialog()
                    return@Thread
                }
                val handshake = waitForAdbHandshake(activity)
                hideAdbConnectionDialog()
                if (adbConnectionCancelled) return@Thread
                Handler(Looper.getMainLooper()).post {
                    if (handshake) {
                        sendMessageToWebView("‚úÖ ADB –ø–æ–¥–∫–ª—é—á–µ–Ω (RSA)")
                        activity.setInstallMethodFromWeb(
                            INSTALL_METHOD_ADB,
                            silent = true,
                            autoReason = INSTALL_METHOD_AUTO_REASON_ADB
                        )
                        activity.notifyAdbStatusChanged()
                        activity.requestStorageUsageUpdate()
                        Thread { activity.adbManager.getRemoteSdkVersion(forceRefresh = true) }.start()
                        activity.whitelistSelfForDoze()
                        val statusAfter = activity.adbManager.getCurrentStatus()
                        val saveHost = statusAfter.host.ifBlank { "127.0.0.1" }
                        val friendlyForSave = activity.getFriendlyNameForIp(statusAfter.host)
                        activity.saveLastAdbConnection(saveHost, statusAfter.port.takeIf { it > 0 } ?: 5555, friendlyForSave)
                        activity.refreshFriendlyNameFromAdb(statusAfter.host)
                    } else {
                        activity.adbManager.disconnect(resetPreferredTarget = true)
                        activity.notifyAdbStatusChanged()
                        sendMessageToWebView("‚ùå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
                    }
                }
            }.start()
        }

        @JavascriptInterface
        fun connectAdbTo(target: String?) {
            if (target.isNullOrBlank()) {
                showToast("–ù–µ —É–∫–∞–∑–∞–Ω –∞–¥—Ä–µ—Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞", "error")
                return
            }
            val trimmed = target.trim()
            val parts = trimmed.split(':', limit = 2)
            val host = parts.getOrNull(0)?.trim().orEmpty()
            val port = parts.getOrNull(1)?.trim()?.toIntOrNull() ?: 5555
            connectAdbToHost(host, port)
        }

        @JavascriptInterface
        fun connectAdbToHost(ip: String?, port: Int) {
            val host = ip?.trim().orEmpty()
            if (host.isEmpty()) {
                showToast("–ù–µ —É–∫–∞–∑–∞–Ω IP –∞–¥—Ä–µ—Å", "error")
                return
            }
            val safePort = port.takeIf { it in 1..65535 } ?: 5555
            Thread {
                val activity = context as? MainActivity
                if (activity == null) {
                    Handler(Looper.getMainLooper()).post {
                        showToast("–ö–æ–Ω—Ç–µ–∫—Å—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "error")
                    }
                    return@Thread
                }
                activity.adbManager.disconnect()
                activity.notifyAdbStatusChanged()
                val status = activity.adbManager.connect(host, safePort)
                if (!status.isConnected) {
                    Handler(Looper.getMainLooper()).post {
                        val reason = status.error?.takeIf { it.isNotBlank() } ?: "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"
                        sendMessageToWebView("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ $host:$safePort ‚Äî $reason")
                    }
                    return@Thread
                }
                showAdbConnectionDialog(
                    title = "–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ ADB",
                    message = "–û–∂–∏–¥–∞—é –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –Ω–∞ $host:$safePort‚Ä¶"
                ) {
                    activity.adbManager.disconnect(resetPreferredTarget = true)
                    activity.notifyAdbStatusChanged()
                    Handler(Looper.getMainLooper()).post {
                        sendMessageToWebView("‚õî –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
                    }
                }
                if (adbConnectionCancelled) {
                    hideAdbConnectionDialog()
                    return@Thread
                }
                val handshakeOk = waitForAdbHandshake(activity)
                hideAdbConnectionDialog()
                if (adbConnectionCancelled) return@Thread
                Handler(Looper.getMainLooper()).post {
                    if (handshakeOk) {
                        val friendly = activity.getFriendlyNameForIp(host).takeIf { !it.isNullOrBlank() }
                        val label = if (!friendly.isNullOrBlank()) "$friendly $host" else "$host"
                        sendMessageToWebView("‚úÖ ADB –ø–æ–¥–∫–ª—é—á–µ–Ω: $label")
                        activity.setInstallMethodFromWeb(
                            INSTALL_METHOD_ADB,
                            silent = true,
                            autoReason = INSTALL_METHOD_AUTO_REASON_ADB
                        )
                        activity.notifyAdbStatusChanged()
                        activity.requestStorageUsageUpdate()
                        Thread { activity.adbManager.getRemoteSdkVersion(forceRefresh = true) }.start()
                        activity.whitelistSelfForDoze()
                        activity.saveLastAdbConnection(host, safePort, friendly)
                        activity.refreshFriendlyNameFromAdb(host)
                    } else {
                        activity.adbManager.disconnect(resetPreferredTarget = true)
                        activity.notifyAdbStatusChanged()
                        sendMessageToWebView("‚ùå –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ $host:$safePort –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ")
                    }
                }
            }.start()
        }

        @JavascriptInterface
        fun hasRootAccess(): Boolean = hasRootAccessInternal()

        @JavascriptInterface
        fun adbRootDiag(): String {
            val cmd = """
                adb_enabled=$(settings get global adb_enabled 2>/dev/null)
                svc_adbd=$(getprop init.svc.adbd)
                tcp_port=$(getprop service.adb.tcp.port)
                sys_usb=$(getprop sys.usb.config)
                persist_usb=$(getprop persist.sys.usb.config)
                persist_adb=$(getprop persist.service.adb.enable)
                ro_secure=$(getprop ro.adb.secure)
                echo "adb_enabled=${'$'}adb_enabled"
                echo "init.svc.adbd=${'$'}svc_adbd"
                echo "service.adb.tcp.port=${'$'}tcp_port"
                echo "sys.usb.config=${'$'}sys_usb"
                echo "persist.sys.usb.config=${'$'}persist_usb"
                echo "persist.service.adb.enable=${'$'}persist_adb"
                echo "ro.adb.secure=${'$'}ro_secure"
            """.trimIndent().replace("\n", "; ")

            val root = hasRootAccessInternal()
            val (ok, output) = if (root) runSuCommand(cmd) else runShCommand(cmd)

            return JSONObject().apply {
                put("ok", ok)
                put("root", root)
                put("output", output)
            }.toString()
        }

        @JavascriptInterface
        fun enableAdbTcp5555(): String {
            val result = JSONObject()
            if (!hasRootAccessInternal()) {
                result.put("ok", false)
                result.put("error", "root_required")
                result.put("output", "")
                return result.toString()
            }
            val (ok, output) = runSuCommand("setprop service.adb.tcp.port 5555; stop adbd; start adbd; sleep 1; getprop service.adb.tcp.port")
            result.put("ok", ok)
            result.put("output", output)
            return result.toString()
        }

        @JavascriptInterface
        fun disableAdbTcp(): String {
            val result = JSONObject()
            if (!hasRootAccessInternal()) {
                result.put("ok", false)
                result.put("error", "root_required")
                result.put("output", "")
                return result.toString()
            }
            val (ok, output) = runSuCommand("setprop service.adb.tcp.port -1; stop adbd; start adbd; sleep 1; getprop service.adb.tcp.port")
            result.put("ok", ok)
            result.put("output", output)
            return result.toString()
        }

        @JavascriptInterface
        fun restartAdbdRoot(): String {
            val result = JSONObject()
            if (!hasRootAccessInternal()) {
                result.put("ok", false)
                result.put("error", "root_required")
                result.put("output", "")
                return result.toString()
            }
            val (ok, output) = runSuCommand("stop adbd; start adbd; sleep 1; getprop init.svc.adbd")
            result.put("ok", ok)
            result.put("output", output)
            return result.toString()
        }

        @JavascriptInterface
        fun probeAdbHostAsync(ip: String?, port: Int, requestId: String?, timeoutMs: Int) {
            val host = ip?.trim().orEmpty()
            val id = requestId?.trim().orEmpty()
            if (host.isEmpty() || id.isEmpty()) return
            val safePort = port.takeIf { it in 1..65535 } ?: 5555
            val activity = context as? MainActivity ?: return
            activity.scheduleAdbProbe(host, safePort, timeoutMs, id)
        }

        @JavascriptInterface
        fun getAdbConnectionInfo(): String {
            val activity = context as? MainActivity
            val status = activity?.adbManager?.getCurrentStatus()
            val label = if (status?.isConnected == true) {
                activity.buildAdbConnectionLabel(status.host, activity?.getFriendlyNameForIp(status.host))
            } else {
                "–õ–æ–∫–∞–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"
            }
            val obj = JSONObject().apply {
                put("connected", status?.isConnected == true)
                put("host", status?.host ?: "")
                put("port", status?.port ?: 0)
                put("label", label)
            }
            return obj.toString()
        }

        @JavascriptInterface
        fun requestStorageUsageRefresh() {
            val activity = context as? MainActivity ?: return
            activity.requestStorageUsageUpdate()
        }

        @JavascriptInterface
        fun getLastAdbConnectionInfo(): String {
            val activity = context as? MainActivity
            val last = activity?.getLastAdbConnection()
            val obj = JSONObject()
            if (last != null) {
                obj.put("available", true)
                obj.put("host", last.host)
                obj.put("port", last.port)
                obj.put("label", last.label)
                obj.put("friendly", last.friendly ?: "")
            } else {
                obj.put("available", false)
            }
            return obj.toString()
        }

        private fun waitForAdbHandshake(activity: MainActivity): Boolean {
            if (adbConnectionCancelled) return false
            return try {
                activity.adbManager.runShellCommand("true")
            } catch (_: Exception) {
                false
            }
        }

        // –ë–ª–æ–∫–∏—Ä—É—é—â–∏–π AlertDialog –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏
        private var blockingDialog: AlertDialog? = null
        private var blockingMessageView: TextView? = null
        private var canCancel = false
        @Volatile private var wipeCancelled = false

        private var adbConnectionDialog: AlertDialog? = null
        @Volatile private var adbConnectionCancelled = false

        // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
        fun formatInstallProgressMessage(base: String = "–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ‚Ä¶"): String {
            val total = totalApks
            if (total <= 0) return base
            val current = (currentApkIndex + 1).coerceAtMost(total)
            return "$base (${current}/${total})"
        }

        fun updateBlockingDialogMessage(message: String) {
            Handler(Looper.getMainLooper()).post {
                blockingMessageView?.text = message
            }
        }

        fun updateBlockingInstallProgress() {
            updateBlockingDialogMessage(formatInstallProgressMessage())
        }
        
        fun formatUploadProgressMessage(base: String = "–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤‚Ä¶"): String {
            val total = (context as? MainActivity)?.totalUploadFiles ?: 0
            if (total <= 0) return base
            val current = ((context as? MainActivity)?.currentUploadIndex ?: 0) + 1
            return "$base ($current/$total)"
        }
        
        fun updateBlockingUploadProgress() {
            updateBlockingDialogMessage(formatUploadProgressMessage())
        }
        
        private fun showUploadCancelConfirmation() {
            Handler(Looper.getMainLooper()).post {
                val dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_install_prompt, null)
                setupAdbReconnectButton(dialogView)
                dialogView.findViewById<TextView>(R.id.dialogTitle).text = "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–º–µ–Ω—ã"
                dialogView.findViewById<TextView>(R.id.dialogMessage).text = "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–º–µ–Ω–∏—Ç—å –∑–∞–≥—Ä—É–∑–∫—É —Ñ–∞–π–ª–æ–≤ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ?"

                val permissionsContainer = dialogView.findViewById<LinearLayout>(R.id.permissionsContainer)
                permissionsContainer.visibility = View.GONE
                dialogView.findViewById<LinearLayout>(R.id.buttonRow).gravity = Gravity.END or Gravity.CENTER_VERTICAL

                val alertDialog = AlertDialog.Builder(context)
                    .setView(dialogView)
                    .setCancelable(false)
                    .create()

                // –î–µ–ª–∞–µ–º —Ñ–æ–Ω –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å –±–µ–ª—ã–µ —É–≥–ª—ã
                alertDialog.window?.setBackgroundDrawableResource(android.R.color.transparent)

                dialogView.findViewById<Button>(R.id.btnInstall).apply {
                    text = "–î–∞, –æ—Ç–º–µ–Ω–∏—Ç—å"
                    setOnClickListener {
                        alertDialog.dismiss()
                        cancelUpload()
                    }
                }

                dialogView.findViewById<Button>(R.id.btnLater).apply {
                    text = "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å"
                    setOnClickListener {
                        alertDialog.dismiss()
                        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–ª–æ–∫–∏—Ä—É—é—â–∏–π –¥–∏–∞–ª–æ–≥ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å–æ–º
                        showUploadBlocking((context as? MainActivity)?.totalUploadFiles ?: 0, (context as? MainActivity)?.currentUploadIndex ?: 0)
                    }
                }

                alertDialog.show()
            }
        }
        
        private fun cancelUpload() {
            (context as? MainActivity)?.let { activity ->
                activity.isUploadCancelledLocal = true
                sendMessageToWebView("‚ùå –ó–∞–≥—Ä—É–∑–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
            }
            hideBlockingDialog()
        }

        fun showInstallBlocking(total: Int, current: Int = 0) {
            totalApks = total
            currentApkIndex = current
            showBlockingDialog(formatInstallProgressMessage(), "–û—Ç–º–µ–Ω–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É") {
                showCancelConfirmation()
            }
        }
        
        fun showUploadBlocking(total: Int, current: Int = 0) {
            showBlockingDialog(formatUploadProgressMessage(), "–û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–≥—Ä—É–∑–∫—É") {
                showUploadCancelConfirmation()
            }
        }

        fun hideInstallBlocking() {
            hideBlockingDialog()
        }

        fun setInstallBlockingProgress(current: Int) {
            currentApkIndex = current
            updateBlockingInstallProgress()
        }

        // –ü–æ–∫–∞–∑–∞—Ç—å –±–ª–æ–∫–∏—Ä—É—é—â–∏–π AlertDialog
        private fun setupAdbReconnectButton(dialogView: View) {
            val reconnectButton = dialogView.findViewById<ImageButton>(R.id.btnReconnectAdb)
            reconnectButton?.setOnClickListener {
                sendMessageToWebView("üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞—é ADB...")
                (context as? MainActivity)?.let { activity ->
                    Thread {
                        activity.adbManager.disconnect(resetPreferredTarget = false)
                        val success = activity.adbManager.ensureConnected { msg ->
                            Handler(Looper.getMainLooper()).post {
                                sendMessageToWebView(msg)
                            }
                        }
                        Handler(Looper.getMainLooper()).post {
                            if (success) {
                                sendMessageToWebView("‚úÖ ADB –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω")
                                activity.notifyAdbStatusChanged()
                            } else {
                                sendMessageToWebView("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å ADB")
                            }
                        }
                    }.start()
                }
            }
        }

        private fun showBlockingDialog(message: String, cancelText: String, onCancel: () -> Unit) {
            Handler(Looper.getMainLooper()).post {
                blockingDialog?.dismiss()

                val dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_install_prompt, null)
                val root = dialogView.findViewById<LinearLayout>(R.id.dialogRoot)
                root.minimumWidth = (context.resources.displayMetrics.density * 320f).toInt()
                root.minimumHeight = (context.resources.displayMetrics.density * 200f).toInt()
                
                // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ADB
                setupAdbReconnectButton(dialogView)
                val titleView = dialogView.findViewById<TextView>(R.id.dialogTitle)
                titleView.text = "–£—Å—Ç–∞–Ω–æ–≤–∫–∞"
                titleView.textAlignment = View.TEXT_ALIGNMENT_CENTER
                val messageView = dialogView.findViewById<TextView>(R.id.dialogMessage)
                // –ù–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –ø–æ–≤—Ç–æ—Ä–Ω–æ, —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å "(x/y)" –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º –æ—Ç–∫—Ä—ã—Ç–∏–∏
                messageView.text = message
                messageView.textAlignment = View.TEXT_ALIGNMENT_CENTER
                blockingMessageView = messageView
                val spinnerView = dialogView.findViewById<ImageView>(R.id.dialogSpinner)
                spinnerView.visibility = View.VISIBLE
                (spinnerView.drawable as? Animatable)?.start()
                dialogView.findViewById<LinearLayout>(R.id.permissionsContainer).visibility = View.GONE

                val buttonRow = dialogView.findViewById<LinearLayout>(R.id.buttonRow)
                buttonRow.gravity = Gravity.CENTER

                dialogView.findViewById<Button>(R.id.btnInstall).apply {
                    text = cancelText
                    setOnClickListener {
                        blockingDialog?.dismiss()
                        onCancel()
                    }
                }

                dialogView.findViewById<Button>(R.id.btnLater).visibility = View.GONE

                blockingDialog = AlertDialog.Builder(context, R.style.CustomDialogTheme)
                    .setView(dialogView)
                    .setCancelable(false)
                    .create()

                blockingDialog?.apply {
                    setCanceledOnTouchOutside(false)
                    show()
                }
                canCancel = true
            }
        }

        // –°–∫—Ä—ã—Ç—å –±–ª–æ–∫–∏—Ä—É—é—â–∏–π AlertDialog
        fun hideBlockingDialog() {
            Handler(Looper.getMainLooper()).post {
                blockingDialog?.dismiss()
                blockingDialog = null
                blockingMessageView = null
                canCancel = false
            }
        }

        private fun showAdbConnectionDialog(title: String, message: String, onCancel: () -> Unit) {
            adbConnectionCancelled = false
            Handler(Looper.getMainLooper()).post {
                adbConnectionDialog?.dismiss()

                val dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_install_prompt, null)
                dialogView.findViewById<TextView>(R.id.dialogTitle).apply {
                    text = title
                    textAlignment = View.TEXT_ALIGNMENT_CENTER
                }
                dialogView.findViewById<TextView>(R.id.dialogMessage).apply {
                    text = message
                    textAlignment = View.TEXT_ALIGNMENT_CENTER
                }
                dialogView.findViewById<LinearLayout>(R.id.permissionsContainer).visibility = View.GONE
                val spinner = dialogView.findViewById<ImageView>(R.id.dialogSpinner)
                spinner.visibility = View.VISIBLE
                (spinner.drawable as? Animatable)?.start()
                val buttonRow = dialogView.findViewById<LinearLayout>(R.id.buttonRow)
                buttonRow.gravity = Gravity.CENTER

                dialogView.findViewById<Button>(R.id.btnInstall).apply {
                    text = "–û—Ç–º–µ–Ω–∞"
                    setOnClickListener {
                        adbConnectionDialog?.dismiss()
                        adbConnectionCancelled = true
                        onCancel()
                    }
                }
                dialogView.findViewById<Button>(R.id.btnLater).visibility = View.GONE

                adbConnectionDialog = AlertDialog.Builder(context, R.style.CustomDialogTheme)
                    .setView(dialogView)
                    .setCancelable(false)
                    .create().also {
                        it.setCanceledOnTouchOutside(false)
                        it.show()
                    }
            }
        }

        private fun hideAdbConnectionDialog() {
            Handler(Looper.getMainLooper()).post {
                adbConnectionDialog?.dismiss()
                adbConnectionDialog = null
            }
        }


        // –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–º–µ–Ω—ã
        private fun showCancelConfirmation() {
            Handler(Looper.getMainLooper()).post {
                val dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_install_prompt, null)
                setupAdbReconnectButton(dialogView)
                dialogView.findViewById<TextView>(R.id.dialogTitle).text = "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–º–µ–Ω—ã"
                dialogView.findViewById<TextView>(R.id.dialogMessage).text = "–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–º–µ–Ω–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É? –í—Å–µ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã."

                val permissionsContainer = dialogView.findViewById<LinearLayout>(R.id.permissionsContainer)
                permissionsContainer.visibility = View.GONE
                dialogView.findViewById<LinearLayout>(R.id.buttonRow).gravity = Gravity.END or Gravity.CENTER_VERTICAL

                dialogView.findViewById<Button>(R.id.btnInstall).apply {
                    text = "–î–∞, –æ—Ç–º–µ–Ω–∏—Ç—å"
                    setOnClickListener {
                        blockingDialog?.dismiss()
                        cancelInstallation()
                    }
                }

                dialogView.findViewById<Button>(R.id.btnLater).apply {
                    text = "–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É"
                    setOnClickListener {
                        blockingDialog?.dismiss()
                        showBlockingDialog(formatInstallProgressMessage(), "–û—Ç–º–µ–Ω–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É") {
                            showCancelConfirmation()
                        }
                    }
                }

                blockingDialog = AlertDialog.Builder(context, R.style.CustomDialogTheme)
                    .setView(dialogView)
                    .setCancelable(false)
                    .create()

                blockingDialog?.apply {
                    setCanceledOnTouchOutside(false)
                    setOnKeyListener { _, keyCode, event ->
                        if (keyCode == KeyEvent.KEYCODE_BACK && event.action == KeyEvent.ACTION_UP) {
                            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É "–Ω–∞–∑–∞–¥", —á—Ç–æ–±—ã –Ω–µ —Å–Ω—è—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫—É —Å–ª—É—á–∞–π–Ω–æ
                            true
                        } else {
                            false
                        }
                    }
                    show()
                }
            }
        }

        // –û—Ç–º–µ–Ω–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–∫—É
        private fun cancelInstallation() {
            sendMessageToWebView("‚èπÔ∏è –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é —É—Å—Ç–∞–Ω–æ–≤–∫—É...")
            shouldRunAutoPermissions = false

            // –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å–µ –ø—Ä–æ—Ü–µ—Å—Å—ã
            isDownloading = false
            isInstalling = false
            activeInstalls = 0
            canCancel = false
            isInstallingCancelled = true
            isInstallingCancelledLocal = true

            // –û—á–∏—Å—Ç–∏—Ç—å –æ—á–µ—Ä–µ–¥–∏
            installQueue.clear()
            readyToInstall.clear()
            downloadUrls.clear()
            apksSplits.clear()
            pendingApkPicker = false
            pendingStandardInstall = null
            isWaitingForStandardInstall = false

            // –°–±—Ä–æ—Å–∏—Ç—å —Å—á—ë—Ç—á–∏–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
            totalApks = 0
            currentApkIndex = 0
            totalApksLocal = 0
            currentApkIndexLocal = 0
            updateBlockingInstallProgress()

            // –û—á–∏—Å—Ç–∏—Ç—å –∫–µ—à
            try {
                val cacheDir = context.cacheDir
                cacheDir.listFiles()?.forEach { it.deleteRecursively() }
            } catch (e: Exception) {
                e.printStackTrace()
            }

            // –°–∫—Ä—ã—Ç—å –¥–∏–∞–ª–æ–≥ –∏ –ø–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
            hideBlockingDialog()
            sendMessageToWebView("‚ùå –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞")
            webView.evaluateJavascript("hideProgress()", null)
        }

        @JavascriptInterface
        fun openAppSettingsList() {
            val activity = context as? MainActivity
            val startedViaAdb = activity?.tryOpenAppSettingsListViaAdb { executed ->
                if (!executed) {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –ø–æ ADB", "warning")
                }
            } ?: false
            if (startedViaAdb) return

            val ctx = context.applicationContext

            fun tryStart(i: Intent): Boolean = try {
                i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                ctx.startActivity(i); true
            } catch (_: Exception) { false }

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –¢–í –ª–∏ —ç—Ç–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
            val pm = ctx.packageManager
            val isTv = try {
                val ui = ctx.getSystemService(Context.UI_MODE_SERVICE) as android.app.UiModeManager
                ui.currentModeType == android.content.res.Configuration.UI_MODE_TYPE_TELEVISION ||
                        pm.hasSystemFeature("android.software.leanback") ||
                        pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)
            } catch (_: Exception) { false }

            if (isTv) {
                // 1) –ü—Ä—è–º–æ–π –≤—Ö–æ–¥ –≤ —Ä–∞–∑–¥–µ–ª ¬´–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è¬ª TV-–Ω–∞—Å—Ç—Ä–æ–µ–∫ (AOSP TV)
                val tvAppLists = listOf(
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.device.apps.AppsActivity"),
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.device.apps.AppManagementActivity"),
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.device.apps.AllAppsActivity"),
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.device.apps.AppsActivityBase")
                )
                for (i in tvAppLists) if (tryStart(i)) return

                // 2) –¢–æ –∂–µ –¥–ª—è Google TV (–Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ—à–∏–≤–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –¥—Ä—É–≥–æ–π –ø–∞–∫–µ—Ç)
                val gtvAppLists = listOf(
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.device.apps.AppsActivity"),
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.device.apps.AppManagementActivity"),
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.device.apps.AllAppsActivity")
                )
                for (i in gtvAppLists) if (tryStart(i)) return

                // 3) –ï—Å–ª–∏ –ø—Ä—è–º—ã—Ö –∞–∫—Ç–∏–≤–∏—Ç–∏ –Ω–µ—Ç ‚Äî —Å–∏—Å—Ç–µ–º–Ω—ã–µ –∏–Ω—Ç–µ–Ω—Ç—ã ¬´–≤—Å–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è¬ª
                if (tryStart(Intent(Settings.ACTION_MANAGE_ALL_APPLICATIONS_SETTINGS))) return
                if (tryStart(Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS))) return

                // 4) –ü–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–Ω—Å ‚Äî –∫–æ—Ä–µ–Ω—å TV-–Ω–∞—Å—Ç—Ä–æ–µ–∫, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–π–¥—ë—Ç —Å—Ç—Ä–µ–ª–∫–∞–º–∏
                val tvSettingsRoots = listOf(
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.MainSettings"),
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.MainSettings"),
                    Intent(Settings.ACTION_SETTINGS)
                )
                for (i in tvSettingsRoots) if (tryStart(i)) return
            } else {
                // –ù–µ –¢–í: —Å—Ä–∞–∑—É –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π/–Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                if (tryStart(Intent(Settings.ACTION_MANAGE_ALL_APPLICATIONS_SETTINGS))) return
                if (tryStart(Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS))) return
                if (tryStart(Intent(Settings.ACTION_APPLICATION_SETTINGS))) return
                if (tryStart(Intent(Settings.ACTION_SETTINGS))) return
            }

            showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.", "warning")
        }
        @JavascriptInterface
        fun openAccessibilitySettings() {
            val activity = context as? MainActivity
            val startedViaAdb = activity?.tryOpenAccessibilitySettingsViaAdb { executed ->
                if (!executed) {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø–æ ADB", "warning")
                }
            } ?: false
            if (startedViaAdb) return

            val ctx = context.applicationContext

            fun tryStart(i: Intent): Boolean = try {
                i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                ctx.startActivity(i)
                true
            } catch (_: Exception) { false }

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —ç—Ç–æ –¢–í –∏–ª–∏ –Ω–µ—Ç
            val pm = ctx.packageManager
            val isTv = try {
                val ui = ctx.getSystemService(Context.UI_MODE_SERVICE) as android.app.UiModeManager
                ui.currentModeType == android.content.res.Configuration.UI_MODE_TYPE_TELEVISION ||
                        pm.hasSystemFeature("android.software.leanback") ||
                        pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK)
            } catch (_: Exception) { false }

            if (isTv) {
                // 1) –ü–æ–ø—Ä–æ–±—É–µ–º ATV/AOSP –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã Accessibility
                val tvAccIntents = listOf(
                    // AOSP TV
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.accessibility.AccessibilityActivity"),
                    Intent().setClassName("com.android.tv.settings", "com.android.tv.settings.AccessibilitySettingsActivity"),
                    // Google TV (–Ω–æ–≤—ã–µ —Ä–µ–≤–∏–∑–∏–∏)
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.accessibility.AccessibilityActivity"),
                    Intent().setClassName("com.google.android.tv.settings", "com.google.android.tv.settings.AccessibilitySettingsActivity"),
                    // Slimbox/Amlogic
                    Intent().setClassName("com.droidlogic.tv.settings", "com.droidlogic.tv.settings.accessibility.AccessibilityActivity"),
                    Intent().setClassName("com.droidlogic.tv.settings", "com.droidlogic.tv.settings.AccessibilitySettingsActivity")
                )
                for (i in tvAccIntents) if (tryStart(i)) return

                // 2) –§–æ–ª–ª–±–µ–∫ ‚Äî –æ–±—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¢–í
                if (tryStart(Intent(Intent.ACTION_MAIN).addCategory("android.intent.category.LEANBACK_SETTINGS"))) return

                // 3) –§–æ–ª–ª–±–µ–∫ ‚Äî –æ–±—ã—á–Ω—ã–µ accessibility (—Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã–µ)
                if (tryStart(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS))) return
            } else {
                // –ù–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞—Ö –∏ –ø–ª–∞–Ω—à–µ—Ç–∞—Ö ‚Äî —Å—Ä–∞–∑—É —Å–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π
                if (tryStart(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS))) return
            }

            showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ä–∞–∑–¥–µ–ª —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ. –ù–∞ –ê–¢–í 11 —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞", "warning")
        }


        @JavascriptInterface
        fun openAllAppsSide() {
            val activity = context as? MainActivity
            val adbConnected = activity?.adbManager?.getCurrentStatus()?.isConnected == true
            if (adbConnected) {
                Thread {
                    val commands = listOf(
                        "am start -a android.intent.action.ALL_APPS",
                        "am start -n com.android.launcher/.Launcher",
                        "am start -n com.google.android.tvlauncher/.MainActivity"
                    )
                    val executed = commands.any { cmd ->
                        try {
                            activity?.adbManager?.runShellCommand(cmd) { }
                            true
                        } catch (_: Exception) {
                            false
                        }
                    }
                    Handler(Looper.getMainLooper()).post {
                        if (!executed) {
                            showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π —á–µ—Ä–µ–∑ ADB", "warning")
                        }
                    }
                }.start()
                return
            }
            try {
                val intent = Intent("android.intent.action.ALL_APPS").apply {
                    flags = Intent.FLAG_ACTIVITY_NEW_TASK
                }
                context.startActivity(intent)
            } catch (e: Exception) {
                showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.", "warning")
            }
        }
        @JavascriptInterface
    fun openAnydesk() {
    val activity = context as? MainActivity
    val startedViaAdb = activity?.tryOpenAnydeskViaAdb { executed ->
        if (!executed) {
            showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å AnyDesk –ø–æ ADB", "warning")
        }
    } ?: false
    if (startedViaAdb) return

    try {
        val intent = Intent().apply {
            setClassName(
                "com.anydesk.anydeskandroid",
                "com.anydesk.anydeskandroid.gui.activity.MainActivity"
            )
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        context.startActivity(intent)
        showToast("üöÄ Anydesk –∑–∞–ø—É—â–µ–Ω", "success")
    } catch (e: Exception) {
        showInstallPrompt(
            title = "AnyDesk –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
            message = "–ü–æ—Ö–æ–∂–µ, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ AnyDesk –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–µ–π—á–∞—Å?",
            installLabel = "–£–°–¢–ê–ù–û–í–ò–¢–¨",
            onInstall = {
                installApkStandardFromUrl(
                    "https://tvboxsetup.ru/fastinstaller/WebView/AnyDesk_v.7.0.6(70006).apk",
                    "AnyDesk"
                )
            },
            laterLabel = "–ü–û–ó–ñ–ï",
            onLater = {},
            cancelable = true
        )
    }
}
        @JavascriptInterface
        fun openPlayMarket() {
            val activity = context as? MainActivity
            val startedViaAdb = activity?.tryOpenPlayMarketViaAdb { executed ->
                if (!executed) {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å Google Play –ø–æ ADB", "warning")
                }
            } ?: false
            if (startedViaAdb) return

            try {
                val intent = context.packageManager.getLaunchIntentForPackage("com.android.vending")
                if (intent != null) {
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    context.startActivity(intent)
                } else {
                    showToast("‚ùå Google Play –Ω–µ –Ω–∞–π–¥–µ–Ω", "warning")
                }
            } catch (e: Exception) {
                showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å Google Play: ${e.message}", "warning")
            }
        }

        @JavascriptInterface
        fun openFileManagerPlus() {
            val activity = context as? MainActivity
            val startedViaAdb = activity?.tryOpenFileManagerPlusViaAdb { executed ->
                if (!executed) {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å File Manager+ –ø–æ ADB", "warning")
                }
            } ?: false
            if (startedViaAdb) return

            try {
                val intent = Intent()
                intent.setClassName(
                    "com.alphainventor.filemanager",
                    "com.alphainventor.filemanager.activity.MainActivity"
                )
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                context.startActivity(intent)
                sendMessageToWebView("")
            } catch (e: Exception) {
                showInstallPrompt(
                    title = "File Manager+ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                    message = "–ü–æ—Ö–æ–∂–µ, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ File Manager+ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–µ–π—á–∞—Å?",
                    installLabel = "–£–°–¢–ê–ù–û–í–ò–¢–¨",
                    onInstall = {
                        installApkStandardFromUrl(
                            "https://tvboxsetup.ru/fastinstaller/WebView/FileManager%202100271-2.7.1.apk",
                            "File Manager+"
                        )
                    },
                    laterLabel = "–ü–û–ó–ñ–ï",
                    onLater = {},
                    cancelable = true
                )
            }
        }

        @JavascriptInterface
        fun requestScreenSaverState() {
            Thread {
                val adb = obtainConnectedAdb()
                if (adb == null) {
                    sendScreenSaverStateToWeb(null)
                    return@Thread
                }
                val state = fetchScreenSaverState(adb)
                sendScreenSaverStateToWeb(state)
            }.start()
        }

        @JavascriptInterface
        fun setScreenSaverTimeout(type: String?, timeoutMs: Double) {
            Thread {
                val adb = obtainConnectedAdb() ?: return@Thread
                val safeMs = timeoutMs.roundToLong().coerceAtLeast(60_000L)
                val command = if (type == "screen") {
                    "settings put system screen_off_timeout $safeMs"
                } else {
                    "settings put secure sleep_timeout $safeMs"
                }
                val (success, output) = runAdbCommand(adb, command)
                Handler(Looper.getMainLooper()).post {
                    if (success) {
                        showToast("‚úÖ –¢–∞–π–º–µ—Ä –æ–±–Ω–æ–≤–ª—ë–Ω", "success")
                    } else {
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ç–∞–π–º–µ—Ä: ${output.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞" }}", "error")
                    }
                }
                sendScreenSaverStateToWeb(fetchScreenSaverState(adb))
            }.start()
        }

        @JavascriptInterface
        fun setScreenSaverPackage(packageName: String?) {
            if (packageName.isNullOrBlank()) return
            Thread {
                val adb = obtainConnectedAdb() ?: return@Thread
                if (!isPackageInstalled(adb, packageName)) {
                    Handler(Looper.getMainLooper()).post {
                        showToast("‚ùå –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ $packageName –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ", "error")
                    }
                    return@Thread
                }
                val component = resolveDreamComponent(adb, packageName)
                if (component == null) {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Å–ª—É–∂–±—É –∑–∞—Å—Ç–∞–≤–∫–∏ –≤ $packageName", "error")
                    return@Thread
                }
                val commands = listOf(
                    "settings put secure screensaver_components $component",
                    "settings put secure screensaver_default_component $component",
                    "cmd dream set-active $component"
                )
                var success = true
                var lastError = ""
                commands.forEach { cmd ->
                    val (ok, output) = runAdbCommand(adb, cmd)
                    if (!ok) {
                        success = false
                        lastError = output
                    }
                }
                if (success) {
                    runAdbCommand(adb, "cmd dream start $component")
                }
                Handler(Looper.getMainLooper()).post {
                    if (success) {
                        showToast("‚úÖ –ó–∞—Å—Ç–∞–≤–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∞", "success")
                    } else {
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∑–∞—Å—Ç–∞–≤–∫—É: ${lastError.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞" }}", "error")
                    }
                }
                sendScreenSaverStateToWeb(fetchScreenSaverState(adb))
            }.start()
        }

        @JavascriptInterface
        fun runScreenSaverPreview(componentOverride: String?) {
            Thread {
                val adb = obtainConnectedAdb() ?: return@Thread
                var lastError = ""
                val directCommands = listOf(
                    "service call dreams 1"
                )
                val directSuccess = directCommands.any { cmd ->
                    val (ok, output) = runAdbCommand(adb, cmd)
                    if (!ok && output.isNotBlank()) {
                        lastError = output
                    }
                    ok
                }
                if (directSuccess) {
                    Handler(Looper.getMainLooper()).post {
                        showToast("‚ñ∂Ô∏è –ó–∞–ø—É—Å–∫–∞—é —Ç–µ–∫—É—â—É—é –∑–∞—Å—Ç–∞–≤–∫—É", "info")
                    }
                    return@Thread
                }

                val rawComponent = componentOverride?.takeIf { it.isNotBlank() }
                    ?: adbValue(adb, "settings get secure screensaver_components")
                    ?: adbValue(adb, "settings get secure screensaver_default_component")
                if (rawComponent.isNullOrBlank()) {
                    showToast("‚ÑπÔ∏è –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∑–∞—Å—Ç–∞–≤–∫—É", "warning")
                    return@Thread
                }
                val selected = rawComponent
                    .split(':', ',', ';', '\n')
                    .map { it.trim() }
                    .firstOrNull { it.contains('/') && it.isNotBlank() }
                val component = selected?.let { ComponentName.unflattenFromString(it) } ?: run {
                    showToast("‚ÑπÔ∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –∑–∞—Å—Ç–∞–≤–∫–∏", "warning")
                    return@Thread
                }
                val flatComponent = component.flattenToString()
                ensurePackageRestored(adb, component.packageName)
                runAdbCommand(adb, "settings put secure screensaver_components $flatComponent")
                runAdbCommand(adb, "settings put secure screensaver_default_component $flatComponent")
                runAdbCommand(adb, "cmd dream set-active $flatComponent")
                val commands = listOf(
                    "cmd dream start $flatComponent",
                    "cmd dream start --user 0 $flatComponent",
                    "cmd dream start",
                    "cmd dream start --user 0",
                    "cmd dream test $flatComponent",
                    "cmd dream test --user 0 $flatComponent",
                    "am startservice -n $flatComponent --ez preview true --ez immediate true",
                    "am startservice --user 0 -n $flatComponent --ez preview true --ez immediate true"
                )
                var success = false
                commands.forEach { cmd ->
                    val (ok, output) = runAdbCommand(adb, cmd)
                    if (ok) {
                        success = true
                        lastError = ""
                        return@forEach
                    } else if (output.isNotBlank()) {
                        lastError = output
                    }
                }
                Handler(Looper.getMainLooper()).post {
                    if (success) {
                        showToast("‚ñ∂Ô∏è –ó–∞–ø—É—Å–∫–∞—é —Ç–µ–∫—É—â—É—é –∑–∞—Å—Ç–∞–≤–∫—É", "info")
                    } else {
                        val message = lastError.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞" }
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –∑–∞—Å—Ç–∞–≤–∫—É: $message", "error")
                    }
                }
            }.start()
        }

        @JavascriptInterface
        fun toggleScreenSaverEnabled() {
            Thread {
                val adb = obtainConnectedAdb() ?: return@Thread
                val current = fetchScreenSaverState(adb)
                val newValue = if (current?.enabled == true) "0" else "1"
                val (success, output) = runAdbCommand(adb, "settings put secure screensaver_enabled $newValue")
                Handler(Looper.getMainLooper()).post {
                    if (success) {
                        val label = if (newValue == "1") "–≤–∫–ª—é—á–µ–Ω–∞" else "–æ—Ç–∫–ª—é—á–µ–Ω–∞"
                        showToast("‚úÖ –ó–∞—Å—Ç–∞–≤–∫–∞ $label", "success")
                    } else {
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ: ${output.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞" }}", "error")
                    }
                }
                sendScreenSaverStateToWeb(fetchScreenSaverState(adb))
            }.start()
        }

        @JavascriptInterface
        fun resetScreenSaverSettings() {
            Thread {
                val adb = obtainConnectedAdb() ?: return@Thread
                val baseCommands = mutableListOf(
                    "settings delete secure screensaver_components",
                    "settings delete secure screensaver_default_component",
                    "settings put secure screensaver_enabled 1",
                    "settings put system screen_off_timeout 600000",
                    "settings delete secure sleep_timeout"
                )
                val systemComponent = resolveSystemScreenSaverComponent(adb)
                if (systemComponent != null) {
                    baseCommands += listOf(
                        "settings put secure screensaver_components $systemComponent",
                        "settings put secure screensaver_default_component $systemComponent"
                    )
                }
                var success = true
                var lastError = ""
                baseCommands.forEach { cmd ->
                    val (ok, output) = runAdbCommand(adb, cmd)
                    if (!ok) {
                        success = false
                        lastError = output
                    }
                }
                Handler(Looper.getMainLooper()).post {
                    if (success) {
                        val message = systemComponent?.let {
                            val label = friendlyDreamLabel(it) ?: "–°–∏—Å—Ç–µ–º–Ω–∞—è –∑–∞—Å—Ç–∞–≤–∫–∞"
                            "–ó–∞—Å—Ç–∞–≤–∫–∞ —Å–±—Ä–æ—à–µ–Ω–∞ –Ω–∞ $label"
                        } ?: "–°–±—Ä–æ—Å –≤—ã–ø–æ–ª–Ω–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–∏—Å—Ç–µ–º–Ω–∞—è –∑–∞—Å—Ç–∞–≤–∫–∞"
                        showToast("‚úÖ $message", "success")
                    } else {
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–±—Ä–æ—Å–∏—Ç—å: ${lastError.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞" }}", "error")
                    }
                }
                sendScreenSaverStateToWeb(fetchScreenSaverState(adb))
            }.start()
        }

        private fun ensurePackageRestored(adb: AdbConnectionManager, packageName: String): Boolean {
            val (hasPath, pathOutput) = runAdbCommand(adb, "pm path $packageName")
            if (hasPath && pathOutput.contains("package:")) return true
            val tryInstallCmd = listOf(
                "cmd package install-existing $packageName",
                "pm install-existing $packageName"
            )
            tryInstallCmd.forEach { cmd ->
                val (restored, _) = runAdbCommand(adb, cmd)
                if (restored) return true
            }
            return false
        }

        private fun resolveSystemScreenSaverComponent(adb: AdbConnectionManager): String? {
            SYSTEM_DREAM_COMPONENTS.forEach { component ->
                val pkg = component.substringBefore('/')
                val ensured = ensurePackageRestored(adb, pkg)
                if (!ensured) return@forEach
                val (resolved, _) = runAdbCommand(adb, "cmd package resolve-activity -n $component")
                if (resolved) {
                    runAdbCommand(adb, "pm enable --user 0 $pkg")
                    runAdbCommand(adb, "cmd package enable --user 0 $pkg")
                    return component
                }
            }
            return null
        }



        @JavascriptInterface
        fun openWirelessDebuggingSettings() {
            val activity = context as? MainActivity
            val startedViaAdb = activity?.tryOpenWirelessDebuggingViaAdb { executed ->
                if (executed) {
                    showToast("‚úÖ –û—Ç–∫—Ä—ã–ª —ç–∫—Ä–∞–Ω —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ. –í–∫–ª—é—á–∏—Ç–µ ¬´–û—Ç–ª–∞–¥–∫–∞ –ø–æ USB¬ª", "success")
                } else {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —ç–∫—Ä–∞–Ω —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ –ø–æ ADB", "error")
                }
            } ?: false
            if (startedViaAdb) return

            // 1) –ü—Ä–æ–±—É–µ–º –æ—Ç–∫—Ä—ã—Ç—å ¬´–î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤¬ª –Ω–∞ ATV –ø—Ä—è–º–æ –ø–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É
            if (tryStartComponent(
                    pkg = "com.android.tv.settings",
                    cls = "com.android.tv.settings.system.development.DevelopmentActivity"
                )
            ) {
                showToast("–í–∫–ª—é—á–∏—Ç–µ ¬´–û—Ç–ª–∞–¥–∫–∞ –ø–æ USB¬ª –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞", "info")
                return
            }
        
            // 2) –§–æ–ª–±—ç–∫: —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∏–Ω—Ç–µ–Ω—Ç —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞
            if (tryStartAction(Settings.ACTION_APPLICATION_DEVELOPMENT_SETTINGS)) {
                showToast("–í–∫–ª—é—á–∏—Ç–µ ¬´–û—Ç–ª–∞–¥–∫–∞ –ø–æ USB¬ª –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞", "info")
                return
            }
        
            // 3) –ü–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–Ω—Å ‚Äî –æ–±—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏; –µ–¥–∏–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
            if (tryStartAction(Settings.ACTION_SETTINGS)) {
                showToast("–ü–µ—Ä–µ–π–¥–∏—Ç–µ: –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí –°–∏—Å—Ç–µ–º–∞ ‚Üí –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ ‚Üí –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ ‚Üí –û—Ç–ª–∞–¥–∫–∞ –ø–æ USB", "info")
                return
            }
        
            // –ï—Å–ª–∏ –≤–æ–æ–±—â–µ –Ω–∏—á–µ–≥–æ –Ω–µ –æ—Ç–∫—Ä—ã–ª–æ—Å—å ‚Äî –æ–¥–Ω–æ –∏—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ + –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è
            showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —ç–∫—Ä–∞–Ω —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞. –û—Ç–∫—Ä–æ–π—Ç–µ –≤—Ä—É—á–Ω—É—é: –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí –°–∏—Å—Ç–µ–º–∞ ‚Üí –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ ‚Üí –î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ ‚Üí –û—Ç–ª–∞–¥–∫–∞ –ø–æ USB", "error")
        }
        
        private fun tryStartComponent(pkg: String, cls: String): Boolean = try {
            val intent = Intent().apply {
                component = ComponentName(pkg, cls)
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
            }
            context.startActivity(intent)
            true
        } catch (_: Exception) { false }
        
        private fun tryStartAction(action: String): Boolean = try {
            val intent = Intent(action).apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
            }
            context.startActivity(intent)
            true
        } catch (_: Exception) { false }
        





        @JavascriptInterface
        fun clearWebCache() {
            Handler(Looper.getMainLooper()).post {
                try {
                    // –û—á–∏—â–∞–µ–º WebView –∫—ç—à
                    webView.clearCache(true)

                    // –û—á–∏—â–∞–µ–º .apk –≤ cacheDir
                    val internalDeleted = context.cacheDir.listFiles()?.count {
                        it.name.endsWith(".apk") && it.delete()
                    } ?: 0

                    // –û—á–∏—â–∞–µ–º –≤—Å—ë –≤–æ –≤–Ω–µ—à–Ω–µ–º externalCacheDir
                    val externalDeleted = context.externalCacheDir?.listFiles()?.count {
                        it.delete()
                    } ?: 0

                    val total = internalDeleted + externalDeleted

                    // ... existing code ...
                    sendMessageToWebView("<img src='https://appassets.androidplatform.net/assets/webview/icons/misc/ic7_clearcash2.png' width='20' height='20' style='vertical-align: bottom;'> –ö—ç—à –æ—á–∏—â–µ–Ω. –£–¥–∞–ª–µ–Ω–æ —Ñ–∞–π–ª–æ–≤: $total")
// ... existing code ...
                } catch (e: Exception) {
                    sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞: ${e.message}")
                }
            }
        }

        @JavascriptInterface
        fun openLink(url: String) {
            Handler(Looper.getMainLooper()).post {
                try {
                    val intent = Intent(Intent.ACTION_VIEW, url.toUri())
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    context.startActivity(intent)
                } catch (e: Exception) {
                    e.printStackTrace()
                    sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è —Å—Å—ã–ª–∫–∏: ${e.message}")
                }
            }
        }

        @JavascriptInterface
        fun getConfigUrl(): String {
            return (context as? MainActivity)?.getConfigUrlForWeb() ?: ""
        }

        @JavascriptInterface
        fun openSettingsForPackage(pkg: String) {
            val activity = context as? MainActivity
            val adbConnected = activity?.adbManager?.getCurrentStatus()?.isConnected == true
            if (adbConnected) {
                Thread {
                    val adb = activity?.adbManager
                    if (adb == null) {
                        Handler(Looper.getMainLooper()).post {
                            showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ ADB", "error")
                        }
                        return@Thread
                    }

                    val output = StringBuilder()
                    val pkgExists = try {
                        adb.runShellCommand("pm list packages $pkg") { chunk ->
                            output.append(chunk)
                        }
                    } catch (_: Exception) {
                        false
                    } && output.toString().contains(pkg)

                    if (!pkgExists) {
                        Handler(Looper.getMainLooper()).post {
                            showToast("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ $pkg –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "error")
                        }
                        return@Thread
                    }

                    val commands = listOf(
                        "am start --user 0 -a android.settings.APPLICATION_DETAILS_SETTINGS -d package:$pkg",
                        "am start -a android.settings.APPLICATION_DETAILS_SETTINGS -d package:$pkg"
                    )
                    val executed = commands.any { cmd ->
                        try {
                            activity?.adbManager?.runShellCommand(cmd) { } == true
                        } catch (_: Exception) {
                            false
                        }
                    }
                    Handler(Looper.getMainLooper()).post {
                        if (!executed) {
                            sendMessageToWebView("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ $pkg —á–µ—Ä–µ–∑ ADB")
                        }
                    }
                }.start()
                return
            }

            if (getInstalledVersion(pkg) == 0L) {
                showToast("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ $pkg –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "error")
                return
            }
            openAppSettings(pkg)
        }
        

private fun isPackageInstalled(pkg: String): Boolean = try {
    if (Build.VERSION.SDK_INT >= 33) {
        context.packageManager.getPackageInfo(pkg, PackageManager.PackageInfoFlags.of(0))
    } else {
        @Suppress("DEPRECATION")
        context.packageManager.getPackageInfo(pkg, 0)
    }
    true
} catch (_: PackageManager.NameNotFoundException) { false }

private fun openAppInfoExact(pkg: String) {
    val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
        data = Uri.parse("package:$pkg")
        addCategory(Intent.CATEGORY_DEFAULT)
        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
    }
    context.startActivity(intent)
}








        private fun openAppSettings(packageName: String) {
            try {
                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
                    data = "package:$packageName".toUri()
                    flags = Intent.FLAG_ACTIVITY_NEW_TASK
                }
                startActivity(intent)
            } catch (e: Exception) {
                e.printStackTrace()
                sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫: ${e.message}")
            }
        }


        @JavascriptInterface
fun openActivityStubOneButton() {
    val candidates = listOf(
        "com.android.tv.frameworkpackagestubs",
        "com.google.android.tv.frameworkpackagestubs"
    )
    val activity = context as? MainActivity
    val adbConnected = activity?.adbManager?.getCurrentStatus()?.isConnected == true
    if (adbConnected) {
        Thread {
            val mainActivity = activity
            val adb = mainActivity?.adbManager
            if (adb == null) {
                Handler(Looper.getMainLooper()).post {
                    showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ ADB", "error")
                }
                return@Thread
            }

            val remotePackage = candidates.firstOrNull { pkg ->
                val output = StringBuilder()
                val success = try {
                    adb.runShellCommand("pm list packages $pkg") { chunk ->
                        output.append(chunk)
                    }
                } catch (_: Exception) {
                    false
                }
                success && output.toString().contains(pkg)
            }

            if (remotePackage == null) {
                Handler(Looper.getMainLooper()).post {
                    showToast("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ Activity Stub –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "error")
                }
                return@Thread
            }

            val cmd = "am start --user 0 -a android.settings.APPLICATION_DETAILS_SETTINGS -d package:$remotePackage"
            val executed = try {
                adb.runShellCommand(cmd) { } == true
            } catch (_: Exception) {
                false
            }
            Handler(Looper.getMainLooper()).post {
                if (!executed) {
                    showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å Activity Stub —á–µ—Ä–µ–∑ ADB", "error")
                }
            }
        }.start()
        return
    }

    val found = candidates.firstOrNull { isPackageInstalled(it) }
    if (found != null) {
        try {
            openAppInfoExact(found)
        } catch (e: Exception) {
            showToast("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å: ${e.message}", "error")
        }
    } else {
        showToast("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ Activity Stub –Ω–µ –Ω–∞–π–¥–µ–Ω–æ", "error")
    }
}


        @JavascriptInterface
        fun confirmDeleteCopiedBackups() {
            Handler(Looper.getMainLooper()).post {
                showInstallPrompt(
                    title = "–£–¥–∞–ª–µ–Ω–∏–µ –±—ç–∫–∞–ø–æ–≤",
                    message = "–ë—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã –≤—Å–µ —Ä–∞–Ω–µ–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –±—ç–∫–∞–ø–æ–≤ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?",
                    installLabel = "–£–¥–∞–ª–∏—Ç—å",
                    onInstall = { deleteCopiedBackups() },
                    laterLabel = "–û—Ç–º–µ–Ω–∞",
                    onLater = { sendMessageToWebView("‚úÖ –û—á–∏—Å—Ç–∫–∞ –±—ç–∫–∞–ø–æ–≤ –æ—Ç–º–µ–Ω–µ–Ω–∞") },
                    cancelable = true
                )
            }
        }

        fun deleteCopiedBackups() {
            Thread {
                val activity = context as? MainActivity
                val registryResult = activity?.cleanupRegisteredBackups()
                val legacyDeleted = deleteBackupsFromConfigLegacy()

                val parts = mutableListOf<String>()
                if (registryResult != null) {
                    if (registryResult.deletedLocal > 0) {
                        parts += "–ª–æ–∫–∞–ª—å–Ω–æ ${registryResult.deletedLocal}"
                    }
                    if (registryResult.deletedRemote > 0) {
                        parts += "–ø–æ ADB ${registryResult.deletedRemote}"
                    }
                }
                if (legacyDeleted > 0) {
                    parts += "–ø–æ –∫–æ–Ω—Ñ–∏–≥—É $legacyDeleted"
                }

                when {
                    parts.isEmpty() -> sendMessageToWebView("‚ÑπÔ∏è –§–∞–π–ª—ã –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã")
                    else -> sendMessageToWebView("üßπ –£–¥–∞–ª–µ–Ω–æ: ${parts.joinToString(", ")}")
                }

                if (registryResult?.pendingRemote ?: 0 > 0) {
                    sendMessageToWebView("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å ${registryResult?.pendingRemote} —Ñ–∞–π–ª–æ–≤ –Ω–∞ —É–¥–∞–ª—ë–Ω–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ. –ü–æ–¥–∫–ª—é—á–∏—Ç–µ—Å—å –ø–æ ADB –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –æ—á–∏—Å—Ç–∫—É.")
                }
            }.start()
        }

        private fun deleteBackupsFromConfigLegacy(): Int {
            return try {
                val configUrl = (context as? MainActivity)?.getConfigUrlForWeb() ?: return 0
                val configText = URL(configUrl).readText()
                val config = JSONObject(configText)
                val backups = config.getJSONArray("backups")
                var deletedCount = 0

                for (i in 0 until backups.length()) {
                    val backup = backups.getJSONObject(i)
                    if (backup.has("files")) {
                        val filesArr = backup.getJSONArray("files")
                        for (j in 0 until filesArr.length()) {
                            val fileObj = filesArr.getJSONObject(j)
                            val url = fileObj.optString("url", "")
                            if (url.isBlank()) continue
                            val targetFolder = fileObj.optString("target_folder", backup.optString("target_folder", "Download"))
                            val targetDir = resolveBackupTargetDir(targetFolder)
                            val fileName = url.toUri().lastPathSegment ?: continue
                            val file = File(targetDir, fileName)
                            if (isWallpaperProtectedPath(file.absolutePath)) continue
                            if (file.exists() && file.delete()) deletedCount++
                        }
                    } else {
                        val urls = when {
                            backup.has("urls") -> {
                                val arr = backup.getJSONArray("urls")
                                List(arr.length()) { idx -> arr.optString(idx) }
                            }
                            backup.has("url") -> listOf(backup.optString("url"))
                            else -> emptyList()
                        }
                        val targetFolder = backup.optString("target_folder", "Download")
                        val targetDir = resolveBackupTargetDir(targetFolder)
                        urls.forEach { url ->
                            if (url.isNullOrBlank()) return@forEach
                            val fileName = url.toUri().lastPathSegment ?: return@forEach
                            val file = File(targetDir, fileName)
                            if (isWallpaperProtectedPath(file.absolutePath)) return@forEach
                            if (file.exists() && file.delete()) deletedCount++
                        }
                    }
                }
                deletedCount
            } catch (e: Exception) {
                sendMessageToWebView("‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: ${e.message}")
                0
            }
        }

        @JavascriptInterface
        fun setAutostartPackage(packageName: String) {
            val prefs = context.getSharedPreferences("autostart", Context.MODE_PRIVATE)
            prefs.edit { putString("autostart_package", packageName) }
        }

        @JavascriptInterface
        fun clearAutostartPackage() {
            val prefs = context.getSharedPreferences("autostart", Context.MODE_PRIVATE)
            prefs.edit { remove("autostart_package") }
        }

        @JavascriptInterface
        fun getInstalledApps() {
            try {
                val pm = context.packageManager
                val apps = pm.getInstalledApplications(0)
                val jsonArray = JSONArray()

                for (app in apps) {
                    val appName = pm.getApplicationLabel(app).toString()
                    val packageName = app.packageName
                    val appJson = JSONObject()
                    appJson.put("name", appName)
                    appJson.put("package", packageName)
                    jsonArray.put(appJson)
                }

                val json = jsonArray.toString()

                (context as Activity).runOnUiThread {
                    webView.evaluateJavascript("onInstalledAppsReceived(${JSONObject.quote(json)})", null)
                }
            } catch (e: Exception) {
                e.printStackTrace()
                (context as Activity).runOnUiThread {
                    webView.evaluateJavascript("onInstalledAppsReceived('[]')", null)
                }
            }
        }


        @JavascriptInterface
        fun getUserApps() {
            val pm = context.packageManager
            val apps = pm.getInstalledApplications(PackageManager.GET_META_DATA)
                .filter {
                    pm.getLaunchIntentForPackage(it.packageName) != null &&
                            (it.flags and ApplicationInfo.FLAG_SYSTEM) == 0 // –¢–æ–ª—å–∫–æ user apps
                }
                .map {
                    mapOf(
                        "label" to pm.getApplicationLabel(it).toString(),
                        "package" to it.packageName,
                        "icon" to "data:image/png;base64," + encodeIconToBase64(pm.getApplicationIcon(it))
                    )
                }

            val json = JSONArray(apps).toString()
            (context as Activity).runOnUiThread {
                webView.evaluateJavascript("renderAppSelection(${JSONObject.quote(json)});", null)
            }
        }

        @JavascriptInterface
        fun getAppsInventory(source: String? = "auto"): String {
            val sourceLower = source?.lowercase(Locale.ROOT) ?: "auto"
            val useRemotePreferred = when (sourceLower) {
                "remote", "adb" -> true
                "local" -> false
                else -> null
            }

            val activity = context as? MainActivity
            val adb = if (activity != null && activity::adbManager.isInitialized) activity.adbManager else null
            val adbConnected = adb?.getCurrentStatus()?.isConnected == true
            val useRemote = useRemotePreferred == true || (useRemotePreferred == null && adbConnected)

            // –ï—Å–ª–∏ –∑–∞–ø—Ä–æ—à–µ–Ω ADB-—Ä–µ–∂–∏–º –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ, –Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –Ω–µ—Ç ‚Äî –Ω–µ –ø–∞–¥–∞–µ–º –≤ –ª–æ–∫–∞–ª—å–Ω—ã–π fallback
            if (useRemotePreferred == true && (!adbConnected || adb == null)) {
                return JSONObject().apply {
                    put("source", "adb")
                    put("sourceLabel", "ADB –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω")
                    put("adbConnected", false)
                    put("apps", JSONArray())
                    put("error", "ADB –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω")
                }.toString()
            }

            return try {
                val localApps = fetchLocalAppsDetailed()
                val localIcons = localApps.associate { it.packageName to (it.icon ?: "") }.filterValues { it.isNotBlank() }
                val localLabels = localApps.associate { it.packageName to it.label }
                val localVersions = localApps.associate { it.packageName to (it.version ?: "") }.filterValues { it.isNotBlank() }

                val (rawApps, error) = if (useRemote && adbConnected && adb != null) {
                    fetchRemoteAppsDetailed(adb)
                } else {
                    localApps to null
                }

                val src = if (useRemote && adbConnected) "adb" else "local"

                val apps = rawApps.map { app ->
                    val label = if (app.label.isBlank() || app.label == app.packageName) {
                        localLabels[app.packageName] ?: app.label
                    } else app.label
                    val icon = app.icon ?: localIcons[app.packageName]
                    val version = if (src == "adb") {
                        app.version // –Ω–µ –ø–æ–¥–º–µ—à–∏–≤–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—É—é, —á—Ç–æ–±—ã –Ω–µ –ø—É—Ç–∞—Ç—å
                    } else {
                        app.version ?: localVersions[app.packageName]
                    }
                    app.copy(label = label, icon = icon, version = version)
                }

                val statusInfo = adb?.getCurrentStatus()
                val label = if (useRemote && adbConnected && statusInfo != null) {
                    val hostPart = statusInfo.host.takeIf { it.isNotBlank() } ?: ""
                    val portPart = statusInfo.port.takeIf { it > 0 }?.toString() ?: ""
                    val hostPort = listOf(hostPart, portPart).filter { it.isNotBlank() }.joinToString(":")
                    if (hostPort.isNotBlank()) "ADB $hostPort" else "ADB —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"
                } else "–õ–æ–∫–∞–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"

                JSONObject().apply {
                    put("source", src)
                    put("sourceLabel", label)
                    put("adbConnected", adbConnected)
                    put("apps", JSONArray().apply { apps.forEach { put(it.toJson()) } })
                    if (localIcons.isNotEmpty()) {
                        val iconsObj = JSONObject()
                        localIcons.forEach { (pkg, icon) -> iconsObj.put(pkg, icon) }
                        put("localIcons", iconsObj)
                    }
                    if (localLabels.isNotEmpty()) {
                        val labelsObj = JSONObject()
                        localLabels.forEach { (pkg, lbl) -> labelsObj.put(pkg, lbl) }
                        put("localLabels", labelsObj)
                    }
                    if (src != "adb" && localVersions.isNotEmpty()) {
                        val verObj = JSONObject()
                        localVersions.forEach { (pkg, ver) -> verObj.put(pkg, ver) }
                        put("localVersions", verObj)
                    }
                    error?.let { put("error", it) }
                }.toString()
            } catch (e: Exception) {
                JSONObject().apply {
                    put("source", "local")
                    put("error", e.message ?: "unknown")
                    put("apps", JSONArray())
                }.toString()
            }
        }

        @JavascriptInterface
        fun performAppAction(action: String, packageName: String, source: String? = "auto"): String {
            val actionLower = action.lowercase(Locale.ROOT)
            val targetSource = source?.lowercase(Locale.ROOT) ?: "auto"

            val activity = context as? MainActivity
            val adb = if (activity != null && activity::adbManager.isInitialized) activity.adbManager else null
            val adbConnected = adb?.getCurrentStatus()?.isConnected == true
            val useRemote = targetSource == "remote" || targetSource == "adb" || (targetSource == "auto" && adbConnected)

            val (ok, message) = try {
                if (useRemote && adbConnected && adb != null) {
                    performRemoteAppAction(adb, actionLower, packageName)
                } else {
                    performLocalAppAction(actionLower, packageName)
                }
            } catch (e: Exception) {
                false to ("–û—à–∏–±–∫–∞: ${e.message}")
            }

            return JSONObject().apply {
                put("success", ok)
                put("message", message)
            }.toString()
        }

        private fun fetchLocalAppsDetailed(): List<JsAppEntry> {
            val pm = context.packageManager
            return pm.getInstalledApplications(PackageManager.GET_META_DATA)
                .mapNotNull { app ->
                    try {
                        val label = pm.getApplicationLabel(app).toString()
                        val pkg = app.packageName
                        val version = runCatching {
                            val pi = pm.getPackageInfo(pkg, 0)
                            listOfNotNull(pi.versionName, pi.versionCode.takeIf { it > 0 }?.toString())
                                .joinToString(" ").trim()
                        }.getOrNull()
                        val isSystem = (app.flags and ApplicationInfo.FLAG_SYSTEM) != 0
                        val enabledSetting = pm.getApplicationEnabledSetting(pkg)
                        val enabled = when (enabledSetting) {
                            PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                            PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER,
                            PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED -> false
                            else -> app.enabled
                        }
                        val state = if (enabled) "enabled" else "disabled"
                        val iconBase64 = runCatching {
                            val icon = pm.getApplicationIcon(app)
                            "data:image/png;base64," + encodeIconToBase64(icon, 96)
                        }.getOrNull()
                        JsAppEntry(label, pkg, if (isSystem) "system" else "user", state, iconBase64, version)
                    } catch (_: Exception) {
                        null
                    }
                }
        }

        private fun fetchRemoteAppsDetailed(adb: AdbConnectionManager): Pair<List<JsAppEntry>, String?> {
            val errors = mutableListOf<String>()

            fun runList(cmd: String): List<String> {
                val (ok, out) = runAdbCommand(adb, cmd)
                if (!ok) {
                    errors += "$cmd ‚Üí ${out.take(120)}"
                    return emptyList()
                }
                return parsePackageListOutput(out)
            }

            val userPkgs = runList("pm list packages --user 0 -3").ifEmpty { runList("pm list packages -3") }
            val systemPkgs = runList("pm list packages --user 0 -s").ifEmpty { runList("pm list packages -s") }
            val disabledPkgs = runList("pm list packages --user 0 -d").ifEmpty { runList("pm list packages -d") }
            val installedAll = runList("pm list packages --user 0").ifEmpty { runList("pm list packages") }
            val withDeleted = runList("pm list packages --user 0 -u").ifEmpty { runList("pm list packages -u") }

            val deletedPkgs = withDeleted.filter { it !in installedAll }.toSet()

            val union = linkedSetOf<String>().apply {
                addAll(userPkgs)
                addAll(systemPkgs)
                addAll(disabledPkgs)
                addAll(deletedPkgs)
                addAll(installedAll)
            }

            val apps = union.map { pkg ->
                val type = if (pkg in systemPkgs) "system" else "user"
                val state = when {
                    pkg in deletedPkgs -> "deleted"
                    pkg in disabledPkgs -> "disabled"
                    else -> "enabled"
                }
                JsAppEntry(pkg, pkg, type, state, null, null)
            }

            val errMsg = if (errors.isNotEmpty()) errors.joinToString("; ").take(500) else null
            return apps to errMsg
        }

        // fetchRemoteLabelVersion —É–¥–∞–ª—ë–Ω (dumpsys package –æ—Ç–∫–ª—é—á—ë–Ω)

        private fun performLocalAppAction(action: String, packageName: String): Pair<Boolean, String> {
            val pm = context.packageManager
            return when (action) {
                "enable" -> {
                    pm.setApplicationEnabledSetting(packageName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP)
                    true to "–í–∫–ª—é—á–µ–Ω–æ –ª–æ–∫–∞–ª—å–Ω–æ"
                }
                "disable" -> {
                    pm.setApplicationEnabledSetting(packageName, PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER, PackageManager.DONT_KILL_APP)
                    true to "–û—Ç–∫–ª—é—á–µ–Ω–æ –ª–æ–∫–∞–ª—å–Ω–æ"
                }
                "delete" -> uninstallLocalPackage(packageName)
                "open" -> {
                    val intent = pm.getLaunchIntentForPackage(packageName)
                    return if (intent != null) {
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                        context.startActivity(intent)
                        true to "–û—Ç–∫—Ä—ã—Ç–æ"
                    } else {
                        false to "–ù–µ—Ç launch activity"
                    }
                }
                "save" -> copyLocalApkToDownloads(packageName)
                else -> false to "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ"
            }
        }

        private fun uninstallLocalPackage(packageName: String): Pair<Boolean, String> {
            return try {
                val intent = Intent(Intent.ACTION_DELETE, Uri.parse("package:$packageName"))
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                context.startActivity(intent)
                true to "–û—Ç–∫—Ä—ã—Ç–æ –æ–∫–Ω–æ —É–¥–∞–ª–µ–Ω–∏—è"
            } catch (e: Exception) {
                false to ("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: ${e.message}")
            }
        }

        private fun copyLocalApkToDownloads(packageName: String): Pair<Boolean, String> {
            return try {
                val pm = context.packageManager
                val appInfo = pm.getApplicationInfo(packageName, 0)
                val srcPath = appInfo.publicSourceDir ?: appInfo.sourceDir
                if (srcPath.isNullOrBlank()) return false to "–ù–µ –Ω–∞–π–¥–µ–Ω –ø—É—Ç—å APK"
                val src = File(srcPath)
                if (!src.exists()) return false to "–§–∞–π–ª APK –Ω–µ –Ω–∞–π–¥–µ–Ω"

                val downloads = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                    ?: context.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS)
                    ?: context.filesDir
                val dst = File(downloads, "${packageName}.apk")
                dst.parentFile?.mkdirs()
                src.copyTo(dst, overwrite = true)
                true to "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –ó–∞–≥—Ä—É–∑–∫–∏: ${dst.name}"
            } catch (e: Exception) {
                false to ("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ${e.message}")
            }
        }

        private fun performRemoteAppAction(adb: AdbConnectionManager, action: String, packageName: String): Pair<Boolean, String> {
            return when (action) {
                "enable" -> {
                    // –ü—Ä–æ–±—É–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —É–¥–∞–ª—ë–Ω–Ω–æ–µ/–æ—Ç–∫–ª—é—á—ë–Ω–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
                    val (ok1, out1) = runAdbCommand(adb, """pm install-existing "$packageName"""")
                    if (!ok1 || out1.contains("Error") || out1.contains("Failure")) {
                        // –ï—Å–ª–∏ install-existing –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º enable
                        runAdbCommand(adb, """pm enable --user 0 "$packageName"""")
                    } else {
                        ok1 to out1
                    }
                }
                "disable" -> runAdbCommand(adb, """pm disable-user --user 0 "$packageName"""")
                "delete" -> runAdbCommand(adb, """pm uninstall --user 0 "$packageName"""")
                "open" -> runAdbCommand(adb, """monkey -p "$packageName" -c android.intent.category.LAUNCHER 1""")
                "save" -> pullRemoteApk(adb, packageName)
                else -> false to "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ"
            }
        }

        private fun pullRemoteApk(adb: AdbConnectionManager, packageName: String): Pair<Boolean, String> {
            val (ok, output) = runAdbCommand(adb, """pm path "$packageName"""")
            if (!ok || output.isBlank()) return false to "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—É—Ç—å APK"
            val remotePath = output
                .lineSequence()
                .map { it.trim() }
                .firstOrNull { it.startsWith("package:") }
                ?.removePrefix("package:")
                ?.trim()
                ?: return false to "–ü—É—Ç—å APK –Ω–µ –Ω–∞–π–¥–µ–Ω"

            val downloads = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                ?: context.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS)
                ?: context.filesDir
            val dst = File(downloads, "${packageName}.apk")

            val pulled = adb.pullFileFromDevice(remotePath, dst) { msg -> sendMessageToWebView(msg) }
            return if (pulled) {
                true to "APK —Å–æ—Ö—Ä–∞–Ω—ë–Ω: ${dst.name}"
            } else {
                false to "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å APK"
            }
        }

        @JavascriptInterface
        fun getUserInstalledPackages(): String {
            return try {
                val packages = queryRemoteUserPackages()
                JSONArray(packages).toString()
            } catch (e: Exception) {
                Log.w(ADB_LOG_TAG, "getUserInstalledPackages error", e)
                "[]"
            }
        }

        private fun queryRemoteUserPackages(): List<String> {
            val activity = context as? MainActivity ?: return emptyList()
            if (!activity::adbManager.isInitialized) return emptyList()
            val adb = activity.adbManager
            if (!adb.getCurrentStatus().isConnected) return emptyList()

            val commands = listOf(
                "pm list packages --user 0 -3",
                "pm list packages -3",
                "cmd package list packages --user 0 --third-party",
                "cmd package list packages --third-party"
            )

            val discovered = linkedSetOf<String>()
            commands.forEach { cmd ->
                val (success, output) = runAdbCommand(adb, cmd)
                if (!success || output.isBlank()) {
                    Log.w(ADB_LOG_TAG, "getUserInstalledPackages: $cmd failed: ${output.take(120)}")
                    return@forEach
                }
                val packages = parsePackageListOutput(output)
                if (packages.isNotEmpty()) {
                    discovered += packages
                }
            }
            return discovered.sorted()
        }
        @JavascriptInterface
        fun saveAutostartPackage(packageName: String) {
            context.getSharedPreferences("autostart", Context.MODE_PRIVATE)
                .edit {
                    putString("autostart_package", packageName)
                }
        }


        @JavascriptInterface
fun testAutostart() {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—ã–±—Ä–∞–Ω–æ –ª–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞
    val prefs = context.getSharedPreferences("autostart", Context.MODE_PRIVATE)
    val autostartPackage = prefs.getString("autostart_package", null)
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ overlay –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        val canOverlay = Settings.canDrawOverlays(context)
        if (!canOverlay) {
            Handler(Looper.getMainLooper()).post {
                (context as? MainActivity)?.showInstallPrompt(
                    title = "–¢—Ä–µ–±—É–µ—Ç—Å—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ",
                    message = "–î–ª—è —Ä–∞–±–æ—Ç—ã –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–∞–∑—Ä–µ—à–∏—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö –¥—Ä—É–≥–∏—Ö –æ–∫–æ–Ω.\n\n" +
                            "–ù–∞–∂–º–∏—Ç–µ –†–ê–ó–†–ï–®–ò–¢–¨, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.",
                    installLabel = "–†–ê–ó–†–ï–®–ò–¢–¨",
                    onInstall = {
                        val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION).apply {
                            data = "package:${context.packageName}".toUri()
                        }
                        context.startActivity(intent)
                    },
                    laterLabel = "–ü–û–ó–ñ–ï",
                    onLater = {},
                    cancelable = true
                )
            }
            return
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—ã–±—Ä–∞–Ω–æ –ª–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–ª—è –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞
    if (autostartPackage.isNullOrEmpty()) {
        showToast("–ü—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–ª—è –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω—ã!", "error")
        return
    }
    
    val intent = Intent(context, AutostartService::class.java)
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        context.startForegroundService(intent)
    } else {
        context.startService(intent)
    }
    
    // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    showToast("–ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –∑–∞–ø—É—â–µ–Ω", "success")
}


        @JavascriptInterface
                fun showToast(message: String, type: String = "info", icon: String? = null) {
            Handler(Looper.getMainLooper()).post {
                try {
                    val safeMessage = message.replace("'", "\\'")
                    val safeType = type.replace("'", "\\'")
                    val safeIcon = icon?.replace("'", "\\'") ?: ""
                    webView.evaluateJavascript("showToast({message: '$safeMessage', type: '$safeType', iconUrl: '$safeIcon'})", null) 
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }

        @JavascriptInterface
        fun showCpuRamToast() {
            Thread {
                val temp = readCpuTemp()
                val mem = readMemAvailable()
                val storage = getStorageFreeLabel(preferAdb = false)
                val msg = "CPU: ${temp}¬∞C  RAM: $mem  Free: $storage"
                Handler(Looper.getMainLooper()).post {
                    Toast.makeText(context, msg, Toast.LENGTH_LONG).show()
                }
            }.start()
        }

        @JavascriptInterface
        fun showCpuRamToastAdb() {
            val adb = obtainConnectedAdb(silent = false) ?: return
            Thread {
                fun parseHwTemp(dump: String): Double? =
                    Regex("CPU temperatures:\\s*\\[([^\\]]+)]", RegexOption.IGNORE_CASE)
                        .find(dump)
                        ?.groupValues
                        ?.getOrNull(1)
                        ?.split(",")
                        ?.firstOrNull()
                        ?.trim()
                        ?.toDoubleOrNull()

                fun parseThermalTemp(dump: String): Double? =
                    Regex("mValue=([0-9.+-]+)", RegexOption.IGNORE_CASE)
                        .find(dump)
                        ?.groupValues
                        ?.getOrNull(1)
                        ?.toDoubleOrNull()

                fun parseMemAvailable(meminfo: String): String? =
                    Regex("MemAvailable:\\s*(\\d+)", RegexOption.IGNORE_CASE)
                        .find(meminfo)
                        ?.groupValues
                        ?.getOrNull(1)
                        ?.toLongOrNull()
                        ?.let { "${it / 1024}MB" }

                val tempVal = runAdbCommand(adb, "dumpsys hardware_properties").second.let { dump ->
                    parseHwTemp(dump) ?: runAdbCommand(adb, "dumpsys thermalservice").second.let { parseThermalTemp(it) }
                }
                val temp = tempVal?.let { String.format("%.1f", it) } ?: "n/a"

                val mem = runAdbCommand(adb, "cat /proc/meminfo").second.let { dump ->
                    parseMemAvailable(dump)
                } ?: "n/a"

                val storage = getStorageFreeLabel(preferAdb = true)
                val msg = "CPU: ${temp}¬∞C  RAM: $mem  Free: $storage"
                Handler(Looper.getMainLooper()).post {
                    Toast.makeText(context, msg, Toast.LENGTH_LONG).show()
                }
            }.start()
        }

        private fun getStorageFreeLabel(preferAdb: Boolean): String {
            val usage = runCatching { fetchStorageUsage() }.getOrNull()
            val freeMb = usage?.let {
                val freeBytes = (it.totalBytes - it.usedBytes).coerceAtLeast(0)
                freeBytes / (1024.0 * 1024.0)
            }
            return formatStorageMb(freeMb)
        }

        private fun formatStorageMb(mb: Double?): String {
            if (mb == null || !mb.isFinite() || mb < 0) return "n/a"
            return if (mb < 1024) {
                "${mb.roundToInt()} MB"
            } else {
                String.format(Locale.US, "%.2f GB", mb / 1024.0)
            }
        }

        @JavascriptInterface
        fun DeleteAutostartPackage(packageName: String?) {
            val prefs = context.getSharedPreferences("autostart", Context.MODE_PRIVATE)
            prefs.edit {
                if (packageName.isNullOrEmpty()) {
                    remove("autostart_package")
                } else {
                    putString("autostart_package", packageName)
                }
            }
        }


        @JavascriptInterface
        fun requestAppExit() {
            val now = System.currentTimeMillis()
            if (now - lastBackPressedTime < backPressInterval) {
                (context as? Activity)?.finish()
            } else {
                lastBackPressedTime = now
                (context as Activity).runOnUiThread {
                    Toast.makeText(context, "–ù–∞–∂–º–∏—Ç–µ –µ—â—ë —Ä–∞–∑ –¥–ª—è –≤—ã—Ö–æ–¥–∞", Toast.LENGTH_SHORT).show()
                }
            }
        }

        @JavascriptInterface
        fun openAddAccountSettings() {
            val activity = context as? MainActivity
            val adbConnected = activity?.adbManager?.getCurrentStatus()?.isConnected == true
            if (adbConnected) {
                Thread {
                    val commands = listOf(
                        "am start --user 0 -a android.settings.ADD_ACCOUNT_SETTINGS",
                        "am start -a android.settings.ADD_ACCOUNT_SETTINGS"
                    )
                    val executed = commands.any { cmd ->
                        try {
                            activity?.adbManager?.runShellCommand(cmd) { } == true
                        } catch (_: Exception) {
                            false
                        }
                    }
                    Handler(Looper.getMainLooper()).post {
                        if (!executed) {
                            sendMessageToWebView("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞ —á–µ—Ä–µ–∑ ADB")
                        }
                    }
                }.start()
                return
            }

            val intent = Intent("android.settings.ADD_ACCOUNT_SETTINGS").apply {
                flags = Intent.FLAG_ACTIVITY_NEW_TASK
            }
            context.startActivity(intent)
        }

        @JavascriptInterface
        fun getCurrentAutostartApp() {
            val prefs = context.getSharedPreferences("autostart", Context.MODE_PRIVATE)
            val pkg = prefs.getString("autostart_package", null)

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ overlay –ø–µ—Ä–µ–¥ –ø–æ–ª—É—á–µ–Ω–∏–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–µ
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                val canOverlay = Settings.canDrawOverlays(context)
                if (!canOverlay) {
            Handler(Looper.getMainLooper()).post {
                (context as? MainActivity)?.showInstallPrompt(
                    title = "–¢—Ä–µ–±—É–µ—Ç—Å—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ",
                    message = "–î–ª—è —Ä–∞–±–æ—Ç—ã –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ä–∞–∑—Ä–µ—à–∏—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö –¥—Ä—É–≥–∏—Ö –æ–∫–æ–Ω.\n\n–ù–∞–∂–º–∏—Ç–µ –†–ê–ó–†–ï–®–ò–¢–¨, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.",
                    installLabel = "–†–ê–ó–†–ï–®–ò–¢–¨",
                    onInstall = {
                        val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION).apply {
                            data = "package:${context.packageName}".toUri()
                        }
                        context.startActivity(intent)
                    },
                    laterLabel = "–ü–æ–∑–∂–µ",
                    onLater = {},
                    cancelable = true
                )
            }
                    return
                }
            }

            // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–æ –≤—ã–±—Ä–∞–Ω–æ
            if (!pkg.isNullOrEmpty()) {
                val pm = context.packageManager
                val appInfo = pm.getApplicationInfo(pkg, 0)
                val label = pm.getApplicationLabel(appInfo).toString()
                val icon = encodeIconToBase64(pm.getApplicationIcon(appInfo))

                val js = "setCurrentAutostartApp(${JSONObject.quote(label)}, 'data:image/png;base64,$icon');"
                (context as Activity).runOnUiThread {
                    webView.evaluateJavascript(js, null)
                }
            }
        }

        @JavascriptInterface
        fun requestPasswordPrefill(current: String?) {
            showPasswordDialog(current)
        }

        @JavascriptInterface
        fun requestPassword() {
            showPasswordDialog(null)
        }

        @JavascriptInterface
fun updateWebView() {
        Handler(Looper.getMainLooper()).post {
            showInstallPrompt(
                title = "–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Android System WebView",
                message = "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–∫—Ç—É–∞–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é Android System WebView?",
                installLabel = "–î–ê",
                onInstall = { checkAndInstallWebView() },
                laterLabel = "–ù–ï–¢",
                onLater = {},
                cancelable = true
            )
        }
}



private fun checkAndInstallWebView() {
    Thread {
        try {
            sendMessageToWebView("üîé –ü—Ä–æ–≤–µ—Ä—è—é –≤–µ—Ä—Å–∏—é WebView...")

            // 1) –ë—ã—Å—Ç—Ä–∞—è —Å–≤–µ—Ä–∫–∞ –ø–æ metadata.json
            val meta = fetchWebViewMeta()
            if (meta != null) {
                val installed = getInstalledVersion(meta.packageName)
                if (installed >= meta.versionCode && installed != 0L) {
                    showToast("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è ‚Äî –∞–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞", "success")
                    return@Thread
                }
                // –ù—É–∂–Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∞/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
                Handler(Looper.getMainLooper()).post {
                    installSingle(meta.apkUrl, "Android System WebView")
                }
                return@Thread
            }

            // 2) –§–æ–ª–±—ç–∫: —Å–≤–µ—Ä–∫–∞ –≤–µ—Ä—Å–∏–∏ –ø–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è APK
            val url = "https://tvboxsetup.ru/fastinstaller/WebView/WebView_upd.apk"
            val tmp = File(context.cacheDir, "webview_${System.currentTimeMillis()}.apk")
            val conn = (URL(url).openConnection() as HttpURLConnection).apply { connect() }
            BufferedInputStream(conn.inputStream).use { input ->
                FileOutputStream(tmp).use { output -> input.copyTo(output) }
            }

            val apkInfo = readApkVersion(tmp)
            if (apkInfo == null) {
                tmp.delete()
                showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å –≤–µ—Ä—Å–∏—é APK WebView", "error")
                return@Thread
            }

            val (pkg, remoteVer) = apkInfo
            val installed = getInstalledVersion(pkg)
            if (installed >= remoteVer && installed != 0L) {
                tmp.delete()
                showToast("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è ‚Äî –∞–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞", "success")
                return@Thread
            }

            // –¢—Ä–µ–±—É–µ—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ª–æ–≥–∏–∫—É
            Handler(Looper.getMainLooper()).post {
                installSingle(url, "Android System WebView")
            }
            // –í installSingle APK –±—É–¥–µ—Ç —Å–∫–∞—á–∞–Ω –∑–∞–Ω–æ–≤–æ —à—Ç–∞—Ç–Ω—ã–º –º–µ—Ç–æ–¥–æ–º; –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª —É–¥–∞–ª—è–µ–º –∑–¥–µ—Å—å
            tmp.delete()

        } catch (e: Exception) {
            e.printStackTrace()
            showToast("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ WebView: ${e.message}", "error")
        }
    }.start()
}

private fun fetchWebViewMeta(): WebViewMeta? {
    return try {
        val text = URL("https://tvboxsetup.ru/fastinstaller/WebView/metadata.json").readText()
        val j = JSONObject(text)
        val pkg = j.optString("packageName", "")
        val verCode = j.optLong("versionCode", 0L)
        val verName = j.optString("versionName", "")
        val apkUrl = j.optString("apkUrl", "https://tvboxsetup.ru/fastinstaller/WebView/WebView_upd.apk")
        if (pkg.isNotBlank() && verCode > 0L) WebViewMeta(pkg, verCode, verName, apkUrl) else null
    } catch (_: Exception) {
        null
    }
}

private fun getInstalledVersion(pkg: String): Long {
    return try {
        val pm = context.packageManager
        val pi = if (Build.VERSION.SDK_INT >= 33)
            pm.getPackageInfo(pkg, PackageManager.PackageInfoFlags.of(0))
        else
            @Suppress("DEPRECATION") pm.getPackageInfo(pkg, 0)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P)
            pi.longVersionCode
        else
            @Suppress("DEPRECATION") pi.versionCode.toLong()
    } catch (_: Exception) {
        0L
    }
}



private fun readApkVersion(apk: File): Pair<String, Long>? {
    return try {
        val pm = context.packageManager
        val info = pm.getPackageArchiveInfo(apk.absolutePath, 0) ?: return null
        val pkg = info.packageName
        val ver = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P)
            info.longVersionCode
        else
            @Suppress("DEPRECATION") info.versionCode.toLong()
        pkg to ver
    } catch (_: Exception) {
        null
    }
}


        private fun hasSaiTagForUrl(config: JSONObject, url: String): Boolean {
            fun arrHasSai(arr: JSONArray): Boolean {
                for (k in 0 until arr.length()) if (arr.getString(k).equals("SAI", true)) return true
                return false
            }
            val apps = config.optJSONArray("apps") ?: return false
            for (i in 0 until apps.length()) {
                val app = apps.getJSONObject(i)
                if (app.optString("url") == url) return arrHasSai(app.getJSONArray("tags"))
            }
            return false
        }




        // –°—Ç–∞—Ä–∞—è —Ñ—É–Ω–∫—Ü–∏—è - –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –∑–∞–º–µ–Ω–µ–Ω–∞ –Ω–∞ installApkItem
        @Deprecated("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ installApkItem –≤–º–µ—Å—Ç–æ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏")
        private fun installNextApk() {
            if (installQueue.isEmpty()) {
                sendProgressToWebView(totalApks, totalApks, 100)
                sendMessageToWebView("‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ë–æ–ª—å—à–µ –Ω–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π.")
                return
            }

                // –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –±–µ–∑ –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∞ (–∏–Ω–∫—Ä–µ–º–µ–Ω—Ç –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏)
                val displayIndex = (currentApkIndex + 1).coerceAtMost(totalApks)
                sendProgressToWebView(displayIndex, totalApks, 0)
                updateBlockingInstallProgress()

            val item = installQueue.removeAt(0)
            if (item.viaSession) {
                // –ò–∑–≤–ª–µ–∫–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ APK
                val meta = extractApkMeta(context, item.file)
                
                val sai = SessionApkInstaller(context, { msg, icon ->
                    sendMessageToWebView(msg, icon)
                    Handler(Looper.getMainLooper()).post {
                        webView.evaluateJavascript("hideProgress()", null)
                    }
                }, meta.iconBase64)
                sai.onFinal = {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –∫–æ–ª–±—ç–∫ –≤–º–µ—Å—Ç–æ –∂–µ—Å—Ç–∫–æ–≥–æ —Ç–∞–π–º–µ—Ä–∞
                    sai.unregister()
                }
                sai.register()
                sai.install(listOf(item.file))
            } else {
                val uri = FileProvider.getUriForFile(context, "${context.packageName}.provider", item.file)
                val intent = Intent(Intent.ACTION_VIEW).apply {
                    setDataAndType(uri, "application/vnd.android.package-archive")
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                }
                context.startActivity(intent)
            }
        }


        private fun sendProgressToWebView(current: Int, total: Int, percent: Int) {
            Handler(Looper.getMainLooper()).post {
                val safeTotal = if (total > 0) total else 1
                webView.evaluateJavascript("updateProgress($current, $safeTotal, $percent)", null)
            }
        }


        private fun tagsMatch(groupTags: JSONArray, itemTags: JSONArray): Boolean {
            for (i in 0 until groupTags.length()) {
                val tag = groupTags.getString(i)
                for (j in 0 until itemTags.length()) {
                    if (tag.equals(itemTags.getString(j), ignoreCase = true)) {
                        return true
                    }
                }
            }
            return false
        }

        private fun downloadApkToCache(urlStr: String, displayName: String): File? {
            return try {
                val fileName = "install_${System.currentTimeMillis()}.apk"
                val file = File(context.cacheDir, fileName)

                val url = URL(urlStr)
                val connection = url.openConnection() as HttpURLConnection
                connection.connect()

                val length = connection.contentLength
                val input = BufferedInputStream(connection.inputStream)
                val output = FileOutputStream(file)

                val data = ByteArray(4096)
                var total: Long = 0
                var count: Int
                var lastPercent = -1

                while (input.read(data).also { count = it } != -1) {
                    total += count
                    output.write(data, 0, count)

                    if (length > 0) {
                        val percent = (total * 100 / length).toInt()
                        if (percent != lastPercent) {
                            lastPercent = percent

                            Handler(Looper.getMainLooper()).post {
                                val safeName = jsQuote(displayName)
                                webView.evaluateJavascript(
                                    "updateProgress(${currentApkIndex + 1}, $totalApks, $percent, '$safeName')",
                                    null
                                )
                            }
                        }
                    }
                }

                output.flush()
                input.close()
                output.close()
                file
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }

        private fun shouldTreatAsApks(url: String): Boolean {
            val u = url.lowercase()
            return u.contains(".apks") || u.contains("%2eapks")
        }

        private fun downloadToCacheWithExt(urlStr: String, displayName: String, ext: String): File? {
            return try {
                val safeExt = if (ext.equals("apks", true)) "apks" else "apk"
                val fileName = "install_${System.currentTimeMillis()}.$safeExt"
                val file = File(context.cacheDir, fileName)

                val url = URL(urlStr)
                val connection = url.openConnection() as HttpURLConnection
                connection.connect()

                val length = connection.contentLength
                val input = BufferedInputStream(connection.inputStream)
                val output = FileOutputStream(file)

                val data = ByteArray(4096)
                var total: Long = 0
                var count: Int
                var lastPercent = -1

                while (input.read(data).also { count = it } != -1) {
                    total += count
                    output.write(data, 0, count)

                    if (length > 0) {
                        val percent = (total * 100 / length).toInt()
                        if (percent != lastPercent) {
                            lastPercent = percent

                            Handler(Looper.getMainLooper()).post {
                                val safeName = jsQuote(displayName)
                                webView.evaluateJavascript(
                                    "updateProgress(${currentApkIndex + 1}, $totalApks, $percent, '$safeName')",
                                    null
                                )
                            }
                        }
                    }
                }

                output.flush()
                input.close()
                output.close()
                file
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }

        fun unzipApksContainer(apksFile: File): List<File> {
            val outDir = File(context.cacheDir, "splits_${System.currentTimeMillis()}")
            if (!outDir.exists()) outDir.mkdirs()
            val extracted = mutableListOf<File>()
            ZipInputStream(FileInputStream(apksFile)).use { zis ->
                var entry: ZipEntry? = zis.nextEntry
                val buffer = ByteArray(8192)
                while (entry != null) {
                    val name = entry.name
                    val outFile = File(outDir, name.substringAfterLast('/'))
                    if (!entry.isDirectory) {
                        FileOutputStream(outFile).use { fos ->
                            var len: Int
                            while (zis.read(buffer).also { len = it } > 0) {
                                fos.write(buffer, 0, len)
                            }
                        }
                        if (outFile.extension.equals("apk", true)) {
                            extracted.add(outFile)
                        } else {
                            // –Ω–µ –Ω—É–∂–Ω—ã–π —Ñ–∞–π–ª ‚Äî —É–¥–∞–ª–∏–º
                            runCatching { outFile.delete() }
                        }
                    }
                    zis.closeEntry()
                    entry = zis.nextEntry
                }
            }
            // –û—Ç—Å–æ—Ä—Ç–∏—Ä—É–µ–º: base.apk –ø–µ—Ä–≤—ã–º, –∑–∞—Ç–µ–º –ø–æ –∏–º–µ–Ω–∏
            return extracted.sortedWith(compareBy<File> { !it.name.equals("base.apk", true) }.thenBy { it.name })
        }



        private fun downloadFile(urlStr: String, targetFolder: String) {
            try {
                val fileName = urlStr.toUri().lastPathSegment ?: return

                val targetDir = resolveBackupTargetDir(targetFolder)

                if (!targetDir.exists()) {
                    if (!targetDir.mkdirs()) return
                }

                val outFile = File(targetDir, fileName)

                val url = URL(urlStr)
                val connection = url.openConnection() as HttpURLConnection
                connection.connect()

                val input = BufferedInputStream(connection.inputStream)
                val output = FileOutputStream(outFile)

                input.copyTo(output)
                input.close()
                output.close()

                (context as? MainActivity)?.registerLocalBackup(outFile)

            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        private fun resolveBackupTargetDir(targetFolder: String): File {
            val normalized = targetFolder.trim()
            val baseDir = when {
                normalized.startsWith("Documents", true) -> Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS)
                normalized.startsWith("Download", true) -> Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
                else -> Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            }
            val relativePath = normalized.substringAfter("/", "")
            return if (relativePath.isNotEmpty()) File(baseDir, relativePath) else baseDir
        }

        private fun installApkDirectly(file: File) {
            Handler(Looper.getMainLooper()).post {
                webView.evaluateJavascript("hideProgress()", null)
            }

            val uri = FileProvider.getUriForFile(context, "${context.packageName}.provider", file)

            val intent = Intent(Intent.ACTION_VIEW).apply {

                setDataAndType(uri, "application/vnd.android.package-archive")
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }

            context.startActivity(intent)
        }

        fun sendMessageToWebView(message: String, icon: String? = null) {
            Handler(Looper.getMainLooper()).post {
                try {
                    val safeMessage = message.replace("'", "\\'")
                    val safeIcon = icon?.replace("'", "\\'") ?: ""
                    if (icon != null) {
                        // –î–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π —Å –∏–∫–æ–Ω–∫–æ–π –∏—Å–ø–æ–ª—å–∑—É–µ–º showStatus —Å HTML (–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –≤–≤–µ—Ä—Ö—É)
                        webView.evaluateJavascript("showStatus('$safeMessage <img src=\"data:image/png;base64,$safeIcon\" style=\"height:20px; width:20px; object-fit:contain; vertical-align:bottom; margin-left:5px;\">', '#fff')", null)
                    } else {
                        webView.evaluateJavascript("showStatus('$safeMessage', '#fff')", null) // –±–µ–ª—ã–π —Ç–µ–∫—Å—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }

        @JavascriptInterface
        fun runAdbShellCommand(rawCommand: String?, rawLabel: String?) {
            runAdbShellCommand(rawCommand, rawLabel, false)
        }

        @JavascriptInterface
        fun runAdbShellCommand(rawCommand: String?, rawLabel: String?, silent: Boolean) {
            val command = rawCommand?.trim().orEmpty()
            if (command.isEmpty()) {
                if (!silent) {
                    showToast("‚ùå –ö–æ–º–∞–Ω–¥–∞ ADB –Ω–µ –∑–∞–¥–∞–Ω–∞", "error")
                } else {
                    Log.w(ADB_LOG_TAG, "runAdbShellCommand: empty command")
                }
                return
            }
            val label = rawLabel?.takeIf { it.isNotBlank() } ?: command

            val adbManager = obtainConnectedAdb(silent = silent)
            if (adbManager == null) {
                if (silent) {
                    Log.w(ADB_LOG_TAG, "runAdbShellCommand: ADB unavailable for $command")
                }
                return
            }

            if (!silent) {
                showToast("‚è≥ –í—ã–ø–æ–ª–Ω—è—é: $label", "info")
            }
            Thread {
                val (success, output) = runAdbCommand(adbManager, command)
                Log.d(ADB_LOG_TAG, "[WebADB] $command ‚Üí success=$success, output=$output")
                Handler(Looper.getMainLooper()).post {
                    if (silent) return@post
                    if (success) {
                        showToast("‚úÖ $label –≤—ã–ø–æ–ª–Ω–µ–Ω–æ", "success")
                    } else {
                        val reason = output.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞" }
                        showToast("‚ùå $label: $reason", "error")
                    }
                }
            }.start()
        }

        @JavascriptInterface
        fun runAdbShellCommandWithResult(rawCommand: String?, rawLabel: String?, silent: Boolean): Boolean {
            val command = rawCommand?.trim().orEmpty()
            if (command.isEmpty()) {
                if (!silent) {
                    showToast("‚ùå –ö–æ–º–∞–Ω–¥–∞ ADB –Ω–µ –∑–∞–¥–∞–Ω–∞", "error")
                } else {
                    Log.w(ADB_LOG_TAG, "runAdbShellCommandWithResult: empty command")
                }
                return false
            }
            val label = rawLabel?.takeIf { it.isNotBlank() } ?: command

            val adbManager = obtainConnectedAdb(silent = silent)
            if (adbManager == null) {
                if (silent) {
                    Log.w(ADB_LOG_TAG, "runAdbShellCommandWithResult: ADB unavailable for $command")
                }
                return false
            }

            if (!silent) {
                showToast("‚è≥ –í—ã–ø–æ–ª–Ω—è—é: $label", "info")
            }

            val (success, output) = runAdbCommand(adbManager, command)
            if (!silent) {
                Handler(Looper.getMainLooper()).post {
                    if (success) {
                        showToast("‚úÖ $label –≤—ã–ø–æ–ª–Ω–µ–Ω–æ", "success")
                    } else {
                        val reason = output.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞" }
                        showToast("‚ùå $label: $reason", "error")
                    }
                }
            } else if (!success) {
                Log.w(ADB_LOG_TAG, "runAdbShellCommandWithResult: $command failed ‚Üí $output")
            }
            return success
        }

        @JavascriptInterface
        fun grantUnknownSourcesPermissionsAsync() {
            Thread {
                val adb = obtainConnectedAdb(silent = false) ?: return@Thread
                val packages = queryRemoteUserPackages()
                    .map { it.trim() }
                    .filter { it.isNotEmpty() && it != context.packageName && !autoPermissionExcludedPackages.contains(it) }
                if (packages.isEmpty()) {
                    showToast("–ù–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è APK", "warning")
                    return@Thread
                }
                showToast("–û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–∫—É APK‚Ä¶", "info")

                val failures = mutableListOf<String>()
                packages.forEach { pkg ->
                    val ok = try {
                        val primary = runAdbCommand(adb, "appops set $pkg REQUEST_INSTALL_PACKAGES allow")
                        primary.first || runAdbCommand(adb, "appops set --uid $pkg REQUEST_INSTALL_PACKAGES allow").first
                    } catch (err: Exception) {
                        Log.w(ADB_LOG_TAG, "[UnknownSources] –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã–¥–∞—á–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –¥–ª—è $pkg", err)
                        false
                    }
                    if (!ok) {
                        failures += pkg
                        Log.w(ADB_LOG_TAG, "[UnknownSources] –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è $pkg")
                    }
                }

                val total = packages.size
                val granted = total - failures.size
                val message = when {
                    granted <= 0 -> "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è APK"
                    granted == total -> "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–∫—É APK –≤—ã–¥–∞–Ω–æ –¥–ª—è $total –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π"
                    else -> "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–∫—É APK –æ–±–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è $granted –∏–∑ $total –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π"
                }
                val type = when {
                    granted <= 0 -> "error"
                    granted == total -> "success"
                    else -> "info"
                }
                showToast(message, type)
            }.start()
        }

        @JavascriptInterface
        fun grantMicrophonePermissionsAsync() {
            Thread {
                val adb = obtainConnectedAdb(silent = false) ?: return@Thread
                val packages = (microphonePermissionPackages + queryRemoteUserPackages())
                    .map { it.trim() }
                    .filter { it.isNotEmpty() && it != context.packageName && !autoPermissionExcludedPackages.contains(it) }
                    .distinct()
                if (packages.isEmpty()) {
                    showToast("–ù–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –¥–ª—è –≤—ã–¥–∞—á–∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞", "warning")
                    return@Thread
                }
                showToast("–í—ã–¥–∞—ë–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞‚Ä¶", "info")

                val failures = mutableListOf<String>()
                packages.forEach { pkg ->
                    val success = try {
                        val (ok, output) = runAdbCommand(adb, "pm grant $pkg $microphonePermission")
                        if (!ok) {
                            Log.w(ADB_LOG_TAG, "[MicrophonePermission] pm grant failed for $pkg: ${output.take(120)}")
                        }
                        ok
                    } catch (err: Exception) {
                        Log.w(ADB_LOG_TAG, "[MicrophonePermission] –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –≤—ã–¥–∞—á–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –¥–ª—è $pkg", err)
                        false
                    }
                    if (!success) {
                        failures += pkg
                    }
                }

                val total = packages.size
                val granted = total - failures.size
                val message = when {
                    granted <= 0 -> "–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–¥–∞—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞"
                    granted == total -> "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è $total –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π"
                    else -> "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è $granted –∏–∑ $total –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π"
                }
                val type = when {
                    granted <= 0 -> "error"
                    granted == total -> "success"
                    else -> "info"
                }
                showToast(message, type)
            }.start()
        }

        @JavascriptInterface
        fun getCurrentInputMethod(): String {
            return try {
                val localValue = Settings.Secure.getString(context.contentResolver, Settings.Secure.DEFAULT_INPUT_METHOD)
                    ?.trim()
                    .orEmpty()
                if (localValue.isNotEmpty()) return localValue

                val adb = obtainConnectedAdb(silent = true) ?: return localValue

                val (success, output) = runAdbCommand(adb, "settings --user 0 get secure default_input_method")
                if (success) output.trim() else localValue
            } catch (e: Exception) {
                Log.w(ADB_LOG_TAG, "getCurrentInputMethod error", e)
                ""
            }
        }

        private fun jsQuote(value: String): String = value
            .replace("\\", "\\\\")
            .replace("'", "\\'")
            .replace("\"", "\\\"")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("\t", "\\t")

        @JavascriptInterface
        fun disablePackage(packageInput: String) {
            Thread {
                val toggleRequest = parseToggleRequest(packageInput)
                val packages = toggleRequest.packages
                if (packages.isEmpty()) {
                    showToast("‚ùå –°–ø–∏—Å–æ–∫ –ø–∞–∫–µ—Ç–æ–≤ –ø—É—Å—Ç", "error")
                    return@Thread
                }

                val adb = (context as? MainActivity)?.adbManager
                if (adb == null) {
                    showToast("‚ùå ADB –º–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "error")
                    return@Thread
                }

                val connected = adb.ensureConnected { msg -> showToast(msg) }
                if (!connected) {
                    showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ ADB", "error")
                    return@Thread
                }

                showToast("üîÅ –í—ã–ø–æ–ª–Ω—è—é ${if (toggleRequest.disable) "–æ—Ç–∫–ª—é—á–µ–Ω–∏–µ" else "–≤–∫–ª—é—á–µ–Ω–∏–µ"} –ø–∞–∫–µ—Ç–æ–≤", "info")

                val quotedPackages = packages
                    .map { it.trim() }
                    .filter { it.isNotEmpty() }
                    .joinToString(" ") { "\"$it\"" }

                if (quotedPackages.isNotEmpty()) {
                    val shell = if (toggleRequest.disable) {
                        """for p in $quotedPackages; do pm disable-user --user 0 "${'$'}p"; pm clear --user 0 "${'$'}p"; done"""
                    } else {
                        """for p in $quotedPackages; do pm enable --user 0 "${'$'}p"; done"""
                    }
                    runAdbCommand(adb, shell)
                }

                val actionMsg = if (toggleRequest.disable) "–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –∏ –æ—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω—ã" else "–í–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ"
                showToast("‚úÖ $actionMsg", "success")
            }.start()
        }

        @JavascriptInterface
        fun confirmWipeThirdPartyApps() {
            Handler(Looper.getMainLooper()).post {
                wipeCancelled = false
                showInstallPrompt(
                    title = "–£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π",
                    message = "–ë—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã –≤—Å–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è, –∫—Ä–æ–º–µ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?",
                    installLabel = "–£–¥–∞–ª–∏—Ç—å",
                    onInstall = {
                        showWipeProgressDialog()
                        wipeThirdPartyAppsInternal()
                    },
                    laterLabel = "–û—Ç–º–µ–Ω–∞",
                    onLater = {
                        wipeCancelled = true
                        sendMessageToWebView("‚úÖ –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
                    },
                    cancelable = true
                )
            }
        }

        private fun wipeThirdPartyAppsInternal() {
            Thread {
                try {
                    val adb = (context as? MainActivity)?.adbManager
                    if (adb == null) {
                        hideBlockingDialog()
                        showToast("‚ùå ADB –º–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "error")
                        return@Thread
                    }

                    val connected = adb.ensureConnected { msg -> showToast(msg) }
                    if (!connected) {
                        hideBlockingDialog()
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ ADB", "error")
                        return@Thread
                    }

                    showToast("üßπ –ò—â—É —Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è‚Ä¶", "info")

                    val (packages, errorMessage) = fetchThirdPartyPackages(adb)

                    if (packages.isEmpty() && errorMessage != null) {
                        hideBlockingDialog()
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–∞–∫–µ—Ç–æ–≤", "error")
                        sendMessageToWebView("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–∞–∫–µ—Ç–æ–≤: $errorMessage")
                        return@Thread
                    }

                    if (packages.isEmpty()) {
                        hideBlockingDialog()
                        showToast("‚ÑπÔ∏è –°—Ç–æ—Ä–æ–Ω–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "info")
                        sendMessageToWebView("‚ÑπÔ∏è –ù–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è")
                        return@Thread
                    }

                    if (wipeCancelled) {
                        hideBlockingDialog()
                        sendMessageToWebView("‚ÑπÔ∏è –£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
                        showToast("‚ÑπÔ∏è –£–¥–∞–ª–µ–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ", "info")
                        return@Thread
                    }

                    showToast("üóë –£–¥–∞–ª—è—é ${packages.size} –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π‚Ä¶", "info")

                    val quotedPackages = packages.joinToString(" ") { "\"$it\"" }
                    val shell = """
for p in $quotedPackages; do
  pm uninstall --user 0 "${'$'}p" >/dev/null 2>&1 && echo "OK:${'$'}p" || echo "ERR:${'$'}p"
done
""".trimIndent()

                    val (batchOk, batchOut) = runAdbCommand(adb, shell)
                    val lines = batchOut
                        .lineSequence()
                        .map { it.trim() }
                        .filter { it.isNotEmpty() }
                        .toList()
                    val removed = lines.filter { it.startsWith("OK:") }.map { it.removePrefix("OK:") }
                    val failed = lines.filter { it.startsWith("ERR:") }.map { it.removePrefix("ERR:") }

                    removed.forEach { sendMessageToWebView("‚úÖ –£–¥–∞–ª–µ–Ω–æ: $it") }
                    failed.forEach { sendMessageToWebView("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å $it") }

                    hideBlockingDialog()
                    if (wipeCancelled) {
                        sendMessageToWebView("‚ÑπÔ∏è –£–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
                        showToast("‚ÑπÔ∏è –£–¥–∞–ª–µ–Ω–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ", "info")
                        requestStorageUsageUpdate()
                    } else {
                        enableSystemLaunchers()
                        if (!batchOk && failed.isEmpty()) {
                            showToast("‚ö†Ô∏è –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è", "error")
                            sendMessageToWebView("‚ö†Ô∏è –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: ${batchOut.ifBlank { "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è" }}")
                        } else if (failed.isEmpty()) {
                            showToast("‚úÖ –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ", "success")
                            sendMessageToWebView("‚úÖ –£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –∑–∞–≤–µ—Ä—à–µ–Ω–æ")
                        } else {
                            showToast("‚ÑπÔ∏è –£–¥–∞–ª–µ–Ω–æ: ${removed.size}, –æ—à–∏–±–æ–∫: ${failed.size}", "info")
                            sendMessageToWebView("‚ÑπÔ∏è –£–¥–∞–ª–µ–Ω–æ: ${removed.size}, –æ—à–∏–±–æ–∫: ${failed.size}")
                        }
                        requestStorageUsageUpdate()
                        
                    }
                } catch (e: Exception) {
                    hideBlockingDialog()
                    showToast("‚ùå –û—à–∏–±–∫–∞: ${e.message}", "error")
                    sendMessageToWebView("‚ùå –°–±–æ–π —É–¥–∞–ª–µ–Ω–∏—è: ${e.message}")
                }
            }.start()
        }

        private fun enableSystemLaunchers() {
            val payload = org.json.JSONObject().apply {
                val array = org.json.JSONArray()
                launcherPackages.forEach { array.put(it) }
                put("packages", array)
                put("disable", false) // –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á–∞–µ–º
            }

            sendMessageToWebView("üîÑ –í–∫–ª—é—á–∞—é —Å–∏—Å—Ç–µ–º–Ω—ã–µ –ª–∞—É–Ω—á–µ—Ä—ã...")
            disablePackage(payload.toString())
        }

        private fun fetchThirdPartyPackages(adb: AdbConnectionManager): Pair<List<String>, String?> {
            val errors = mutableListOf<String>()
            var hasSuccessfulQuery = false
            val exclusions = baseWipeExclusions + context.packageName
            val candidates = listOf(
                "pm list packages --user 0 -3",
                "pm list packages -3",
                "cmd package list packages --user 0 --third-party",
                "cmd package list packages --third-party"
            )

            val discovered = linkedSetOf<String>()
            for (cmd in candidates) {
                val (success, output) = runAdbCommand(adb, cmd)
                if (success) {
                    hasSuccessfulQuery = true
                    val packages = parsePackageListOutput(output)
                        .filter { it !in exclusions }
                    if (packages.isNotEmpty()) {
                        discovered += packages
                    }
                } else {
                    val message = output.takeIf { it.isNotBlank() } ?: "–ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç"
                    errors += "$cmd ‚Üí $message"
                }
            }

            if (discovered.isEmpty()) {
                val message = if (!hasSuccessfulQuery && errors.isNotEmpty()) {
                    errors.joinToString("; ")
                } else {
                    null
                }
                return emptyList<String>() to message
            }

            val verified = discovered
                .filter { it !in exclusions }
                .filter { isThirdPartyPackage(adb, it) }

            return verified to null
        }

        private fun parsePackageListOutput(output: String): List<String> {
            if (output.isBlank()) return emptyList()
            return output
                .lineSequence()
                .map { it.trim() }
                .mapNotNull { line ->
                    val idx = line.indexOf("package:")
                    if (idx == -1) return@mapNotNull null
                    line.substring(idx + "package:".length)
                        .substringBefore(' ')
                        .substringBefore('\t')
                        .trim()
                        .takeIf { it.isNotEmpty() }
                }
                .distinct()
                .toList()
        }

        private fun isThirdPartyPackage(adb: AdbConnectionManager, packageName: String): Boolean {
            val dump = obtainPackageDump(adb, packageName)
            if (dump.isNotBlank()) {
                val lines = dump.lineSequence().map { it.trim() }.filter { it.isNotEmpty() }.toList()
                val flagsLine = lines.firstOrNull { it.startsWith("pkgFlags", ignoreCase = true) }
                val flagTokens = flagsLine?.let { parseFlagTokens(it) } ?: emptySet()
                if (flagTokens.any { it in systemFlagMarkers }) {
                    return false
                }

                val codePathLine = lines.firstOrNull { it.startsWith("codePath=", ignoreCase = true) }
                if (codePathLine != null) {
                    val pathLower = codePathLine.substringAfter('=').trim().lowercase(Locale.ROOT)
                    if (systemPathPrefixes.any { pathLower.startsWith(it) }) {
                        return false
                    }
                    if (userAppPathMarkers.any { pathLower.contains(it) }) {
                        return true
                    }
                }

                val resourcePathLine = lines.firstOrNull { it.startsWith("resourcePath=", ignoreCase = true) }
                if (resourcePathLine != null) {
                    val pathLower = resourcePathLine.substringAfter('=').trim().lowercase(Locale.ROOT)
                    if (systemPathPrefixes.any { pathLower.startsWith(it) }) {
                        return false
                    }
                }

                if (flagTokens.isNotEmpty()) {
                    // –§–ª–∞–≥–æ–≤ SYSTEM –Ω–µ—Ç, codePath –Ω–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å–∏—Å—Ç–µ–º–Ω—ã–π —Ä–∞–∑–¥–µ–ª ‚Äî —Å—á–∏—Ç–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    return true
                }
            }

            val (success, output) = runAdbCommand(adb, "pm path $packageName")
            if (!success || output.isBlank()) return false
            val lower = output.lowercase(Locale.ROOT)
            if (systemPathPrefixes.any { lower.contains(it) }) {
                return false
            }
            return userAppPathMarkers.any { lower.contains(it) }
        }

        private fun obtainPackageDump(adb: AdbConnectionManager, packageName: String): String {
            val commands = listOf(
                "cmd package dump $packageName",
                "dumpsys package $packageName"
            )
            for (cmd in commands) {
                val (success, output) = runAdbCommand(adb, cmd)
                if (success && output.isNotBlank()) {
                    return output
                }
            }
            return ""
        }

        private fun parseFlagTokens(flagsLine: String): Set<String> {
            val raw = flagsLine.substringAfter('[', flagsLine)
                .substringBefore(']', flagsLine)
            if (raw.isBlank()) return emptySet()
            return raw.split(',', ' ', '\t')
                .map { it.trim() }
                .filter { it.isNotEmpty() }
                .map { it.uppercase(Locale.ROOT) }
                .toSet()
        }

        private fun showWipeProgressDialog() {
            Handler(Looper.getMainLooper()).post {
                wipeCancelled = false

                val dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_install_prompt, null)
                val titleView = dialogView.findViewById<TextView>(R.id.dialogTitle)
                val messageView = dialogView.findViewById<TextView>(R.id.dialogMessage)
                val spinnerView = dialogView.findViewById<ImageView>(R.id.dialogSpinner)
                val permissionsContainer = dialogView.findViewById<LinearLayout>(R.id.permissionsContainer)
                val buttonRow = dialogView.findViewById<LinearLayout>(R.id.buttonRow)
                val btnCancel = dialogView.findViewById<Button>(R.id.btnInstall)
                val btnLater = dialogView.findViewById<Button>(R.id.btnLater)

                titleView.text = "–£–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω–Ω–∏—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π"
                messageView.text = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ. –í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —É–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π‚Ä¶"
                spinnerView.visibility = View.VISIBLE
                (spinnerView.drawable as? Animatable)?.start()
                permissionsContainer.visibility = View.GONE
                buttonRow.gravity = Gravity.END or Gravity.CENTER_VERTICAL

                btnLater.visibility = View.GONE

                btnCancel.text = "–û—Ç–º–µ–Ω–∞"
                btnCancel.setOnClickListener {
                    wipeCancelled = true
                    hideBlockingDialog()
                    sendMessageToWebView("‚ÑπÔ∏è –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —É–¥–∞–ª–µ–Ω–∏–µ‚Ä¶")
                    showToast("‚ÑπÔ∏è –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —É–¥–∞–ª–µ–Ω–∏–µ", "info")
                }

                blockingDialog?.dismiss()
                blockingDialog = AlertDialog.Builder(context, R.style.CustomDialogTheme)
                    .setView(dialogView)
                    .setCancelable(false)
                    .create()

                blockingDialog?.apply {
                    setCanceledOnTouchOutside(false)
                    show()
                }
                // –û–±–Ω–æ–≤–∏–º —Ç–µ–∫—Å—Ç –Ω–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –ø—Ä–æ–≥—Ä–µ—Å—Å, –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ
                updateBlockingInstallProgress()
            }
        }

        private fun parseToggleRequest(rawValue: String?): ToggleRequest {
            if (rawValue.isNullOrBlank()) return ToggleRequest(emptyList(), disable = true)
            return runCatching {
                val obj = JSONObject(rawValue)
                val packages = obj.optJSONArray("packages")?.let { arr ->
                    (0 until arr.length())
                        .mapNotNull { arr.optString(it)?.trim() }
                        .filter { it.isNotEmpty() }
                } ?: emptyList()
                val disable = obj.optBoolean("disable", true)
                ToggleRequest(packages.distinct(), disable)
            }.getOrElse {
                ToggleRequest(parseCommaSeparated(rawValue), disable = true)
            }
        }

        private fun parseCommaSeparated(value: String): List<String> =
            value.split(',')
                .map { it.trim() }
                .filter { it.isNotEmpty() }
                .distinct()

        private fun runAdbCommand(adb: AdbConnectionManager, command: String): Pair<Boolean, String> {
            val output = StringBuilder()
            val success = adb.runShellCommand(command) { chunk -> output.append(chunk) }
            return success to output.toString().trim()
        }

        private fun obtainConnectedAdb(silent: Boolean = false): AdbConnectionManager? {
            val activity = context as? MainActivity ?: return null
            if (!activity::adbManager.isInitialized) {
                if (!silent) {
                    showToast("‚ùå ADB –º–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "error")
                }
                return null
            }
            val adb = activity.adbManager
            val status = adb.getCurrentStatus()
            if (!status.isConnected) {
                if (!silent) {
                    showToast("‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ADB", "error")
                }
                activity.handleAdbConnectionLost()
                return null
            }
            val alive = adb.silentPing()
            if (!alive) {
                activity.handleAdbConnectionLost()
                if (!silent) {
                    showToast("‚ùå ADB –æ—Ç–∫–ª—é—á–∏–ª—Å—è", "error")
                }
                return null
            }
            activity.handleAdbConnectionAlive()
            return adb
        }

        private fun fetchScreenSaverState(adb: AdbConnectionManager): ScreenSaverState? {
            val enabledValue = adbValue(adb, "settings get secure screensaver_enabled")
            val enabled = enabledValue == "1"
            val currentComponent = adbValue(adb, "settings get secure screensaver_components")
                ?: adbValue(adb, "settings get secure screensaver_default_component")
            val screenTimeout = adbValue(adb, "settings get system screen_off_timeout")?.toLongOrNull()
            val sleepTimeout = adbValue(adb, "settings get secure sleep_timeout")?.toLongOrNull()
            val componentInstalled = currentComponent
                ?.substringBefore('/')
                ?.takeIf { it.isNotBlank() }
                ?.let { isPackageInstalled(adb, it) }
                ?: true
            val label = friendlyDreamLabel(currentComponent)
            val displayLabel = when {
                currentComponent.isNullOrBlank() -> "–ù–µ –≤—ã–±—Ä–∞–Ω–∞"
                !componentInstalled -> "${label ?: currentComponent} (–Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ)"
                else -> label ?: currentComponent
            }
            return ScreenSaverState(
                enabled = enabled,
                currentLabel = displayLabel,
                screenTimeoutMs = screenTimeout,
                sleepTimeoutMs = sleepTimeout,
                component = currentComponent
            )
        }

        private fun adbValue(adb: AdbConnectionManager, command: String): String? {
            val (success, output) = runAdbCommand(adb, command)
            if (!success) return null
            val value = output.trim()
            if (value.equals("null", true) || value.isEmpty()) return null
            return value
        }

        private fun friendlyDreamLabel(component: String?): String? {
            if (component.isNullOrBlank()) return null
            KNOWN_DREAM_LABELS[component]?.let { return it }
            if (component.startsWith("com.google.android")) {
                return "–°–∏—Å—Ç–µ–º–Ω–∞—è –∑–∞—Å—Ç–∞–≤–∫–∞"
            }
            return try {
                val cn = ComponentName.unflattenFromString(component) ?: return component
                val pm = context.packageManager
                val appInfo = pm.getApplicationInfo(cn.packageName, 0)
                pm.getApplicationLabel(appInfo)?.toString() ?: component
            } catch (_: Exception) {
                component
            }
        }

        private fun resolveDreamComponent(adb: AdbConnectionManager, packageName: String): String? {
            KNOWN_DREAM_COMPONENTS[packageName]?.let { return it }
            val dump = obtainPackageDump(adb, packageName)
            if (dump.isBlank()) return null
            val regex = Regex(
                "service\\s+([\\w\\.]+)/([\\w\\.]+|\\.[\\w\\.]+).*?android.permission.BIND_DREAM_SERVICE",
                setOf(RegexOption.IGNORE_CASE, RegexOption.DOT_MATCHES_ALL)
            )
            val match = regex.find(dump)
            if (match != null) {
                val pkg = match.groupValues[1]
                val cls = match.groupValues[2]
                val fullCls = if (cls.startsWith(".")) pkg + cls else cls
                return "$pkg/$fullCls"
            }
            return null
        }

        private fun isPackageInstalled(adb: AdbConnectionManager, packageName: String): Boolean {
            if (packageName.isBlank()) return false
            val (_, output) = runAdbCommand(adb, "pm path $packageName")
            return output
                .lineSequence()
                .map { it.trim() }
                .any { it.startsWith("package:") }
        }

        private fun sendScreenSaverStateToWeb(state: ScreenSaverState?) {
            val payload = JSONObject().apply {
                put("enabled", state?.enabled ?: false)
                put("current", state?.currentLabel ?: "‚Äî")
                if (state?.screenTimeoutMs != null) {
                    put("screenTimeoutMs", state.screenTimeoutMs)
                } else {
                    put("screenTimeoutMs", JSONObject.NULL)
                }
                if (state?.sleepTimeoutMs != null) {
                    put("sleepTimeoutMs", state.sleepTimeoutMs)
                } else {
                    put("sleepTimeoutMs", JSONObject.NULL)
                }
                if (state?.component != null) {
                    put("component", state.component)
                } else {
                    put("component", JSONObject.NULL)
                }
            }
            Handler(Looper.getMainLooper()).post {
                try {
                    webView.evaluateJavascript("updateScreenSaverState(${payload.toString()})", null)
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }

        private fun installApkStandardFromUrl(url: String, displayName: String) {
            Thread {
                try {
                    val file = downloadToCacheWithExt(url, displayName, "apk")
                    if (file == null) {
                        showToast("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å $displayName", "error")
                        return@Thread
                    }
                    Handler(Looper.getMainLooper()).post {
                        showToast("‚è≥ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ $displayName‚Ä¶", "info")
                        installApkDirectly(file)
                    }
                } catch (e: Exception) {
                    showToast("‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ $displayName: ${e.message}", "error")
                }
            }.start()
        }

        private fun showInstallPrompt(
            title: String,
            message: String,
            installLabel: String = "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å",
            onInstall: () -> Unit,
            onLater: () -> Unit = {}
        ) {
            runOnUiThread {
                val dialogView = LayoutInflater.from(context).inflate(R.layout.dialog_install_prompt, null)
                val dialog = AlertDialog.Builder(context, R.style.CustomDialogTheme)
                    .setView(dialogView)
                    .setCancelable(false)
                    .create()

                dialogView.findViewById<TextView>(R.id.dialogTitle).text = title
                dialogView.findViewById<TextView>(R.id.dialogMessage).text = message
                dialogView.findViewById<Button>(R.id.btnInstall).apply {
                    val ripple = ContextCompat.getDrawable(context, R.drawable.ripple_dialog_button)
                    foreground = ripple
                    text = installLabel
                    setOnClickListener {
                        dialog.dismiss()
                        onInstall()
                    }
                }
                dialogView.findViewById<Button>(R.id.btnLater).setOnClickListener {
                    dialog.dismiss()
                    onLater()
                }

                dialog.show()
            }
        }
    }
}
